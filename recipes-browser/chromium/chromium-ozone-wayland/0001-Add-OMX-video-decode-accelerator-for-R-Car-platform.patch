From b50a8a8c139b9a098f56f3e89a500edb9fa89a04 Mon Sep 17 00:00:00 2001
From: Damian Hobson-Garcia <dhobsong@igel.co.jp>
Date: Thu, 25 Jul 2019 17:10:35 +0900
Subject: [PATCH]  Add OMX video decode accelerator for R-Car platform

Can be enabled by setting the use_omx_codec=true gn flag and compile time.
Does not update the gpu blacklist so will still need to run chromium
with the --disable-gpu-blacklist flag for this to work.
---
 content/gpu/gpu_main.cc                       |    7 +
 media/gpu/BUILD.gn                            |   55 +-
 media/gpu/args.gni                            |    3 +
 .../gpu_video_decode_accelerator_factory.cc   |   29 +-
 .../gpu_video_decode_accelerator_factory.h    |    6 +
 media/gpu/omx/mmngr.sig                       |    8 +
 media/gpu/omx/mmngrbuf.sig                    |    8 +
 media/gpu/omx/omx.sig                         |   11 +
 media/gpu/omx/omx_stub_header.fragment        |    9 +
 .../gpu/omx/omxr_video_decode_accelerator.cc  | 1646 +++++++++++++++++
 media/gpu/omx/omxr_video_decode_accelerator.h |  365 ++++
 .../gpu/video_decode_accelerator_unittest.cc  |    6 +
 third_party/mmngr/mmngr_buf_user_public.h     |   48 +
 third_party/mmngr/mmngr_public_cmn.h          |   69 +
 third_party/mmngr/mmngr_user_public.h         |   86 +
 third_party/openmax/README.chromium           |   15 +
 third_party/openmax/il/BUILD.gn               |   13 +
 third_party/openmax/il/LICENSE                |   21 +
 third_party/openmax/il/LICENSE.rej            |   28 +
 third_party/openmax/il/OMXR_Extension.h       |  175 ++
 third_party/openmax/il/OMXR_Extension_audio.h |   91 +
 third_party/openmax/il/OMXR_Extension_h264.h  |   73 +
 third_party/openmax/il/OMXR_Extension_h264d.h |  199 ++
 third_party/openmax/il/OMXR_Extension_h264e.h |  104 ++
 third_party/openmax/il/OMXR_Extension_vdcmn.h |  298 +++
 third_party/openmax/il/OMXR_Extension_vecmn.h |  119 ++
 third_party/openmax/il/OMXR_Extension_video.h |   96 +
 third_party/openmax/il/OMX_Audio.h            | 1311 +++++++++++++
 third_party/openmax/il/OMX_Component.h        |  579 ++++++
 third_party/openmax/il/OMX_ComponentExt.h     |   61 +
 third_party/openmax/il/OMX_ContentPipe.h      |  195 ++
 third_party/openmax/il/OMX_Core.h             | 1431 ++++++++++++++
 third_party/openmax/il/OMX_CoreExt.h          |   73 +
 third_party/openmax/il/OMX_IVCommon.h         |  920 +++++++++
 third_party/openmax/il/OMX_Image.h            |  328 ++++
 third_party/openmax/il/OMX_ImageExt.h         |   55 +
 third_party/openmax/il/OMX_Index.h            |  258 +++
 third_party/openmax/il/OMX_IndexExt.h         |   90 +
 third_party/openmax/il/OMX_Other.h            |  337 ++++
 third_party/openmax/il/OMX_Types.h            |  361 ++++
 third_party/openmax/il/OMX_Video.h            | 1060 +++++++++++
 third_party/openmax/il/OMX_VideoExt.h         |  123 ++
 42 files changed, 10767 insertions(+), 3 deletions(-)
 create mode 100644 media/gpu/omx/mmngr.sig
 create mode 100644 media/gpu/omx/mmngrbuf.sig
 create mode 100644 media/gpu/omx/omx.sig
 create mode 100644 media/gpu/omx/omx_stub_header.fragment
 create mode 100644 media/gpu/omx/omxr_video_decode_accelerator.cc
 create mode 100644 media/gpu/omx/omxr_video_decode_accelerator.h
 create mode 100644 third_party/mmngr/mmngr_buf_user_public.h
 create mode 100644 third_party/mmngr/mmngr_public_cmn.h
 create mode 100644 third_party/mmngr/mmngr_user_public.h
 create mode 100644 third_party/openmax/README.chromium
 create mode 100644 third_party/openmax/il/BUILD.gn
 create mode 100644 third_party/openmax/il/LICENSE
 create mode 100644 third_party/openmax/il/LICENSE.rej
 create mode 100644 third_party/openmax/il/OMXR_Extension.h
 create mode 100644 third_party/openmax/il/OMXR_Extension_audio.h
 create mode 100644 third_party/openmax/il/OMXR_Extension_h264.h
 create mode 100644 third_party/openmax/il/OMXR_Extension_h264d.h
 create mode 100644 third_party/openmax/il/OMXR_Extension_h264e.h
 create mode 100644 third_party/openmax/il/OMXR_Extension_vdcmn.h
 create mode 100644 third_party/openmax/il/OMXR_Extension_vecmn.h
 create mode 100644 third_party/openmax/il/OMXR_Extension_video.h
 create mode 100644 third_party/openmax/il/OMX_Audio.h
 create mode 100644 third_party/openmax/il/OMX_Component.h
 create mode 100644 third_party/openmax/il/OMX_ComponentExt.h
 create mode 100644 third_party/openmax/il/OMX_ContentPipe.h
 create mode 100644 third_party/openmax/il/OMX_Core.h
 create mode 100644 third_party/openmax/il/OMX_CoreExt.h
 create mode 100644 third_party/openmax/il/OMX_IVCommon.h
 create mode 100644 third_party/openmax/il/OMX_Image.h
 create mode 100644 third_party/openmax/il/OMX_ImageExt.h
 create mode 100644 third_party/openmax/il/OMX_Index.h
 create mode 100644 third_party/openmax/il/OMX_IndexExt.h
 create mode 100644 third_party/openmax/il/OMX_Other.h
 create mode 100644 third_party/openmax/il/OMX_Types.h
 create mode 100644 third_party/openmax/il/OMX_Video.h
 create mode 100644 third_party/openmax/il/OMX_VideoExt.h

diff --git a/content/gpu/gpu_main.cc b/content/gpu/gpu_main.cc
index a838f0c..f2183de 100644
--- a/content/gpu/gpu_main.cc
+++ b/content/gpu/gpu_main.cc
@@ -100,6 +100,10 @@
 #include "media/gpu/vaapi/vaapi_wrapper.h"
 #endif
 
+#if BUILDFLAG(USE_OMX_CODEC)
+#include "media/gpu/omx/omxr_video_decode_accelerator.h"
+#endif
+
 #if defined(OS_MACOSX)
 extern "C" {
 void _LSSetApplicationLaunchServicesServerConnectionStatus(
@@ -164,6 +168,9 @@ class ContentSandboxHelper : public gpu::GpuSandboxHelper {
     media::DXVAVideoDecodeAccelerator::PreSandboxInitialization();
     media::MediaFoundationVideoEncodeAccelerator::PreSandboxInitialization();
 #endif
+#if BUILDFLAG(USE_OMX_CODEC)
+    media::OmxrVideoDecodeAccelerator::PreSandboxInitialization();
+#endif
 
     // On Linux, reading system memory doesn't work through the GPU sandbox.
     // This value is cached, so access it here to populate the cache.
diff --git a/media/gpu/BUILD.gn b/media/gpu/BUILD.gn
index db6d92d..9f1474d 100644
--- a/media/gpu/BUILD.gn
+++ b/media/gpu/BUILD.gn
@@ -18,6 +18,7 @@ buildflag_header("buildflags") {
     "USE_V4L2_CODEC=$use_v4l2_codec",
     "USE_LIBV4L2=$use_v4lplugin",
     "USE_LINUX_V4L2=$use_linux_v4l2_only",
+    "USE_OMX_CODEC=$use_omx_codec",
   ]
 }
 
@@ -36,6 +37,44 @@ if (use_v4lplugin) {
   }
 }
 
+if (use_omx_codec) {
+  action("omx_generate_stubs") {
+    extra_header = "omx/omx_stub_header.fragment"
+
+    script = "../../tools/generate_stubs/generate_stubs.py"
+    sources = [
+      "omx/omx.sig",
+      "omx/mmngr.sig",
+      "omx/mmngrbuf.sig",
+    ]
+    inputs = [
+      extra_header,
+    ]
+    stubs_filename_root = "omx_stubs"
+
+    outputs = [
+      "$target_gen_dir/omx/$stubs_filename_root.cc",
+      "$target_gen_dir/omx/$stubs_filename_root.h",
+    ]
+    args = [
+      "-i",
+      rebase_path("$target_gen_dir/omx", root_build_dir),
+      "-o",
+      rebase_path("$target_gen_dir/omx", root_build_dir),
+      "-t",
+      "posix_stubs",
+      "-e",
+      rebase_path(extra_header, root_build_dir),
+      "-s",
+      stubs_filename_root,
+      "-p",
+      "media/gpu/omx",
+    ]
+
+    args += rebase_path(sources, root_build_dir)
+  }
+}
+
 component("gpu") {
   output_name = "media_gpu"
 
@@ -255,6 +294,18 @@ component("gpu") {
     public_deps += [ "//media/gpu/vaapi" ]
   }
 
+  if (use_omx_codec) {
+      sources += get_target_outputs(":omx_generate_stubs")
+      deps += [ ":omx_generate_stubs" ]
+      sources += [
+        "omx/omxr_video_decode_accelerator.cc",
+        "omx/omxr_video_decode_accelerator.h",
+      ]
+      deps += [
+        "//third_party/openmax/il:openmax_il",
+      ]
+  }
+
   if (is_win) {
     sources += [
       "windows/d3d11_h264_accelerator.cc",
@@ -367,7 +418,7 @@ source_set("common") {
 }
 
 # TODO(watk): Run this on bots. http://crbug.com/461437
-if (is_win || is_android || use_v4l2_codec || use_vaapi) {
+if (is_win || is_android || use_v4l2_codec || use_vaapi || use_omx_codec) {
   test("video_decode_accelerator_unittest") {
     data = [
       "//media/test/data/",
@@ -393,7 +444,7 @@ if (is_win || is_android || use_v4l2_codec || use_vaapi) {
 
     configs += [ "//third_party/khronos:khronos_headers" ]
 
-    if (is_win || is_chromeos || use_v4l2_codec) {
+    if (is_win || is_chromeos || use_v4l2_codec || use_omx_codec) {
       sources = [
         "video_decode_accelerator_unittest.cc",
       ]
diff --git a/media/gpu/args.gni b/media/gpu/args.gni
index ac740ff..b94146d 100644
--- a/media/gpu/args.gni
+++ b/media/gpu/args.gni
@@ -17,4 +17,7 @@ declare_args() {
   # Indicates if VA-API-based hardware acceleration is to be used. This
   # is typically the case on x86-based ChromeOS devices.
   use_vaapi = false
+
+  # Return of the mack.  Use OMX decoder.
+  use_omx_codec = false
 }
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.cc b/media/gpu/gpu_video_decode_accelerator_factory.cc
index 4c39f8a..0a19b93 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ b/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -30,6 +30,10 @@
 #include "media/gpu/v4l2/v4l2_video_decode_accelerator.h"
 #include "ui/gl/gl_surface_egl.h"
 #endif
+#if BUILDFLAG(USE_OMX_CODEC)
+#include "media/gpu/omx/omxr_video_decode_accelerator.h"
+#include "ui/gl/gl_surface_egl.h"
+#endif
 #if defined(OS_ANDROID)
 #include "media/gpu/android/android_video_decode_accelerator.h"
 #include "media/gpu/android/android_video_surface_chooser_impl.h"
@@ -63,7 +67,7 @@ gpu::VideoDecodeAcceleratorCapabilities GetDecoderCapabilitiesInternal(
   capabilities.supported_profiles =
       DXVAVideoDecodeAccelerator::GetSupportedProfiles(gpu_preferences,
                                                        workarounds);
-#elif BUILDFLAG(USE_V4L2_CODEC) || BUILDFLAG(USE_VAAPI)
+#elif BUILDFLAG(USE_V4L2_CODEC) || BUILDFLAG(USE_VAAPI) || BUILDFLAG(USE_OMX_CODEC)
   VideoDecodeAccelerator::SupportedProfiles vda_profiles;
 #if BUILDFLAG(USE_V4L2_CODEC)
   vda_profiles = V4L2VideoDecodeAccelerator::GetSupportedProfiles();
@@ -80,6 +84,11 @@ gpu::VideoDecodeAcceleratorCapabilities GetDecoderCapabilitiesInternal(
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
 #endif
+#if BUILDFLAG(USE_OMX_CODEC)
+  vda_profiles = OmxrVideoDecodeAccelerator::GetSupportedProfiles();
+  GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
+      vda_profiles, &capabilities.supported_profiles);
+#endif
 #elif defined(OS_MACOSX)
   capabilities.supported_profiles =
       VTVideoDecodeAccelerator::GetSupportedProfiles();
@@ -175,6 +184,9 @@ GpuVideoDecodeAcceleratorFactory::CreateVDA(
 #if BUILDFLAG(USE_VAAPI)
     &GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA,
 #endif
+#if BUILDFLAG(USE_OMX_CODEC)
+    &GpuVideoDecodeAcceleratorFactory::CreateOMXRVDA,
+#endif
 #if defined(OS_MACOSX)
     &GpuVideoDecodeAcceleratorFactory::CreateVTVDA,
 #endif
@@ -256,6 +268,21 @@ GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA(
 }
 #endif
 
+#if BUILDFLAG(USE_OMX_CODEC)
+std::unique_ptr<VideoDecodeAccelerator>
+GpuVideoDecodeAcceleratorFactory::CreateOMXRVDA(
+    const gpu::GpuDriverBugWorkarounds& workarounds,
+    const gpu::GpuPreferences& gpu_preferences,
+    MediaLog* media_log) const {
+  std::unique_ptr<VideoDecodeAccelerator> decoder;
+  decoder.reset(new OmxrVideoDecodeAccelerator(
+        gl::GLSurfaceEGL::GetHardwareDisplay(), make_context_current_cb_));
+  return decoder;
+}
+
+#endif
+
+
 #if defined(OS_MACOSX)
 std::unique_ptr<VideoDecodeAccelerator>
 GpuVideoDecodeAcceleratorFactory::CreateVTVDA(
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.h b/media/gpu/gpu_video_decode_accelerator_factory.h
index e779ef5..92dc3f1 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.h
+++ b/media/gpu/gpu_video_decode_accelerator_factory.h
@@ -124,6 +124,12 @@ class MEDIA_GPU_EXPORT GpuVideoDecodeAcceleratorFactory {
       const gpu::GpuPreferences& gpu_preferences,
       MediaLog* media_log) const;
 #endif
+#if BUILDFLAG(USE_OMX_CODEC)
+  std::unique_ptr<VideoDecodeAccelerator> CreateOMXRVDA(
+      const gpu::GpuDriverBugWorkarounds& workarounds,
+      const gpu::GpuPreferences& gpu_preferences,
+      MediaLog* media_log) const;
+#endif
 #if defined(OS_MACOSX)
   std::unique_ptr<VideoDecodeAccelerator> CreateVTVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
diff --git a/media/gpu/omx/mmngr.sig b/media/gpu/omx/mmngr.sig
new file mode 100644
index 0000000..73c7edf
--- /dev/null
+++ b/media/gpu/omx/mmngr.sig
@@ -0,0 +1,8 @@
+# Copyright (c) 2019 Renesas Electronics Corporation
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# Functions Renesas MMNGR functions used in Chromium code
+
+int mmngr_alloc_in_user_ext(MMNGR_ID *pid, size_t size, unsigned int *phard_addr, void **puser_virt_addr, unsigned int flag, void *mem_param);
+int mmngr_free_in_user_ext(MMNGR_ID id);
diff --git a/media/gpu/omx/mmngrbuf.sig b/media/gpu/omx/mmngrbuf.sig
new file mode 100644
index 0000000..f496e51
--- /dev/null
+++ b/media/gpu/omx/mmngrbuf.sig
@@ -0,0 +1,8 @@
+# Copyright (c) 2019 Renesas Electronics Corporation
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# Functions Renesas MMNGR functions used in Chromium code
+
+int mmngr_export_start_in_user_ext(int *pid, size_t size, unsigned int hard_addr, int *pbuf, void *mem_param);
+int mmngr_export_end_in_user_ext(int id);
diff --git a/media/gpu/omx/omx.sig b/media/gpu/omx/omx.sig
new file mode 100644
index 0000000..20d6b98
--- /dev/null
+++ b/media/gpu/omx/omx.sig
@@ -0,0 +1,11 @@
+# Copyright (c) 2010 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# Functions from OpenMAX IL used in Chromium code.
+
+OMX_ERRORTYPE OMX_Init(void);
+OMX_ERRORTYPE OMX_Deinit(void);
+OMX_ERRORTYPE OMX_GetHandle(OMX_HANDLETYPE* pHandle, OMX_STRING cComponentName, OMX_PTR pAppData, OMX_CALLBACKTYPE* pCallBacks);
+OMX_ERRORTYPE OMX_FreeHandle(OMX_HANDLETYPE hComponent);
+OMX_ERRORTYPE OMX_GetComponentsOfRole (OMX_STRING role, OMX_U32* pNumComps, OMX_U8** compNames);
diff --git a/media/gpu/omx/omx_stub_header.fragment b/media/gpu/omx/omx_stub_header.fragment
new file mode 100644
index 0000000..c7501fc
--- /dev/null
+++ b/media/gpu/omx/omx_stub_header.fragment
@@ -0,0 +1,9 @@
+// These are some extra includes needed in the generated stub file for defining
+// various OpenMAX and MMNGR types.
+
+extern "C" {
+
+#include "third_party/openmax/il/OMX_Core.h"
+#include "third_party/mmngr/mmngr_user_public.h"
+
+}
diff --git a/media/gpu/omx/omxr_video_decode_accelerator.cc b/media/gpu/omx/omxr_video_decode_accelerator.cc
new file mode 100644
index 0000000..dbcec93
--- /dev/null
+++ b/media/gpu/omx/omxr_video_decode_accelerator.cc
@@ -0,0 +1,1646 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+#include "media/gpu/omx/omxr_video_decode_accelerator.h"
+
+#include <libdrm/drm_fourcc.h>
+#include "base/bind.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/trace_event/trace_event.h"
+#include "media/base/bitstream_buffer.h"
+#include "media/video/picture.h"
+#include "third_party/openmax/il/OMXR_Extension_vdcmn.h"
+#include "ui/gl/egl_util.h"
+
+#include "media/gpu/omx/omx_stubs.h"
+
+#define PAGE_SIZE 4096
+
+#define VLOGF(level) VLOG(level) << __func__ << "(): "
+
+using media_gpu_omx::kModuleOmx;
+using media_gpu_omx::kModuleMmngr;
+using media_gpu_omx::kModuleMmngrbuf;
+using media_gpu_omx::InitializeStubs;
+using media_gpu_omx::StubPathMap;
+
+static const base::FilePath::CharType kOMXLib[] =
+    FILE_PATH_LITERAL("/usr/lib/libomxr_core.so");
+
+static const base::FilePath::CharType kMMNGRLib[] =
+    FILE_PATH_LITERAL("/usr/lib/libmmngr.so.1");
+
+static const base::FilePath::CharType kMMNGRBufLib[] =
+    FILE_PATH_LITERAL("/usr/lib/libmmngrbuf.so.1");
+
+namespace media {
+
+enum { kNumPictureBuffers = 8 };
+
+// Delay between polling for texture sync status. 5ms feels like a good
+// compromise, allowing some decoding ahead (up to 3 frames/vsync) to compensate
+// for more difficult frames.
+enum { kSyncPollDelayMs = 5 };
+
+OmxrVideoDecodeAccelerator::BitstreamBufferRef::BitstreamBufferRef(
+    const media::BitstreamBuffer &buf,
+    scoped_refptr<base::SingleThreadTaskRunner> tr,
+    base::WeakPtr<Client> cl)
+    : task_runner(tr),
+      client(cl) {
+  id = buf.id();
+  size = buf.size();
+  shm = std::make_unique<base::SharedMemory> (buf.handle(), true);
+  shm->Map(size);
+  memory = shm->memory();
+}
+
+OmxrVideoDecodeAccelerator::BitstreamBufferRef::~BitstreamBufferRef() {
+    if (id < 0)
+        return;
+    task_runner->PostTask(FROM_HERE, base::Bind(
+     &Client::NotifyEndOfBitstreamBuffer, client, id));
+}
+
+OmxrVideoDecodeAccelerator::OutputPicture::OutputPicture(
+  const OmxrVideoDecodeAccelerator &dec,
+  media::PictureBuffer pbuffer,
+  OMX_BUFFERHEADERTYPE* obuffer,
+  EGLImageKHR eimage,
+  struct MmngrBuffer mbuf)
+  : decoder(dec), picture_buffer(pbuffer),
+    omx_buffer_header(obuffer),
+    egl_image(eimage), mmngr_buf(mbuf),
+    at_component(false),
+    allocated(false) {}
+
+OMX_ERRORTYPE OmxrVideoDecodeAccelerator::OutputPicture::FreeOMXHandle() {
+  OMX_BUFFERHEADERTYPE* obuffer = omx_buffer_header;
+  if (!obuffer)
+    return OMX_ErrorNone;
+
+  omx_buffer_header = NULL;
+  return OMX_FreeBuffer(decoder.component_handle_, decoder.output_port_, obuffer);
+}
+
+OmxrVideoDecodeAccelerator::OutputPicture::~OutputPicture() {
+
+    VLOGF(1) << "Deleting picture " << picture_buffer.id();
+
+    FreeOMXHandle();
+
+    mmngr_export_end_in_user_ext(mmngr_buf.dmabuf_id);
+    mmngr_free_in_user_ext(mmngr_buf.mem_id);
+    eglDestroyImageKHR(decoder.egl_display_, egl_image);
+
+    if (decoder.client_)
+      decoder.client_->DismissPictureBuffer(picture_buffer.id());
+}
+
+// Helper macros for dealing with failure.  If |result| evaluates false, emit
+// |log| to ERROR, register |error| with the decoder, and return |ret_val|
+// (which may be omitted for functions that return void).
+#define RETURN_ON_FAILURE(result, log, error, ret_val)             \
+  do {                                                             \
+    if (!(result)) {                                               \
+      DLOG(ERROR) << log;                                          \
+      StopOnError(error);                                          \
+      return ret_val;                                              \
+    }                                                              \
+  } while (0)
+
+// OMX-specific version of RETURN_ON_FAILURE which compares with OMX_ErrorNone.
+#define RETURN_ON_OMX_FAILURE(omx_result, log, error, ret_val)          \
+  RETURN_ON_FAILURE(                                                    \
+      ((omx_result) == OMX_ErrorNone),                                  \
+      log << ", OMX result: 0x" << std::hex << omx_result,              \
+      error, ret_val)
+
+const OmxrVideoDecodeAccelerator::OmxrProfileManager &OmxrVideoDecodeAccelerator::OmxrProfileManager::Get() {
+    static const base::NoDestructor<OmxrProfileManager> profile_manager;
+    return *profile_manager;
+}
+
+void OmxrVideoDecodeAccelerator::OmxrProfileManager::InitOMXLibs() {
+    StubPathMap paths;
+    paths[kModuleOmx].push_back(kOMXLib);
+    paths[kModuleMmngr].push_back(kMMNGRLib);
+    paths[kModuleMmngrbuf].push_back(kMMNGRBufLib);
+    InitializeStubs(paths);
+}
+
+OmxrVideoDecodeAccelerator::OmxrProfileManager::OmxrProfileManager() {
+    OMX_HANDLETYPE component_handle;
+
+    InitOMXLibs();
+    OMX_Init();
+
+    OMX_CALLBACKTYPE omx_accelerator_callbacks = {
+      &OmxrVideoDecodeAccelerator::EventHandler,
+      &OmxrVideoDecodeAccelerator::EmptyBufferCallback,
+      &OmxrVideoDecodeAccelerator::FillBufferCallback
+    };
+
+    for (auto &profile : possible_profiles_) {
+        OMX_U32 num_components = 1;
+        OMX_STRING role_name = const_cast<OMX_STRING>(profile.first.role);
+        char *component = new char[OMX_MAX_STRINGNAME_SIZE];
+        OMX_ERRORTYPE result = OMX_GetComponentsOfRole(
+            role_name, &num_components,
+            reinterpret_cast<OMX_U8**>(&component));
+
+        if (result != OMX_ErrorNone || num_components < 1) {
+            delete[] component;
+            continue;
+        }
+
+        VLOG(1) << "Got component " << component << " for role: " << role_name;
+        result = OMX_GetHandle(&component_handle,
+            reinterpret_cast<OMX_STRING>(component),
+            NULL, &omx_accelerator_callbacks);
+
+        if (result == OMX_ErrorNone) {
+            supported_profiles_.insert(supported_profiles_.end(),
+                                       profile.second.begin(), profile.second.end());
+            profile.first.component = component;
+        }
+    }
+}
+
+const struct OmxrVideoDecodeAccelerator::CodecInfo
+OmxrVideoDecodeAccelerator::OmxrProfileManager::getCodecForProfile (VideoCodecProfile profile) const {
+    for (auto codec : possible_profiles_) {
+        for (auto supported_profile : codec.second) {
+            if (profile == supported_profile && codec.first.component) {
+                return codec.first;
+            }
+        }
+    }
+    return CodecInfo {UNKNOWN};
+}
+
+OmxrVideoDecodeAccelerator::OmxrVideoDecodeAccelerator(
+    EGLDisplay egl_display,
+    const base::Callback<bool(void)>& make_context_current)
+    : child_task_runner_(base::ThreadTaskRunnerHandle::Get()),
+      component_handle_(NULL),
+      weak_this_factory_(this),
+      init_begun_(false),
+      init_done_cond_(&init_lock_),
+      client_state_(OMX_StateMax),
+      current_state_change_(NO_TRANSITION),
+      input_buffer_count_(0),
+      input_buffer_size_(0),
+      input_port_(0),
+      input_buffers_at_component_(0),
+      first_input_buffer_sent_(false),
+      previous_frame_has_data_(false),
+      output_port_(0),
+      output_buffers_at_component_(0),
+      reset_pending_(false),
+      egl_display_(egl_display),
+      make_context_current_(make_context_current),
+      codec_(UNKNOWN) {
+  weak_this_ = weak_this_factory_.GetWeakPtr();
+}
+
+OmxrVideoDecodeAccelerator::~OmxrVideoDecodeAccelerator() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  DCHECK(free_input_buffers_.empty());
+  DCHECK_EQ(0, input_buffers_at_component_);
+  DCHECK_EQ(0, output_buffers_at_component_);
+  DCHECK(pictures_.empty());
+}
+
+// This is to initialize the OMX data structures to default values.
+template <typename T>
+static void InitParam(T* param) {
+  memset(param, 0, sizeof(T));
+  param->nVersion.nVersion = 0x00000101;
+  param->nSize = sizeof(T);
+}
+
+VideoDecodeAccelerator::SupportedProfiles
+OmxrVideoDecodeAccelerator::GetSupportedProfiles() {
+    VideoDecodeAccelerator::SupportedProfiles profiles;
+    const std::vector<VideoCodecProfile> &supported_profiles =
+        OmxrProfileManager::Get().getSupportedProfiles();
+
+    for (const auto& profile : supported_profiles) {
+        const auto kMinSize = gfx::Size(130,98);
+        const auto kMaxSize = gfx::Size(1920,1080);
+        VideoDecodeAccelerator::SupportedProfile supp_profile;
+        supp_profile.profile = profile;
+        supp_profile.min_resolution = kMinSize;
+        supp_profile.max_resolution = kMaxSize;
+        supp_profile.encrypted_only = false;
+        profiles.push_back(supp_profile);
+    }
+    return profiles;
+}
+
+bool OmxrVideoDecodeAccelerator::Initialize(const Config& config, Client* client) {
+  auto profile = config.profile;
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  CodecInfo cinfo;
+
+  page_size_ = sysconf(_SC_PAGESIZE);
+
+  RETURN_ON_FAILURE(page_size_ > 0,
+        "Cannot get valid system page size",
+        PLATFORM_FAILURE, false);
+
+  cinfo = OmxrProfileManager::Get().getCodecForProfile(profile);
+
+  RETURN_ON_FAILURE(cinfo.codec != UNKNOWN, "Unsupported profile: " << profile,
+                      INVALID_ARGUMENT, false);
+
+  codec_ = cinfo.codec;
+
+  if (codec_ == H264)
+    h264_parser_.reset(new H264Parser);
+
+  // Make sure that we have a context we can use for EGL image binding.
+  RETURN_ON_FAILURE(make_context_current_.Run(),
+                    "Failed make context current",
+                    PLATFORM_FAILURE,
+                    false);
+
+  client_ptr_factory_.reset(new base::WeakPtrFactory<Client>(client));
+  client_ = client_ptr_factory_->GetWeakPtr();
+
+  if (!decode_task_runner_) {
+    decode_task_runner_ = child_task_runner_;
+    decode_client_ = client_;
+  }
+
+  if (!config.supported_output_formats.empty() &&
+      !base::ContainsValue(config.supported_output_formats,
+        PIXEL_FORMAT_NV12))
+    return false;
+
+  RETURN_ON_FAILURE(gl::GLFence::IsSupported(),
+                    "Platform does not support GL fences",
+                    PLATFORM_FAILURE,
+                    false);
+
+  if (!CreateComponent(cinfo))  // Does its own RETURN_ON_FAILURE dances.
+    return false;
+  if (!DecoderSpecificInitialization())  // Does its own RETURN_ON_FAILURE dances.
+    return false;
+
+  deferred_init_allowed_ = config.is_deferred_initialization_allowed;
+
+  VLOGF(1) << "Deferred initialization " << (deferred_init_allowed_ ? "allowed" : "not allowed");
+
+  DCHECK_EQ(current_state_change_, NO_TRANSITION);
+  current_state_change_ = INITIALIZING;
+  BeginTransitionToState(OMX_StateIdle);
+
+  if (!AllocateInputBuffers())  // Does its own RETURN_ON_FAILURE dances.
+    return false;
+  if (!AllocateFakeOutputBuffers())  // Does its own RETURN_ON_FAILURE dances.
+    return false;
+
+  init_begun_ = true;
+  input_buffer_offset_ = 0;
+
+
+  if (deferred_init_allowed_)
+    return true;
+
+  /* Wait until we reach executing if deferred init is not allowed */
+  /* TODO(dhobsong): timeout */
+
+  base::AutoLock auto_lock_(init_lock_);
+  while (current_state_change_ == INITIALIZING) {
+    init_done_cond_.Wait();
+  }
+  VLOGF(1) << "Sync Initialization complete";
+  return true;
+
+}
+
+bool OmxrVideoDecodeAccelerator::CreateComponent(const struct CodecInfo &cinfo) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  OMX_ERRORTYPE result;
+  OMX_CALLBACKTYPE omx_accelerator_callbacks = {
+    &OmxrVideoDecodeAccelerator::EventHandler,
+    &OmxrVideoDecodeAccelerator::EmptyBufferCallback,
+    &OmxrVideoDecodeAccelerator::FillBufferCallback
+  };
+
+  // Get the handle to the component.
+  result = OMX_GetHandle(
+      &component_handle_, cinfo.component,
+      this, &omx_accelerator_callbacks);
+
+  RETURN_ON_OMX_FAILURE(result,
+                        "Failed to OMX_GetHandle on: " << cinfo.component,
+                        PLATFORM_FAILURE, false);
+  client_state_ = OMX_StateLoaded;
+
+  // Get the port information. This will obtain information about the number of
+  // ports and index of the first port.
+  OMX_PORT_PARAM_TYPE port_param;
+  InitParam(&port_param);
+  result = OMX_GetParameter(component_handle_, OMX_IndexParamVideoInit,
+                            &port_param);
+  RETURN_ON_FAILURE(result == OMX_ErrorNone && port_param.nPorts == 2,
+                    "Failed to get Port Param: " << result << ", "
+                    << port_param.nPorts,
+                    PLATFORM_FAILURE, false);
+
+  input_port_ = port_param.nStartPortNumber;
+  output_port_ = input_port_ + 1;
+
+  // Set role for the component because components can have multiple roles.
+  OMX_PARAM_COMPONENTROLETYPE role_type;
+  InitParam(&role_type);
+  base::strlcpy(reinterpret_cast<char*>(role_type.cRole),
+                cinfo.role,
+                OMX_MAX_STRINGNAME_SIZE);
+
+  result = OMX_SetParameter(component_handle_,
+                            OMX_IndexParamStandardComponentRole,
+                            &role_type);
+  RETURN_ON_OMX_FAILURE(result, "Failed to Set Role",
+                        PLATFORM_FAILURE, false);
+
+  // Populate input-buffer-related members based on input port data.
+  OMX_PARAM_PORTDEFINITIONTYPE port_format;
+  InitParam(&port_format);
+  port_format.nPortIndex = input_port_;
+  result = OMX_GetParameter(component_handle_,
+                            OMX_IndexParamPortDefinition,
+                            &port_format);
+  RETURN_ON_OMX_FAILURE(result,
+                        "GetParameter(OMX_IndexParamPortDefinition) failed",
+                        PLATFORM_FAILURE, false);
+  RETURN_ON_FAILURE(OMX_DirInput == port_format.eDir, "Expected input port",
+                    PLATFORM_FAILURE, false);
+
+  input_buffer_count_ = port_format.nBufferCountActual;
+  input_buffer_size_ = port_format.nBufferSize;
+
+  // Verify output port conforms to our expectations.
+  InitParam(&port_format);
+  port_format.nPortIndex = output_port_;
+  result = OMX_GetParameter(component_handle_,
+                            OMX_IndexParamPortDefinition,
+                            &port_format);
+  RETURN_ON_OMX_FAILURE(result,
+                        "GetParameter(OMX_IndexParamPortDefinition) failed",
+                        PLATFORM_FAILURE, false);
+  RETURN_ON_FAILURE(OMX_DirOutput == port_format.eDir, "Expect Output Port",
+                    PLATFORM_FAILURE, false);
+
+  // Set output port parameters.
+  port_format.nBufferCountActual = kNumPictureBuffers;
+  port_format.format.video.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+
+  // Force an OMX_EventPortSettingsChanged event to be sent once we know the
+  // stream's real dimensions (which can only happen once some Decode() work has
+  // been done).
+  port_format.format.video.nFrameWidth = 128;
+  port_format.format.video.nFrameHeight = 96;
+  port_format.format.video.nStride = 128;
+  port_format.format.video.nSliceHeight = 96;
+
+  port_format.nBufferSize = port_format.format.video.nStride *
+        port_format.format.video.nSliceHeight * 3 / 2;
+  output_buffer_size_ = port_format.nBufferSize;
+  result = OMX_SetParameter(component_handle_,
+                            OMX_IndexParamPortDefinition,
+                            &port_format);
+  RETURN_ON_OMX_FAILURE(result,
+                        "SetParameter(OMX_IndexParamPortDefinition) failed",
+                        PLATFORM_FAILURE, false);
+  return true;
+}
+
+bool OmxrVideoDecodeAccelerator::DecoderSpecificInitialization() {
+  OMXR_MC_VIDEO_PARAM_REORDERTYPE param_reorder;
+  InitParam(&param_reorder);
+
+  param_reorder.nPortIndex = output_port_;
+  param_reorder.bReorder = OMX_FALSE;
+
+  OMX_ERRORTYPE result = OMX_SetParameter(component_handle_,
+                            static_cast<OMX_INDEXTYPE> (OMXR_MC_IndexParamVideoReorder),
+                            &param_reorder);
+
+  RETURN_ON_OMX_FAILURE(result,
+                        "SetParameter(OMXR_MC_IndexParamVideoReorder) failed",
+                        PLATFORM_FAILURE, false);
+
+  // Set up timestamps to be returned in decode order (i.e. don't adjust
+  // values to make them come out in ascneding order)
+
+  OMXR_MC_VIDEO_PARAM_TIME_STAMP_MODETYPE param_ts;
+  InitParam(&param_ts);
+
+  param_ts.nPortIndex = output_port_;
+  param_ts.eTimeStampMode = OMXR_MC_VIDEO_TimeStampModeDecodeOrder;
+
+  result = OMX_SetParameter(component_handle_,
+                            static_cast<OMX_INDEXTYPE> (OMXR_MC_IndexParamVideoTimeStampMode),
+                            &param_ts);
+
+  RETURN_ON_OMX_FAILURE(result,
+                        "SetParameter(OMXR_MC_IndexParamVideoTimeStampMode) failed",
+                        PLATFORM_FAILURE, false);
+
+  // Enable dynamic video resizing up to FHD resolution
+
+  OMXR_MC_VIDEO_PARAM_DYNAMIC_PORT_RECONF_IN_DECODINGTYPE param_dynamic;
+  InitParam(&param_dynamic);
+
+  param_dynamic.nPortIndex = output_port_;
+  param_dynamic.bEnable = OMX_TRUE;
+
+  result = OMX_SetParameter(component_handle_,
+                            static_cast<OMX_INDEXTYPE> (OMXR_MC_IndexParamVideoDynamicPortReconfInDecoding),
+                            &param_dynamic);
+
+  RETURN_ON_OMX_FAILURE(result,
+                        "SetParameter(OMXR_MC_IndexParamVideoDynamicPortReconfInDecoding) failed",
+                        PLATFORM_FAILURE, false);
+
+  OMXR_MC_VIDEO_PARAM_MAXIMUM_DECODE_CAPABILITYTYPE param_maxdecode;
+  InitParam(&param_maxdecode);
+
+  param_maxdecode.nPortIndex = output_port_;
+  param_maxdecode.nMaxDecodedWidth = 1920;
+  param_maxdecode.nMaxDecodedHeight = 1088;
+  param_maxdecode.eMaxLevel = OMX_VIDEO_AVCLevel5;
+  param_maxdecode.bForceEnable = OMX_TRUE;
+
+  result = OMX_SetParameter(component_handle_,
+                            static_cast<OMX_INDEXTYPE> (OMXR_MC_IndexParamVideoMaximumDecodeCapability),
+                            &param_maxdecode);
+  RETURN_ON_OMX_FAILURE(result,
+                        "SetParameter(OMXR_MC_IndexParamVideoMaximumDecodeCapability) failed",
+                        PLATFORM_FAILURE, false);
+  return true;
+}
+
+void OmxrVideoDecodeAccelerator::Decode(
+    const media::BitstreamBuffer& bitstream_buffer) {
+  TRACE_EVENT2("media,gpu", "OVDA::Decode",
+               "Buffer id", bitstream_buffer.id(),
+               "Component input buffers", input_buffers_at_component_ + 1);
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  VLOGF(2) << "buffer id:" << bitstream_buffer.id();
+
+  auto buffer = std::make_unique<BitstreamBufferRef>(bitstream_buffer, decode_task_runner_, decode_client_);
+  RETURN_ON_FAILURE(buffer->memory != NULL || buffer->id < 0,
+                    "Failed to map bistream buffer memory", UNREADABLE_INPUT,);
+
+  DecodeBuffer(std::move(buffer));
+}
+
+void OmxrVideoDecodeAccelerator::DecodeBuffer(std::unique_ptr<struct BitstreamBufferRef> input_buffer) {
+  if (current_state_change_ == RESETTING ||
+      current_state_change_ == INITIALIZING ||
+      !queued_bitstream_buffers_.empty() ||
+      free_input_buffers_.empty()) {
+    queued_bitstream_buffers_.push_back(std::move(input_buffer));
+    return;
+  }
+
+  RETURN_ON_FAILURE((current_state_change_ == NO_TRANSITION ||
+                     current_state_change_ == RESIZING ||
+                     current_state_change_ == FLUSHING) &&
+                    (client_state_ == OMX_StateIdle ||
+                     client_state_ == OMX_StateExecuting),
+                    "Call to Decode() during invalid state or transition: "
+                    << current_state_change_ << ", " << client_state_,
+                    ILLEGAL_STATE,);
+
+  OMX_BUFFERHEADERTYPE* omx_buffer = free_input_buffers_.front();
+
+  if (input_buffer->id == -1) {
+    // Cook up an empty buffer w/ EOS set and feed it to OMX.
+    if (input_buffer_offset_) {
+      first_input_buffer_sent_ = true;
+      VLOGF(2) << "decoding buffer :" << (int) omx_buffer->nTimeStamp;
+      // Give this buffer to OMX.
+      free_input_buffers_.pop();
+      OMX_ERRORTYPE result = OMX_EmptyThisBuffer(component_handle_, omx_buffer);
+      RETURN_ON_OMX_FAILURE(result, "OMX_EmptyThisBuffer() failed",
+                        PLATFORM_FAILURE,);
+
+      input_buffer_size_ = 0;
+      input_buffer_offset_ = 0;
+      input_buffers_at_component_++;
+      if (free_input_buffers_.empty()) {
+        VLOGF(2) << "No more buffers available, returning bistream buffer to queue";
+        queued_bitstream_buffers_.push_back(std::move(input_buffer));
+        return;
+      }
+      omx_buffer = free_input_buffers_.front();
+    }
+
+    omx_buffer->nFilledLen = 0;
+    omx_buffer->nAllocLen = omx_buffer->nFilledLen;
+    omx_buffer->nFlags = OMX_BUFFERFLAG_EOS;
+    omx_buffer->nTimeStamp = -2;
+    free_input_buffers_.pop();
+    OMX_ERRORTYPE result = OMX_EmptyThisBuffer(component_handle_, omx_buffer);
+    RETURN_ON_OMX_FAILURE(result, "OMX_EmptyThisBuffer() failed",
+                          PLATFORM_FAILURE,);
+    input_buffer_offset_ = 0;
+    input_buffers_at_component_++;
+    return;
+  }
+
+  // Setup |omx_buffer|.
+
+  DCHECK(!omx_buffer->pAppPrivate);
+
+
+  OMX_U8 *data = static_cast<OMX_U8*>(input_buffer->memory);
+
+  bool send_frame = false;
+  int size = input_buffer->size;
+  if (codec_ == H264) {
+    h264_parser_->SetStream(data, size);
+
+    bool has_data = false;
+    bool new_frame = false;
+    H264Parser::Result res;
+    H264NALU nal;
+    while ((res = h264_parser_->AdvanceToNextNALU(&nal)) != H264Parser::kEOStream) {
+
+      RETURN_ON_FAILURE(res == H264Parser::kOk, "Parsing H264 stream failed",
+                          PLATFORM_FAILURE,);
+
+      switch (nal.nal_unit_type) {
+         case H264NALU::kNonIDRSlice:
+         case H264NALU::kIDRSlice:
+            //check if first-mb-in-slice is 0 (i.e. first NAL in picture)
+            if (nal.size > 1 && nal.data[1] & 0x80) {
+                DCHECK_EQ(has_data, false);
+                new_frame = true;
+            }
+            has_data = true;
+            break;
+         case H264NALU::kAUD:
+         case H264NALU::kEOSeq:
+         case H264NALU::kEOStream:
+         case H264NALU::kSEIMessage:
+         case H264NALU::kSPS:
+         case H264NALU::kPPS:
+              new_frame = true;
+              break;
+         default:
+            LOG(WARNING) << "Got an unrecognized NAL unit: " << nal.nal_unit_type;
+      };
+
+    }
+
+    send_frame = new_frame && previous_frame_has_data_;
+    previous_frame_has_data_ = has_data;
+  }
+
+  if (send_frame && omx_buffer->nFilledLen) {
+      first_input_buffer_sent_ = true;
+      VLOGF(2) << "decoding buffer :" << (int) omx_buffer->nTimeStamp;
+      // Give this buffer to OMX.
+      free_input_buffers_.pop();
+      OMX_ERRORTYPE result = OMX_EmptyThisBuffer(component_handle_, omx_buffer);
+      RETURN_ON_OMX_FAILURE(result, "OMX_EmptyThisBuffer() failed",
+                        PLATFORM_FAILURE,);
+
+      input_buffer_size_ = 0;
+      input_buffer_offset_ = 0;
+      input_buffers_at_component_++;
+
+      if (free_input_buffers_.empty()) {
+        VLOGF(2) << "No more buffers available, returning bistream buffer to queue";
+        queued_bitstream_buffers_.push_back(std::move(input_buffer));
+        return;
+      }
+      omx_buffer = free_input_buffers_.front();
+  }
+
+  // Abuse the header's nTimeStamp field to propagate the bitstream buffer ID to
+  // the output buffer's nTimeStamp field, so we can report it back to the
+  // client in PictureReady().
+  omx_buffer->nTimeStamp = input_buffer->id;
+
+  memcpy(omx_buffer->pBuffer + input_buffer_offset_, data, size);
+  input_buffer_offset_ += size;
+
+  omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
+  omx_buffer->nFilledLen = input_buffer_offset_;
+  omx_buffer->nAllocLen = omx_buffer->nFilledLen;
+
+  //processed |input_buffer|s go out of scope here and return to client.
+}
+
+void OmxrVideoDecodeAccelerator::AssignPictureBuffers(
+    const std::vector<media::PictureBuffer>& buffers) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  // If we are resetting/destroying/erroring, don't bother, as
+  // OMX_FillThisBuffer will fail anyway. In case we're in the middle of
+  // closing, this will put the Accelerator in ERRORING mode, which has the
+  // unwanted side effect of not going through the OMX_FreeBuffers path and
+  // leaks memory.
+  if (current_state_change_ == RESETTING ||
+      current_state_change_ == DESTROYING ||
+      current_state_change_ == ERRORING)
+    return;
+
+  RETURN_ON_FAILURE(CanFillBuffer(), "Can't fill buffer", ILLEGAL_STATE,);
+  RETURN_ON_FAILURE((kNumPictureBuffers <= buffers.size()),
+      "Failed to provide requested picture buffers. (Got " << buffers.size() <<
+      ", requested " << kNumPictureBuffers << ")", INVALID_ARGUMENT,);
+
+  DCHECK_EQ(output_buffers_at_component_, 0);
+  DCHECK_EQ(fake_output_buffers_.size(), 0U);
+  DCHECK_EQ(pictures_.size(), 0U);
+
+  if (!make_context_current_.Run())
+    return;
+
+  OMX_ERRORTYPE result;
+  OMX_PARAM_PORTDEFINITIONTYPE port_format;
+
+  InitParam(&port_format);
+  port_format.nPortIndex = output_port_;
+
+  result = OMX_GetParameter(component_handle_,
+                            OMX_IndexParamPortDefinition,
+                            &port_format);
+
+  RETURN_ON_OMX_FAILURE(result,
+                        "GetParameter(OMX_IndexParamPortDefinition) failed",
+                        PLATFORM_FAILURE,);
+
+  port_format.nBufferCountActual = buffers.size();
+
+  result = OMX_SetParameter(component_handle_,
+                            OMX_IndexParamPortDefinition,
+                            &port_format);
+  RETURN_ON_OMX_FAILURE(result,
+                        "SetParameter(OMX_IndexParamPortDefinition) failed",
+                        PLATFORM_FAILURE,);
+
+  for (size_t i = 0; i < buffers.size(); ++i) {
+    void *dummy;
+    EGLImageKHR egl_image;
+    struct MmngrBuffer mbuf;
+    int alloc_size = (port_format.nBufferSize + (page_size_ - 1)) & ~(page_size_ - 1);
+
+    gfx::Size size = buffers[i].size();
+    DCHECK_EQ(picture_buffer_dimensions_.width(), size.width());
+    DCHECK_EQ(picture_buffer_dimensions_.height(), size.height());
+
+    int ret = mmngr_alloc_in_user_ext(&mbuf.mem_id, alloc_size,
+            &mbuf.hard_addr, &dummy, MMNGR_PA_SUPPORT, NULL);
+
+    RETURN_ON_FAILURE(!ret, "Cannot allocate output buffer memory" << ret,
+        PLATFORM_FAILURE,);
+
+    ret = mmngr_export_start_in_user_ext(&mbuf.dmabuf_id, alloc_size,
+        mbuf.hard_addr, &mbuf.dmabuf_fd, NULL);
+    /* Make EGLImage */
+
+    std::vector<EGLint> attrs;
+    attrs.push_back(EGL_WIDTH);
+    attrs.push_back(size.width());
+    attrs.push_back(EGL_HEIGHT);
+    attrs.push_back(size.height());
+    attrs.push_back(EGL_LINUX_DRM_FOURCC_EXT);
+    attrs.push_back(DRM_FORMAT_NV12);
+
+    static const int plane_count = 2; // NV12 has 2 planes
+
+    size_t plane_offset = 0;
+    for (size_t plane = 0; plane < plane_count; ++plane) {
+      attrs.push_back(EGL_DMA_BUF_PLANE0_FD_EXT + plane * 3);
+      attrs.push_back(mbuf.dmabuf_fd);
+      attrs.push_back(EGL_DMA_BUF_PLANE0_OFFSET_EXT + plane * 3);
+      attrs.push_back(plane_offset);
+      attrs.push_back(EGL_DMA_BUF_PLANE0_PITCH_EXT + plane * 3);
+      attrs.push_back(port_format.format.video.nStride);
+
+      plane_offset += port_format.format.video.nStride *
+                      port_format.format.video.nSliceHeight;
+    }
+
+    attrs.push_back(EGL_NONE);
+
+    uint32_t texture_id = buffers[i].service_texture_ids()[0];
+
+    egl_image = eglCreateImageKHR(
+        egl_display_, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, NULL, &attrs[0]);
+    RETURN_ON_FAILURE((egl_image != EGL_NO_IMAGE_KHR), "Cannot create EGLImage " << ui::GetLastEGLErrorString(),
+          PLATFORM_FAILURE,);
+
+    glBindTexture(GL_TEXTURE_EXTERNAL_OES, texture_id);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, egl_image);
+
+    VLOGF(1) << "Creating picture buffer. id = " << buffers[i].id();
+
+    pictures_.insert(std::make_pair(buffers[i].id(),
+        std::make_unique<OutputPicture>(*this, buffers[i], nullptr, egl_image, mbuf)));
+  }
+
+  if (!SendCommandToPort(OMX_CommandPortEnable, output_port_))
+    return;
+  if (!AllocateOutputBuffers(port_format.nBufferSize))
+    return;
+  VLOGF(1) << "Resize complete";
+  current_state_change_ = NO_TRANSITION;
+}
+
+void OmxrVideoDecodeAccelerator::ReusePictureBuffer(int32_t picture_buffer_id) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  TRACE_EVENT1("media,gpu", "OVDA::ReusePictureBuffer",
+               "Picture id", picture_buffer_id);
+
+  RETURN_ON_FAILURE(make_context_current_.Run(),
+                    "Failed to make context current",
+                    PLATFORM_FAILURE,);
+
+  auto picture_sync_fence = gl::GLFence::Create();
+
+  // Start checking sync status periodically.
+  CheckPictureStatus(picture_buffer_id, std::move(picture_sync_fence));
+}
+
+void OmxrVideoDecodeAccelerator::CheckPictureStatus(
+    int32_t picture_buffer_id,
+    std::unique_ptr<gl::GLFence> fence_obj
+    ) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  TRACE_EVENT1("media,gpu", "OVDA::CheckPictureStatus",
+               "Picture id", picture_buffer_id);
+
+  // It's possible for this task to never run if the message loop is
+  // stopped. In that case we may never call QueuePictureBuffer().
+  // This is fine though, because all pictures, irrespective of their state,
+  // are in pictures_ map and that's what will be used to do the clean up.
+  if (!fence_obj->HasCompleted()) {
+    child_task_runner_->PostDelayedTask(FROM_HERE, base::Bind(
+        &OmxrVideoDecodeAccelerator::CheckPictureStatus, weak_this_,
+        picture_buffer_id, base::Passed(&fence_obj)),
+        base::TimeDelta::FromMilliseconds(kSyncPollDelayMs));
+    return;
+  }
+  // Synced successfully. Queue the buffer for reuse.
+  QueuePictureBuffer(picture_buffer_id);
+}
+
+void OmxrVideoDecodeAccelerator::QueuePictureBuffer(int32_t picture_buffer_id) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  if (picture_buffer_id < 0)
+     return;
+
+  // During port-flushing, do not call OMX FillThisBuffer.
+  if (current_state_change_ == RESETTING) {
+    queued_picture_buffer_ids_.push_back(picture_buffer_id);
+    return;
+  }
+
+  // We might have started destroying while waiting for the picture. It's safe
+  // to drop it here, because we will free all the pictures regardless of their
+  // state using the pictures_ map.
+  if (!CanFillBuffer())
+    return;
+
+  OutputPictureById::iterator it = pictures_.find(picture_buffer_id);
+  RETURN_ON_FAILURE(it != pictures_.end(),
+                    "Missing picture buffer id: " << picture_buffer_id,
+                    INVALID_ARGUMENT,);
+  OutputPicture& output_picture = *it->second;
+
+  if (!output_picture.omx_buffer_header) {
+    VLOGF(1) << "Releasing picture for freed OMX buffer. Picture ID = " << picture_buffer_id;
+    pictures_.erase(it);
+    return;
+  }
+
+  ++output_buffers_at_component_;
+  output_picture.at_component = true;
+  TRACE_EVENT2("media,gpu", "OVDA::QueuePictureBuffer",
+               "Picture id", picture_buffer_id,
+               "At component", output_buffers_at_component_);
+  OMX_ERRORTYPE result =
+      OMX_FillThisBuffer(component_handle_, output_picture.omx_buffer_header);
+  RETURN_ON_OMX_FAILURE(result, "OMX_FillThisBuffer() failed",
+                        PLATFORM_FAILURE,);
+}
+
+void OmxrVideoDecodeAccelerator::Flush() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  DCHECK_EQ(current_state_change_, NO_TRANSITION);
+  DCHECK_EQ(client_state_, OMX_StateExecuting);
+  VLOGF(1);
+  current_state_change_ = FLUSHING;
+
+  if (!first_input_buffer_sent_ ) {
+    VLOGF(1) << "Nothing to flush, scheduling FlushDone";
+    child_task_runner_->PostTask(FROM_HERE, base::Bind(
+       &Client::NotifyFlushDone, client_));
+    return;
+  }
+  Decode(media::BitstreamBuffer(-1, base::SharedMemoryHandle(), 0));
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedEOSInFlushing() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  DCHECK_EQ(client_state_, OMX_StateExecuting);
+  VLOGF(1);
+  current_state_change_ = NO_TRANSITION;
+  if (client_)
+    client_->NotifyFlushDone();
+}
+
+void OmxrVideoDecodeAccelerator::FlushIOPorts() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  // Flush input port first.
+  if (!SendCommandToPort(OMX_CommandFlush, input_port_))
+    return;
+}
+
+void OmxrVideoDecodeAccelerator::InputPortFlushDone() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  DCHECK_EQ(input_buffers_at_component_, 0);
+  if (!SendCommandToPort(OMX_CommandFlush, output_port_))
+    return;
+}
+
+void OmxrVideoDecodeAccelerator::OutputPortFlushDone() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  DCHECK_EQ(output_buffers_at_component_, 0);
+  BeginTransitionToState(OMX_StateExecuting);
+}
+
+void OmxrVideoDecodeAccelerator::Reset() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  DCHECK(current_state_change_ == NO_TRANSITION ||
+        current_state_change_ == FLUSHING ||
+        current_state_change_ == RESIZING);
+  DCHECK_EQ(client_state_, OMX_StateExecuting);
+  VLOGF(1);
+
+  if (!first_input_buffer_sent_ ) {
+    input_buffer_offset_ = 0;
+    first_input_buffer_sent_ = false;
+
+    child_task_runner_->PostTask(FROM_HERE, base::Bind(
+       &Client::NotifyResetDone, client_));
+    return;
+  }
+
+  /* Wait for resize to finish before doing Reset */
+  if (current_state_change_ == RESIZING ||
+    picture_buffer_dimensions_ == gfx::Size()) {
+    VLOGF(1) << "Postponing reset during resize";
+    reset_pending_ = true;
+    return;
+  }
+  FinishReset();
+}
+
+void OmxrVideoDecodeAccelerator::FinishReset() {
+  current_state_change_ = RESETTING;
+  reset_pending_ = false;
+  queued_bitstream_buffers_.clear();
+  BeginTransitionToState(OMX_StatePause);
+}
+
+void OmxrVideoDecodeAccelerator::Destroy() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  std::unique_ptr<OmxrVideoDecodeAccelerator> deleter(this);
+  client_ptr_factory_->InvalidateWeakPtrs();
+
+  if (current_state_change_ == ERRORING ||
+      current_state_change_ == DESTROYING) {
+    return;
+  }
+
+  DCHECK(current_state_change_ == NO_TRANSITION ||
+         current_state_change_ == FLUSHING ||
+         current_state_change_ == RESETTING) << current_state_change_;
+
+  // If we were never initializeed there's no teardown to do.
+  if (client_state_ == OMX_StateMax)
+    return;
+  // If we can already call OMX_FreeHandle, simply do so.
+  if (client_state_ == OMX_StateInvalid || client_state_ == OMX_StateLoaded) {
+    ShutdownComponent();
+    return;
+  }
+  DCHECK(client_state_ == OMX_StateExecuting ||
+         client_state_ == OMX_StateIdle ||
+         client_state_ == OMX_StatePause);
+  current_state_change_ = DESTROYING;
+  BeginTransitionToState(OMX_StateIdle);
+  BusyLoopInDestroying(std::move(deleter));
+}
+
+bool OmxrVideoDecodeAccelerator::TryToSetupDecodeOnSeparateThread(
+    const base::WeakPtr<Client>& decode_client,
+    const scoped_refptr<base::SingleThreadTaskRunner>& decode_task_runner) {
+
+    return false;
+}
+
+void OmxrVideoDecodeAccelerator::BeginTransitionToState(
+    OMX_STATETYPE new_state) {
+  VLOGF(1) << "new_state = " << new_state;
+  DCHECK(new_state == OMX_StateInvalid ||
+         current_state_change_ != NO_TRANSITION);
+
+  if (current_state_change_ == ERRORING)
+    return;
+  OMX_ERRORTYPE result = OMX_SendCommand(
+      component_handle_, OMX_CommandStateSet, new_state, 0);
+  RETURN_ON_FAILURE(result == OMX_ErrorNone || new_state == OMX_StateInvalid,
+                        "SendCommand(OMX_CommandStateSet) failed",
+                        PLATFORM_FAILURE,);
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedIdleInInitializing() {
+  VLOGF(1);
+  DCHECK_EQ(client_state_, OMX_StateLoaded);
+  client_state_ = OMX_StateIdle;
+  BeginTransitionToState(OMX_StateExecuting);
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedExecutingInInitializing() {
+  VLOGF(1);
+  DCHECK_EQ(client_state_, OMX_StateIdle);
+  base::AutoLock auto_lock_(init_lock_);
+  client_state_ = OMX_StateExecuting;
+  current_state_change_ = NO_TRANSITION;
+
+  // Request filling of our fake buffers to trigger decode processing.  In
+  // reality as soon as any data is decoded these will get dismissed due to
+  // dimension mismatch.
+  for (std::set<OMX_BUFFERHEADERTYPE*>::iterator it =
+           fake_output_buffers_.begin();
+       it != fake_output_buffers_.end(); ++it) {
+    OMX_BUFFERHEADERTYPE* buffer = *it;
+    OMX_ERRORTYPE result = OMX_FillThisBuffer(component_handle_, buffer);
+    RETURN_ON_OMX_FAILURE(result, "OMX_FillThisBuffer()", PLATFORM_FAILURE,);
+    ++output_buffers_at_component_;
+  }
+  if (deferred_init_allowed_ && client_) {
+    client_->NotifyInitializationComplete(true);
+     // Drain queues of input & output buffers held during the init.
+    VLOGF(1) << "Deferred Initialization complete";
+    DecodeQueuedBitstreamBuffers();
+  } else {
+    init_done_cond_.Signal();
+  }
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedPauseInResetting() {
+  DCHECK_EQ(client_state_, OMX_StateExecuting);
+  client_state_ = OMX_StatePause;
+  FlushIOPorts();
+}
+
+void OmxrVideoDecodeAccelerator::DecodeQueuedBitstreamBuffers() {
+  BitstreamBufferList buffers;
+  buffers.swap(queued_bitstream_buffers_);
+  if (current_state_change_ == DESTROYING ||
+      current_state_change_ == ERRORING) {
+    return;
+  }
+  for (size_t i = 0; i < buffers.size(); ++i)
+    DecodeBuffer(std::move(buffers[i]));
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedExecutingInResetting() {
+  DCHECK_EQ(client_state_, OMX_StatePause);
+  VLOGF(1);
+  client_state_ = OMX_StateExecuting;
+  current_state_change_ = NO_TRANSITION;
+
+  input_buffer_offset_ = 0;
+  previous_frame_has_data_ = false;
+  first_input_buffer_sent_ = false;
+
+  if (!client_)
+    return;
+
+  // Drain queues of input & output buffers held during the reset.
+  DecodeQueuedBitstreamBuffers();
+  for (size_t i = 0; i < queued_picture_buffer_ids_.size(); ++i)
+    QueuePictureBuffer(queued_picture_buffer_ids_[i]);
+  queued_picture_buffer_ids_.clear();
+
+  client_->NotifyResetDone();
+}
+
+// Alert: HORROR ahead!  OMX shutdown is an asynchronous dance but our clients
+// enjoy the fire-and-forget nature of a synchronous Destroy() call that
+// ensures no further callbacks are made.  Since the interface between OMX
+// callbacks and this class is a MessageLoop, we need to ensure the loop
+// outlives the shutdown dance, even during process shutdown.  We do this by
+// repeatedly enqueuing a no-op task until shutdown is complete, since
+// MessageLoop's shutdown drains pending tasks.
+// TODO(dhobsong): Yes indeed.  Review this.
+void OmxrVideoDecodeAccelerator::BusyLoopInDestroying(
+    std::unique_ptr<OmxrVideoDecodeAccelerator> self) {
+  if (!component_handle_) return;
+  // Can't use PostDelayedTask here because MessageLoop doesn't drain delayed
+  // tasks.  Instead we sleep for 5ms.  Really.
+  base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(5));
+  self->child_task_runner_->PostTask(FROM_HERE, base::Bind(
+      &OmxrVideoDecodeAccelerator::BusyLoopInDestroying,
+      base::Unretained(this), base::Passed(&self)));
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedIdleInDestroying() {
+  DCHECK(client_state_ == OMX_StateExecuting ||
+         client_state_ == OMX_StateIdle ||
+         client_state_ == OMX_StatePause);
+  client_state_ = OMX_StateIdle;
+
+  // Note that during the Executing -> Idle transition, the OMX spec guarantees
+  // buffers have been returned to the client, so we don't need to do an
+  // explicit FlushIOPorts().
+
+  BeginTransitionToState(OMX_StateLoaded);
+
+  FreeOMXBuffers();
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedLoadedInDestroying() {
+  DCHECK_EQ(client_state_, OMX_StateIdle);
+  client_state_ = OMX_StateLoaded;
+  current_state_change_ = NO_TRANSITION;
+  ShutdownComponent();
+}
+
+void OmxrVideoDecodeAccelerator::OnReachedInvalidInErroring() {
+  client_state_ = OMX_StateInvalid;
+  FreeOMXBuffers();
+  ShutdownComponent();
+}
+
+void OmxrVideoDecodeAccelerator::ShutdownComponent() {
+  OMX_ERRORTYPE result = OMX_FreeHandle(component_handle_);
+  if (result != OMX_ErrorNone)
+    DLOG(ERROR) << "OMX_FreeHandle() error. Error code: " << result;
+  client_state_ = OMX_StateMax;
+  // Allow BusyLoopInDestroying to exit and delete |this|.
+  component_handle_ = NULL;
+}
+
+void OmxrVideoDecodeAccelerator::StopOnError(
+    media::VideoDecodeAccelerator::Error error) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  if (current_state_change_ == ERRORING)
+    return;
+
+  if (client_ && init_begun_)
+    client_->NotifyError(error);
+  client_ptr_factory_->InvalidateWeakPtrs();
+
+  if (client_state_ == OMX_StateInvalid || client_state_ == OMX_StateMax)
+      return;
+
+  BeginTransitionToState(OMX_StateInvalid);
+  current_state_change_ = ERRORING;
+}
+
+bool OmxrVideoDecodeAccelerator::AllocateInputBuffers() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  VLOG(1) << __func__ << ": Allocating " << input_buffer_count_ << " buffers of size: " << input_buffer_size_;
+  for (int i = 0; i < input_buffer_count_; ++i) {
+    OMX_BUFFERHEADERTYPE* buffer;
+    OMX_ERRORTYPE result =
+        OMX_AllocateBuffer(component_handle_, &buffer, input_port_,
+                      NULL, /* pAppPrivate gets set in Decode(). */
+                      input_buffer_size_);
+    RETURN_ON_OMX_FAILURE(result, "OMX_AllocateBuffer() Input buffer error",
+                          PLATFORM_FAILURE, false);
+    buffer->nInputPortIndex = input_port_;
+    buffer->nOffset = 0;
+    buffer->nFlags = 0;
+    free_input_buffers_.push(buffer);
+  }
+  return true;
+}
+
+bool OmxrVideoDecodeAccelerator::AllocateFakeOutputBuffers() {
+  // Fill the component with fake output buffers.
+  VLOG(1) << __func__ << ": Allocating " << kNumPictureBuffers << " buffers of size: " << output_buffer_size_;
+  for (unsigned int i = 0; i < kNumPictureBuffers; ++i) {
+    OMX_BUFFERHEADERTYPE* buffer;
+    OMX_ERRORTYPE result;
+    result = OMX_AllocateBuffer(component_handle_, &buffer, output_port_,
+                                NULL, output_buffer_size_);
+    RETURN_ON_OMX_FAILURE(result, "OMX_AllocateBuffer failed",
+                          PLATFORM_FAILURE, false);
+    buffer->pAppPrivate = NULL;
+    buffer->nTimeStamp = -1;
+    buffer->nOutputPortIndex = output_port_;
+    CHECK(fake_output_buffers_.insert(buffer).second);
+  }
+  return true;
+}
+
+bool OmxrVideoDecodeAccelerator::AllocateOutputBuffers(int size) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  DCHECK(!pictures_.empty());
+  for (OutputPictureById::iterator it = pictures_.begin();
+       it != pictures_.end(); ++it) {
+    OutputPicture *output_picture = it->second.get();
+    if (output_picture->allocated)
+        continue;
+
+    OMX_BUFFERHEADERTYPE** omx_buffer = &output_picture->omx_buffer_header;
+    uint32_t hard_addr = output_picture->mmngr_buf.hard_addr;
+    DCHECK(!*omx_buffer);
+
+    OMX_ERRORTYPE result = OMX_UseBuffer(
+        component_handle_, omx_buffer, output_port_, output_picture, size,
+        reinterpret_cast<OMX_U8*>(hard_addr));
+
+    RETURN_ON_OMX_FAILURE(result, "OMX_UseBuffer", PLATFORM_FAILURE, false);
+  }
+  return true;
+}
+
+void OmxrVideoDecodeAccelerator::FreeOMXBuffers() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  bool failure_seen = false;
+  while (!free_input_buffers_.empty()) {
+    OMX_BUFFERHEADERTYPE* omx_buffer = free_input_buffers_.front();
+    free_input_buffers_.pop();
+    OMX_ERRORTYPE result =
+        OMX_FreeBuffer(component_handle_, input_port_, omx_buffer);
+    if (result != OMX_ErrorNone) {
+      DLOG(ERROR) << "OMX_FreeBuffer failed: 0x" << std::hex << result;
+      failure_seen = true;
+    }
+  }
+
+  pictures_.clear();
+
+  // Delete pending fake_output_buffers_ //TODO(dhobsong): still not liking these
+  for (std::set<OMX_BUFFERHEADERTYPE*>::iterator it =
+           fake_output_buffers_.begin();
+       it != fake_output_buffers_.end(); ++it) {
+    OMX_BUFFERHEADERTYPE* buffer = *it;
+    OMX_ERRORTYPE result =
+        OMX_FreeBuffer(component_handle_, output_port_, buffer);
+    if (result != OMX_ErrorNone) {
+      DLOG(ERROR) << "OMX_FreeBuffer failed: 0x" << std::hex << result;
+      failure_seen = true;
+    }
+  }
+  fake_output_buffers_.clear();
+
+  // Dequeue pending queued_picture_buffer_ids_
+  if (client_) {
+    for (size_t i = 0; i < queued_picture_buffer_ids_.size(); ++i)
+      client_->DismissPictureBuffer(queued_picture_buffer_ids_[i]);
+  }
+  queued_picture_buffer_ids_.clear();
+
+  RETURN_ON_FAILURE(!failure_seen, "OMX_FreeBuffer", PLATFORM_FAILURE,);
+}
+
+void OmxrVideoDecodeAccelerator::OnPortSettingsChanged() {
+  VLOGF(1) << "Port settings changed received";
+  current_state_change_ = RESIZING;
+  SendCommandToPort(OMX_CommandPortDisable, output_port_);
+
+  for (OutputPictureById::iterator it = pictures_.begin();
+           it != pictures_.end(); ++it) {
+    if (!it->second->at_component) {
+      OMX_ERRORTYPE result = it->second->FreeOMXHandle();
+      RETURN_ON_OMX_FAILURE(result, "OMX_FreeBuffer", PLATFORM_FAILURE,);
+    }
+  }
+}
+
+void OmxrVideoDecodeAccelerator::OnOutputPortDisabled() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  OMX_PARAM_PORTDEFINITIONTYPE port_format;
+  InitParam(&port_format);
+  port_format.nPortIndex = output_port_;
+  OMX_ERRORTYPE result = OMX_GetParameter(
+      component_handle_, OMX_IndexParamPortDefinition, &port_format);
+  RETURN_ON_OMX_FAILURE(result, "OMX_GetParameter", PLATFORM_FAILURE,);
+  DCHECK_LE(port_format.nBufferCountMin, kNumPictureBuffers);
+
+  // TODO(fischman): to support mid-stream resize, need to free/dismiss any
+  // |pictures_| we already have.  Make sure that the shutdown-path agrees with
+  // this (there's already freeing logic there, which should not be duplicated).
+
+  // Request picture buffers to be handed to the component.
+  // ProvidePictureBuffers() will trigger AssignPictureBuffers, which ultimately
+  // assigns the textures to the component and re-enables the port.
+  const OMX_VIDEO_PORTDEFINITIONTYPE& vformat = port_format.format.video;
+  picture_buffer_dimensions_.SetSize(vformat.nFrameWidth,
+                                                    vformat.nFrameHeight);
+  if (client_) {
+    client_->ProvidePictureBuffers(
+        kNumPictureBuffers,
+        PIXEL_FORMAT_NV12,
+        1,
+        picture_buffer_dimensions_,
+        GL_TEXTURE_EXTERNAL_OES);
+  }
+}
+
+void OmxrVideoDecodeAccelerator::OnOutputPortEnabled() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+
+  if (current_state_change_ == RESETTING) {
+    for (OutputPictureById::iterator it = pictures_.begin();
+         it != pictures_.end(); ++it) {
+      queued_picture_buffer_ids_.push_back(it->first);
+    }
+    return;
+  }
+
+  if (!CanFillBuffer()) {
+    StopOnError(ILLEGAL_STATE);
+    return;
+  }
+
+  // Provide output buffers to decoder.
+  for (OutputPictureById::iterator it = pictures_.begin();
+       it != pictures_.end(); ++it) {
+    if (it->second->allocated)
+        continue;
+    OMX_BUFFERHEADERTYPE* omx_buffer = it->second->omx_buffer_header;
+    DCHECK(omx_buffer);
+    // Clear EOS flag.
+    omx_buffer->nFlags &= ~OMX_BUFFERFLAG_EOS;
+    omx_buffer->nOutputPortIndex = output_port_;
+    ++output_buffers_at_component_;
+    it->second->at_component = true;
+    OMX_ERRORTYPE result = OMX_FillThisBuffer(component_handle_, omx_buffer);
+    RETURN_ON_OMX_FAILURE(result, "OMX_FillThisBuffer() failed",
+                          PLATFORM_FAILURE,);
+    it->second->allocated = true;
+  }
+}
+
+void OmxrVideoDecodeAccelerator::FillBufferDoneTask(
+    OMX_BUFFERHEADERTYPE* buffer) {
+  VLOGF(2);
+  OutputPicture *output_picture =
+      reinterpret_cast<OutputPicture*>(buffer->pAppPrivate);
+
+  int picture_buffer_id = output_picture ? output_picture->picture_buffer.id() : -1;
+
+  TRACE_EVENT2("media,gpu", "OVDA::FillBufferDoneTask",
+               "Buffer id", buffer->nTimeStamp,
+               "Picture id", picture_buffer_id);
+  DCHECK(decode_task_runner_->BelongsToCurrentThread());
+  DCHECK_GT(output_buffers_at_component_, 0);
+  --output_buffers_at_component_;
+
+  // If we are destroying and then get a fillbuffer callback, calling into any
+  // openmax function will put us in error mode, so bail now. In the RESETTING
+  // case we still need to enqueue the picture ids but have to avoid giving
+  // them to the client (this is handled below).
+  if (current_state_change_ == DESTROYING ||
+      current_state_change_ == ERRORING)
+    return;
+
+  // During the transition from Executing to Idle, and during port-flushing, all
+  // pictures are sent back through here.  Avoid giving them to the client.
+  if (current_state_change_ == RESETTING) {
+    queued_picture_buffer_ids_.push_back(picture_buffer_id);
+    return;
+  }
+
+  if (fake_output_buffers_.size() && fake_output_buffers_.count(buffer)) {
+    size_t erased = fake_output_buffers_.erase(buffer);
+    DCHECK_EQ(erased, 1U);
+    OMX_ERRORTYPE result =
+        OMX_FreeBuffer(component_handle_, output_port_, buffer);
+    RETURN_ON_OMX_FAILURE(result, "OMX_FreeBuffer failed", PLATFORM_FAILURE,);
+    return;
+  }
+  DCHECK(!fake_output_buffers_.size());
+
+  output_picture->at_component = false;
+
+  if (current_state_change_ == RESIZING) {
+    VLOGF(1) << "Freeing buffer during resize. remaining at component: " << output_buffers_at_component_;
+    pictures_.erase(output_picture->picture_buffer.id());
+    return;
+  }
+
+  if (reset_pending_)
+    FinishReset();
+
+  // When the EOS picture is delivered back to us, notify the client and reuse
+  // the underlying picturebuffer.
+  if (buffer->nFlags & OMX_BUFFERFLAG_EOS) {
+    buffer->nFlags &= ~OMX_BUFFERFLAG_EOS;
+    OnReachedEOSInFlushing();
+    QueuePictureBuffer(picture_buffer_id);
+    return;
+  }
+
+
+  //TODO(dhobsong): Set up colorspace (BT.601 vs BT.709)*/
+  media::Picture picture(picture_buffer_id, buffer->nTimeStamp,
+            gfx::Rect(picture_buffer_dimensions_), gfx::ColorSpace(), false);
+
+  // See Decode() for an explanation of this abuse of nTimeStamp.
+  if (decode_client_)
+    decode_client_->PictureReady(picture);
+}
+
+void OmxrVideoDecodeAccelerator::EmptyBufferDoneTask(
+    OMX_BUFFERHEADERTYPE* buffer) {
+  TRACE_EVENT1("media,gpu", "OVDA::EmptyBufferDoneTask",
+               "Buffer id", buffer->nTimeStamp);
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  DCHECK_GT(input_buffers_at_component_, 0);
+  free_input_buffers_.push(buffer);
+  input_buffers_at_component_--;
+  if (buffer->nFlags & OMX_BUFFERFLAG_EOS)
+    return;
+
+  DecodeQueuedBitstreamBuffers();
+}
+
+void OmxrVideoDecodeAccelerator::DispatchStateReached(OMX_STATETYPE reached) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  switch (current_state_change_) {
+    case INITIALIZING:
+      switch (reached) {
+        case OMX_StateIdle:
+          OnReachedIdleInInitializing();
+          return;
+        case OMX_StateExecuting:
+          OnReachedExecutingInInitializing();
+          return;
+        default:
+          NOTREACHED() << "Unexpected state in INITIALIZING: " << reached;
+          return;
+      }
+    case RESETTING:
+      switch (reached) {
+        case OMX_StatePause:
+          OnReachedPauseInResetting();
+          return;
+        case OMX_StateExecuting:
+          OnReachedExecutingInResetting();
+          return;
+        default:
+          NOTREACHED() << "Unexpected state in RESETTING: " << reached;
+          return;
+      }
+    case DESTROYING:
+      switch (reached) {
+        case OMX_StatePause:
+        case OMX_StateExecuting:
+          // Because Destroy() can interrupt an in-progress Reset(),
+          // we might arrive at these states after current_state_change_ was
+          // overwritten with DESTROYING.  That's fine though - we already have
+          // the state transition for Destroy() queued up at the component, so
+          // we treat this as a no-op.
+          return;
+        case OMX_StateIdle:
+          OnReachedIdleInDestroying();
+          return;
+        case OMX_StateLoaded:
+          OnReachedLoadedInDestroying();
+          return;
+        default:
+          NOTREACHED() << "Unexpected state in DESTROYING: " << reached;
+          return;
+      }
+    case ERRORING:
+      switch (reached) {
+        case OMX_StateInvalid:
+          OnReachedInvalidInErroring();
+          return;
+        default:
+          NOTREACHED() << "Unexpected state in ERRORING: " << reached;
+          return;
+      }
+    default:
+      NOTREACHED() << "Unexpected state in " << current_state_change_
+                   << ": " << reached;
+  }
+}
+
+void OmxrVideoDecodeAccelerator::HandleSyncronousInit(OMX_EVENTTYPE event,
+                                                         OMX_U32 data1,
+                                                         OMX_U32 data2) {
+
+  VLOGF(1) << "event = " << event;
+  switch (event) {
+    case OMX_EventCmdComplete:
+      if (data1 == OMX_CommandStateSet) {
+        if (data2 == OMX_StateIdle) {
+          OnReachedIdleInInitializing();
+          return;
+        } else if (data2 == OMX_StateExecuting) {
+          OnReachedExecutingInInitializing();
+          return;
+        }
+      }
+      //fall through
+    default:
+      RETURN_ON_FAILURE(false, __func__ << "Unexpected unhandled event: " << event,
+                        PLATFORM_FAILURE,);
+  }
+}
+
+void OmxrVideoDecodeAccelerator::EventHandlerCompleteTask(OMX_EVENTTYPE event,
+                                                         OMX_U32 data1,
+                                                         OMX_U32 data2) {
+  VLOGF(1) << "event:" << event << " data:" << data1 << ":" << data2;
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  switch (event) {
+    case OMX_EventCmdComplete:
+      switch (data1) {
+        case OMX_CommandPortDisable:
+          DCHECK_EQ(data2, output_port_);
+          OnOutputPortDisabled();
+          return;
+        case OMX_CommandPortEnable:
+          DCHECK_EQ(data2, output_port_);
+          OnOutputPortEnabled();
+          return;
+        case OMX_CommandStateSet:
+          DispatchStateReached(static_cast<OMX_STATETYPE>(data2));
+          return;
+        case OMX_CommandFlush:
+          if (current_state_change_ == DESTROYING ||
+              current_state_change_ == ERRORING) {
+            return;
+          }
+          DCHECK_EQ(current_state_change_, RESETTING);
+          if (data2 == input_port_)
+            InputPortFlushDone();
+          else if (data2 == output_port_)
+            OutputPortFlushDone();
+          else
+            NOTREACHED() << "Unexpected port flushed: " << data2;
+          return;
+        default:
+          RETURN_ON_FAILURE(false, "Unknown command completed: " << data1,
+                            PLATFORM_FAILURE,);
+      }
+      return;
+    case OMX_EventError:
+      if (current_state_change_ != DESTROYING &&
+          current_state_change_ != ERRORING) {
+        RETURN_ON_FAILURE(false, "EventError: 0x" << std::hex << data1,
+                          PLATFORM_FAILURE,);
+      }
+      return;
+    case OMX_EventPortSettingsChanged:
+      if (data1 == output_port_ &&
+          data2 == OMX_IndexParamPortDefinition) {
+        // This event is only used for output resize; kick off handling that by
+        // pausing the output port.
+        OnPortSettingsChanged();
+      } else if (data1 == output_port_ &&
+                 data2 == OMX_IndexConfigCommonOutputCrop) {
+        // TODO(vjain): Handle video crop rect.
+      } else if (data1 == output_port_ &&
+                 data2 == OMX_IndexConfigCommonScale) {
+        // TODO(ashokm@nvidia.com): Handle video SAR change.
+      } else {
+        RETURN_ON_FAILURE(false,
+                          "Unexpected EventPortSettingsChanged: "
+                          << data1 << ", " << data2,
+                          PLATFORM_FAILURE,);
+      }
+      return;
+    case OMX_EventBufferFlag:
+      if (data1 == output_port_) {
+        // In case of Destroy() interrupting Flush().
+        if (current_state_change_ == DESTROYING)
+          return;
+        DCHECK_EQ(current_state_change_, FLUSHING);
+        // Do nothing; rely on the EOS picture delivery to notify the client.
+      } else {
+        RETURN_ON_FAILURE(false,
+                          "Unexpected OMX_EventBufferFlag: "
+                          << data1 << ", " << data2,
+                          PLATFORM_FAILURE,);
+      }
+      return;
+    default:
+      RETURN_ON_FAILURE(false, "Unexpected unhandled event: " << event,
+                        PLATFORM_FAILURE,);
+  }
+}
+
+// static
+void OmxrVideoDecodeAccelerator::PreSandboxInitialization() {
+  VLOG(1) << "Starting pre sandbox init";
+  //enumerate and dlopen codec libraries*/
+  OmxrProfileManager::Get();
+}
+
+// static
+OMX_ERRORTYPE OmxrVideoDecodeAccelerator::EventHandler(OMX_HANDLETYPE component,
+                                                      OMX_PTR priv_data,
+                                                      OMX_EVENTTYPE event,
+                                                      OMX_U32 data1,
+                                                      OMX_U32 data2,
+                                                      OMX_PTR event_data) {
+
+  VLOGF(1);
+  // Called on the OMX thread.
+  OmxrVideoDecodeAccelerator* decoder =
+      static_cast<OmxrVideoDecodeAccelerator*>(priv_data);
+  DCHECK_EQ(component, decoder->component_handle_);
+
+  if (!decoder->deferred_init_allowed_ &&
+         decoder->current_state_change_ == INITIALIZING) {
+      decoder->HandleSyncronousInit(event, data1, data2);
+      return OMX_ErrorNone;
+  }
+
+  decoder->child_task_runner_->PostTask(FROM_HERE, base::Bind(
+      &OmxrVideoDecodeAccelerator::EventHandlerCompleteTask,
+      decoder->weak_this(), event, data1, data2));
+  return OMX_ErrorNone;
+}
+
+// static
+OMX_ERRORTYPE OmxrVideoDecodeAccelerator::EmptyBufferCallback(
+    OMX_HANDLETYPE component,
+    OMX_PTR priv_data,
+    OMX_BUFFERHEADERTYPE* buffer) {
+  TRACE_EVENT1("media,gpu", "OVDA::EmptyBufferCallback",
+               "Buffer id", buffer->nTimeStamp);
+  // Called on the OMX thread.
+  OmxrVideoDecodeAccelerator* decoder =
+      static_cast<OmxrVideoDecodeAccelerator*>(priv_data);
+  DCHECK_EQ(component, decoder->component_handle_);
+  decoder->decode_task_runner_->PostTask(FROM_HERE, base::Bind(
+      &OmxrVideoDecodeAccelerator::EmptyBufferDoneTask, decoder->weak_this(),
+      buffer));
+  return OMX_ErrorNone;
+}
+
+// static
+OMX_ERRORTYPE OmxrVideoDecodeAccelerator::FillBufferCallback(
+    OMX_HANDLETYPE component,
+    OMX_PTR priv_data,
+    OMX_BUFFERHEADERTYPE* buffer) {
+  media::Picture* picture =
+      reinterpret_cast<media::Picture*>(buffer->pAppPrivate);
+  int picture_buffer_id = picture ? picture->picture_buffer_id() : -1;
+  TRACE_EVENT2("media,gpu", "OVDA::FillBufferCallback",
+               "Buffer id", buffer->nTimeStamp,
+               "Picture id", picture_buffer_id);
+  // Called on the OMX thread.
+  OmxrVideoDecodeAccelerator* decoder =
+      static_cast<OmxrVideoDecodeAccelerator*>(priv_data);
+  DCHECK_EQ(component, decoder->component_handle_);
+  decoder->decode_task_runner_->PostTask(FROM_HERE, base::Bind(
+      &OmxrVideoDecodeAccelerator::FillBufferDoneTask, decoder->weak_this(),
+      buffer));
+  return OMX_ErrorNone;
+}
+
+bool OmxrVideoDecodeAccelerator::CanFillBuffer() {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  const CurrentStateChange csc = current_state_change_;
+  const OMX_STATETYPE cs = client_state_;
+  return (csc != DESTROYING && csc != ERRORING && csc != RESETTING) &&
+      (cs == OMX_StateIdle || cs == OMX_StateExecuting || cs == OMX_StatePause);
+}
+
+bool OmxrVideoDecodeAccelerator::SendCommandToPort(
+    OMX_COMMANDTYPE cmd, int port_index) {
+  DCHECK(child_task_runner_->BelongsToCurrentThread());
+  OMX_ERRORTYPE result = OMX_SendCommand(component_handle_,
+                                         cmd, port_index, 0);
+  RETURN_ON_OMX_FAILURE(result, "SendCommand() failed" << cmd,
+                        PLATFORM_FAILURE, false);
+  return true;
+}
+
+}  // namespace content
diff --git a/media/gpu/omx/omxr_video_decode_accelerator.h b/media/gpu/omx/omxr_video_decode_accelerator.h
new file mode 100644
index 0000000..9eccb04
--- /dev/null
+++ b/media/gpu/omx/omxr_video_decode_accelerator.h
@@ -0,0 +1,365 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_COMMON_GPU_MEDIA_OMX_VIDEO_DECODE_ACCELERATOR_H_
+#define CONTENT_COMMON_GPU_MEDIA_OMX_VIDEO_DECODE_ACCELERATOR_H_
+
+#include <dlfcn.h>
+#include <map>
+#include <queue>
+#include <set>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/logging.h"
+#include "base/memory/shared_memory.h"
+#include "base/message_loop/message_loop.h"
+#include "base/synchronization/lock.h"
+#include "base/synchronization/condition_variable.h"
+#include "content/common/content_export.h"
+#include "media/video/h264_parser.h"
+#include "media/video/video_decode_accelerator.h"
+#include "third_party/mmngr/mmngr_user_public.h"
+#include "third_party/mmngr/mmngr_buf_user_public.h"
+#include "third_party/openmax/il/OMX_Component.h"
+#include "third_party/openmax/il/OMX_Core.h"
+#include "third_party/openmax/il/OMX_Video.h"
+#include "ui/gl/gl_bindings.h"
+#include "ui/gl/gl_fence.h"
+
+namespace media {
+
+// Class to wrap OpenMAX IL accelerator behind VideoDecodeAccelerator interface.
+// The implementation assumes an OpenMAX IL 1.1.2 implementation conforming to
+// http://www.khronos.org/registry/omxil/specs/OpenMAX_IL_1_1_2_Specification.pdf
+//
+// This class lives on a single thread (the GPU process ChildThread) and DCHECKs
+// that it is never accessed from any other.  OMX callbacks are trampolined from
+// the OMX component's thread to maintain this invariant, using |weak_this()|.
+class CONTENT_EXPORT OmxrVideoDecodeAccelerator :
+    public VideoDecodeAccelerator {
+ public:
+  // Does not take ownership of |client| which must outlive |*this|.
+  OmxrVideoDecodeAccelerator(
+      EGLDisplay egl_display,
+      const base::Callback<bool(void)>& make_context_current);
+  virtual ~OmxrVideoDecodeAccelerator();
+
+  // media::VideoDecodeAccelerator implementation.
+  bool Initialize(const Config& config, Client* client) override;
+  void Decode(const media::BitstreamBuffer& bitstream_buffer) override;
+  virtual void AssignPictureBuffers(
+      const std::vector<media::PictureBuffer>& buffers) override;
+  void ReusePictureBuffer(int32_t picture_buffer_id) override;
+  void Flush() override;
+  void Reset() override;
+  void Destroy() override;
+  bool TryToSetupDecodeOnSeparateThread(const base::WeakPtr<Client>& decode_client,
+   const scoped_refptr<base::SingleThreadTaskRunner>& decode_task_runner) override;
+
+  base::WeakPtr<OmxrVideoDecodeAccelerator> weak_this() { return weak_this_; }
+
+  static VideoDecodeAccelerator::SupportedProfiles GetSupportedProfiles();
+  // Do any necessary initialization before the sandbox is enabled.
+  static void PreSandboxInitialization();
+
+ private:
+  // Because OMX state-transitions are described solely by the "state reached"
+  // (3.1.2.9.1, table 3-7 of the spec), we track what transition was requested
+  // using this enum.  Note that it is an error to request a transition while
+  // |*this| is in any state other than NO_TRANSITION, unless requesting
+  // DESTROYING or ERRORING.
+  enum CurrentStateChange {
+    NO_TRANSITION,  // Not in the middle of a transition.
+    INITIALIZING,
+    FLUSHING,
+    RESETTING,
+    RESIZING,
+    DESTROYING,
+    ERRORING,  // Trumps all other transitions; no recovery is possible.
+  };
+
+  // Add codecs as we get HW that supports them (and which are supported by SW
+  // decode!).
+  enum Codec {
+    UNKNOWN,
+    H264,
+    VP8,
+    CODEC_MAX,
+  };
+
+  struct CodecInfo {
+    Codec codec;
+    const char *role;
+    char *component;
+  };
+
+  // Helper struct for keeping track of MMNGR buffer metadata
+  struct MmngrBuffer {
+    MMNGR_ID mem_id;
+    uint32_t hard_addr;
+    int dmabuf_id;
+    int dmabuf_fd;
+  };
+
+  // Helper struct for keeping track of all output buffer metadata
+  // buffer and the PictureBuffer it points to.
+  struct OutputPicture {
+    OutputPicture(
+          const OmxrVideoDecodeAccelerator &dec,
+          media::PictureBuffer pbuffer,
+          OMX_BUFFERHEADERTYPE* obuffer,
+          EGLImageKHR eimage,
+          struct MmngrBuffer mbuf);
+    virtual ~OutputPicture();
+
+    OMX_ERRORTYPE FreeOMXHandle();
+
+    const OmxrVideoDecodeAccelerator &decoder;
+    media::PictureBuffer picture_buffer;
+    OMX_BUFFERHEADERTYPE* omx_buffer_header;
+    EGLImageKHR egl_image;
+    struct MmngrBuffer mmngr_buf;
+    bool at_component;
+    bool allocated;
+  };
+
+  class OmxrProfileManager {
+  public:
+    static const OmxrProfileManager &Get();
+
+    OmxrProfileManager();
+    ~OmxrProfileManager() = default;
+
+    const struct CodecInfo getCodecForProfile(VideoCodecProfile profile) const;
+    const std::vector<VideoCodecProfile> & getSupportedProfiles() const { return supported_profiles_;}
+
+  private:
+    void InitOMXLibs(void);
+
+  private:
+    std::vector<std::pair<struct CodecInfo, std::vector<VideoCodecProfile>>> possible_profiles_ = {
+        {{H264, "video_decoder.avc", nullptr}, {H264PROFILE_BASELINE, H264PROFILE_MAIN, H264PROFILE_HIGH}},
+        {{VP8, "video_decoder.vp9", nullptr}, {VP8PROFILE_ANY}}
+    };
+    std::vector<VideoCodecProfile> supported_profiles_;
+  };
+
+  struct BitstreamBufferRef {
+    BitstreamBufferRef(
+      const media::BitstreamBuffer &buf,
+      scoped_refptr<base::SingleThreadTaskRunner> tr,
+      base::WeakPtr<Client> cl);
+    virtual ~BitstreamBufferRef();
+
+    std::unique_ptr<base::SharedMemory> shm;
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner;
+    base::WeakPtr<Client> client;
+    int32_t id;
+    size_t size;
+    void *memory;
+  };
+
+  typedef std::map<int32_t, std::unique_ptr<OutputPicture>> OutputPictureById;
+
+  scoped_refptr<base::SingleThreadTaskRunner> child_task_runner_;
+
+  OMX_HANDLETYPE component_handle_;
+
+  // Create the Component for OMX. Handles all OMX initialization.
+  bool CreateComponent(const struct CodecInfo &cinfo);
+  // Do any decoder specific initialization not covered in the standard OMX spec
+  bool DecoderSpecificInitialization();
+
+  // Buffer allocation/free methods for input and output buffers.
+  bool AllocateInputBuffers();
+  bool AllocateFakeOutputBuffers();
+  bool AllocateOutputBuffers(int size);
+  void FreeOMXBuffers();
+
+  // Methods to handle OMX state transitions.  See section 3.1.1.2 of the spec.
+  // Request transitioning OMX component to some other state.
+  void BeginTransitionToState(OMX_STATETYPE new_state);
+  // The callback received when the OMX component has transitioned.
+  void DispatchStateReached(OMX_STATETYPE reached);
+  // Callbacks handling transitioning to specific states during state changes.
+  // These follow a convention of OnReached<STATE>In<CurrentStateChange>(),
+  // requiring that each pair of <reached-state>/CurrentStateChange is unique
+  // (i.e. the source state is uniquely defined by the pair).
+  void OnReachedIdleInInitializing();
+  void OnReachedExecutingInInitializing();
+  void OnReachedPauseInResetting();
+  void OnReachedExecutingInResetting();
+  void OnReachedIdleInDestroying();
+  void OnReachedLoadedInDestroying();
+  void OnReachedEOSInFlushing();
+  void OnReachedInvalidInErroring();
+  void ShutdownComponent();
+  void BusyLoopInDestroying(std::unique_ptr<OmxrVideoDecodeAccelerator> self);
+
+  // Port-flushing helpers.
+  void FlushIOPorts();
+  void InputPortFlushDone();
+  void OutputPortFlushDone();
+
+  // Stop the component when any error is detected.
+  void StopOnError(media::VideoDecodeAccelerator::Error error);
+
+  // Determine whether we can issue fill buffer to the decoder based on the
+  // current state (and outstanding state change) of the component.
+  bool CanFillBuffer();
+
+  // Whenever port settings change, the first thing we must do is disable the
+  // port (see Figure 3-18 of the OpenMAX IL spec linked to above).  When the
+  // port is disabled, the component will call us back here.  We then re-enable
+  // the port once we have textures, and that's the second method below.
+  void OnOutputPortDisabled();
+  void OnOutputPortEnabled();
+  void OnPortSettingsChanged();
+
+  // Do the Decode() heavy lifting.
+  void DecodeBuffer(std::unique_ptr<struct BitstreamBufferRef> input_buffer);
+  // Decode bitstream buffers that were queued (see queued_bitstream_buffers_).
+  void DecodeQueuedBitstreamBuffers();
+
+  // Weak pointer to |this|; used to safely trampoline calls from the OMX thread
+  // to the ChildThread.  Since |this| is kept alive until OMX is fully shut
+  // down, only the OMX->Child thread direction needs to be guarded this way.
+  base::WeakPtr<OmxrVideoDecodeAccelerator> weak_this_;
+  base::WeakPtrFactory<OmxrVideoDecodeAccelerator> weak_this_factory_;
+
+  // True once Initialize() has returned true; before this point there's never a
+  // point in calling client_->NotifyError().
+  bool init_begun_;
+
+  base::Lock init_lock_;
+  base::ConditionVariable init_done_cond_;
+
+  // IL-client state.
+  OMX_STATETYPE client_state_;
+  // See comment on CurrentStateChange above.
+  CurrentStateChange current_state_change_;
+
+  // Following are input port related variables.
+  int input_buffer_count_;
+  int input_buffer_size_;
+  OMX_U32 input_port_;
+  int input_buffers_at_component_;
+
+  std::unique_ptr<H264Parser> h264_parser_;
+  int input_buffer_offset_;
+  bool first_input_buffer_sent_;
+  bool previous_frame_has_data_;
+
+  // Following are output port related variables.
+  OMX_U32 output_port_;
+  int output_buffer_size_;
+  int output_buffers_at_component_;
+  int page_size_;
+
+  gfx::Size picture_buffer_dimensions_;
+
+  /* Helpers to handle restrictions on Reset() timing*/
+  bool reset_pending_;
+  void FinishReset();
+
+  // NOTE: someday there may be multiple contexts for a single decoder.  But not
+  // today.
+  // TODO(fischman,vrk): handle lost contexts?
+  EGLDisplay egl_display_;
+  EGLContext egl_context_;
+  base::Callback<bool(void)> make_context_current_;
+
+  // Free input OpenMAX buffers that can be used to take bitstream from demuxer.
+  std::queue<OMX_BUFFERHEADERTYPE*> free_input_buffers_;
+
+  // For output buffer recycling cases.
+  OutputPictureById pictures_;
+
+  // To kick the component from Loaded to Idle before we know the real size of
+  // the video (so can't yet ask for textures) we populate it with fake output
+  // buffers.  Keep track of them here.
+  // TODO(fischman): do away with this madness.
+  std::set<OMX_BUFFERHEADERTYPE*> fake_output_buffers_;
+
+  // Encoded bitstream buffers awaiting decode, queued while the decoder was
+  // unable to accept them.
+  typedef std::vector<std::unique_ptr<BitstreamBufferRef>> BitstreamBufferList;
+  BitstreamBufferList queued_bitstream_buffers_;
+  // Available output picture buffers released during Reset() and awaiting
+  // re-use once Reset is done.  Is empty most of the time and drained right
+  // before NotifyResetDone is sent.
+  std::vector<int> queued_picture_buffer_ids_;
+
+  // To expose client callbacks from VideoDecodeAccelerator.
+  // NOTE: all calls to these objects *MUST* be executed on
+  // message_loop_.
+  std::unique_ptr<base::WeakPtrFactory<Client>> client_ptr_factory_;
+  base::WeakPtr<Client> client_;
+
+
+  // The following are used when performing Docode() tasks from
+  // a separate thread.  Otherwise they will be set to
+  // |child_task_runner_| and |client_| respectively
+
+  scoped_refptr<base::SingleThreadTaskRunner> decode_task_runner_;
+  base::WeakPtr<Client> decode_client_;
+
+  // These members are only used during Initialization.
+  Codec codec_;
+  bool deferred_init_allowed_;
+
+  // Handle syncronous transition to EXECUTING state when deferred init is
+  // not available.
+  void HandleSyncronousInit(OMX_EVENTTYPE event,
+                                OMX_U32 data1,
+                                OMX_U32 data2);
+  // Method to handle events
+  void EventHandlerCompleteTask(OMX_EVENTTYPE event,
+                                OMX_U32 data1,
+                                OMX_U32 data2);
+
+  // Method to receive buffers from component's input port
+  void EmptyBufferDoneTask(OMX_BUFFERHEADERTYPE* buffer);
+
+  // Method to receive buffers from component's output port
+  void FillBufferDoneTask(OMX_BUFFERHEADERTYPE* buffer);
+
+  // Send a command to an OMX port.  Return false on failure (after logging and
+  // setting |this| to ERRORING state).
+  bool SendCommandToPort(OMX_COMMANDTYPE cmd, int port_index);
+
+  // Callback methods for the OMX component.
+  // When these callbacks are received, the
+  // call is delegated to the three internal methods above.
+  static OMX_ERRORTYPE EventHandler(OMX_HANDLETYPE component,
+                                    OMX_PTR priv_data,
+                                    OMX_EVENTTYPE event,
+                                    OMX_U32 data1, OMX_U32 data2,
+                                    OMX_PTR event_data);
+  static OMX_ERRORTYPE EmptyBufferCallback(OMX_HANDLETYPE component,
+                                           OMX_PTR priv_data,
+                                           OMX_BUFFERHEADERTYPE* buffer);
+  static OMX_ERRORTYPE FillBufferCallback(OMX_HANDLETYPE component,
+                                          OMX_PTR priv_data,
+                                          OMX_BUFFERHEADERTYPE* buffer);
+
+  // When we get a texture back via ReusePictureBuffer(), we want to ensure
+  // that its contents have been read out by rendering layer, before we start
+  // overwriting it with the decoder. Use a GPU fence and CheckPicutreStatus()
+  // to poll for the fence completion before sending it to the decoder.
+  void CheckPictureStatus(int32_t picture_buffer_id,
+            std::unique_ptr<gl::GLFence> fence_obj);
+
+  // Queue a picture for use by the decoder, either by sending it directly to it
+  // via OMX_FillThisBuffer, or by queueing it for later if we are RESETTING.
+  void QueuePictureBuffer(int32_t picture_buffer_id);
+
+};
+
+}  // namespace content
+
+#endif  // CONTENT_COMMON_GPU_MEDIA_OMX_VIDEO_DECODE_ACCELERATOR_H_
diff --git a/media/gpu/video_decode_accelerator_unittest.cc b/media/gpu/video_decode_accelerator_unittest.cc
index 09289b9..f40efd7 100644
--- a/media/gpu/video_decode_accelerator_unittest.cc
+++ b/media/gpu/video_decode_accelerator_unittest.cc
@@ -84,6 +84,10 @@
 #include "media/gpu/vaapi/vaapi_wrapper.h"
 #endif  // BUILDFLAG(USE_VAAPI)
 
+#if BUILDFLAG(USE_OMX_CODEC)
+#include "media/gpu/omx/omxr_video_decode_accelerator.h"
+#endif  // BUILDFLAG(USE_OMX_CODEC)
+
 #if defined(OS_CHROMEOS)
 #include "ui/ozone/public/ozone_platform.h"
 #endif  // defined(OS_CHROMEOS)
@@ -1789,6 +1793,8 @@ class VDATestSuite : public base::TestSuite {
     media::VaapiWrapper::PreSandboxInitialization();
 #elif defined(OS_WIN)
     media::DXVAVideoDecodeAccelerator::PreSandboxInitialization();
+#elif BUILDFLAG(USE_OMX_CODEC)
+    media::OmxrVideoDecodeAccelerator::PreSandboxInitialization();
 #endif
   }
 
diff --git a/third_party/mmngr/mmngr_buf_user_public.h b/third_party/mmngr/mmngr_buf_user_public.h
new file mode 100644
index 0000000..78eeb86
--- /dev/null
+++ b/third_party/mmngr/mmngr_buf_user_public.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2015 Renesas Electronics Corporation
+ * Released under the MIT license
+ * http://opensource.org/licenses/mit-license.php
+ */
+#ifndef	__MMNGR_BUF_USER_PUBLIC_H__
+#define __MMNGR_BUF_USER_PUBLIC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/* Gen3 API */
+int mmngr_export_start_in_user_ext(int *pid,
+			size_t size,
+			unsigned int hard_addr,
+			int *pbuf,
+			void *mem_param);
+int mmngr_export_end_in_user_ext(int id);
+int mmngr_import_start_in_user_ext(int *pid,
+			size_t *psize,
+			unsigned int *phard_addr,
+			int buf,
+			void *mem_param);
+int mmngr_import_end_in_user_ext(int id);
+
+/* Gen2 Legacy API */
+int mmngr_export_start_in_user(int *pid,
+			unsigned long size,
+			unsigned long hard_addr,
+			int *pbuf);
+int mmngr_export_end_in_user(int id);
+int mmngr_import_start_in_user(int *pid,
+			unsigned long *psize,
+			unsigned long *phard_addr,
+			int buf);
+int mmngr_import_end_in_user(int id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#define R_MM_OK			0
+#define R_MM_FATAL		-1
+#define R_MM_SEQE		-2
+#define R_MM_PARE		-3
+#define R_MM_NOMEM		-4
+
+#endif	/* __MMNGR_BUF_USER_PUBLIC_H__ */
diff --git a/third_party/mmngr/mmngr_public_cmn.h b/third_party/mmngr/mmngr_public_cmn.h
new file mode 100644
index 0000000..dce81a1
--- /dev/null
+++ b/third_party/mmngr/mmngr_public_cmn.h
@@ -0,0 +1,69 @@
+/*************************************************************************/ /*
+ MMNGR
+
+ Copyright (C) 2016 Renesas Electronics Corporation
+
+ License        Dual MIT/GPLv2
+
+ The contents of this file are subject to the MIT license as set out below.
+
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+
+ Alternatively, the contents of this file may be used under the terms of
+ the GNU General Public License Version 2 ("GPL") in which case the provisions
+ of GPL are applicable instead of those above.
+
+ If you wish to allow use of your version of this file only under the terms of
+ GPL, and not to allow others to use your version of this file under the terms
+ of the MIT license, indicate your decision by deleting the provisions above
+ and replace them with the notice and other provisions required by GPL as set
+ out in the file called "GPL-COPYING" included in this distribution. If you do
+ not delete the provisions above, a recipient may use your version of this file
+ under the terms of either the MIT license or GPL.
+
+ This License is also included in this distribution in the file called
+ "MIT-COPYING".
+
+ EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+ PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+ COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+ GPLv2:
+ If you wish to use this file under the terms of GPL, following terms are
+ effective.
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; version 2 of the License.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/ /*************************************************************************/
+#ifndef	__MMNGR_PUBLIC_CMN_H__
+#define __MMNGR_PUBLIC_CMN_H__
+
+#define MM_KERNELHEAP	0
+#define MM_CARVEOUT	1
+#define MM_CARVEOUT_SSP	3
+#define MM_CARVEOUT_LOSSY	4
+
+#endif	/* __MMNGR_PUBLIC_CMN_H__ */
diff --git a/third_party/mmngr/mmngr_user_public.h b/third_party/mmngr/mmngr_user_public.h
new file mode 100644
index 0000000..ef0f4b4
--- /dev/null
+++ b/third_party/mmngr/mmngr_user_public.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2015-2016 Renesas Electronics Corporation
+ * Released under the MIT license
+ * http://opensource.org/licenses/mit-license.php
+ */
+#ifndef	__MMNGR_USER_PUBLIC_H__
+#define __MMNGR_USER_PUBLIC_H__
+
+#include "mmngr_public_cmn.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int MMNGR_ID;
+
+struct MM_FUNC {
+	unsigned int func;
+	unsigned int type;
+	unsigned int attr;
+	unsigned int *conf;
+};
+
+/* Gen3 API */
+int mmngr_alloc_in_user_ext(MMNGR_ID *pid,
+			size_t size,
+			unsigned int *phard_addr,
+			void **puser_virt_addr,
+			unsigned int flag,
+			void *mem_param);
+int mmngr_free_in_user_ext(MMNGR_ID id);
+#define mmngr_debug_map_va_ext(a, b, c, d, e) \
+		mmngr_share_in_user_ext(a, b, c, d, e)
+#define mmngr_debug_unmap_va_ext(a) \
+		mmngr_release_in_user_ext(a)
+int mmngr_share_in_user_ext(MMNGR_ID *pid,
+			size_t size,
+			unsigned int hard_addr,
+			void **puser_virt_addr,
+			void *mem_param);
+int mmngr_release_in_user_ext(MMNGR_ID id);
+
+/* Gen2 Legacy API */
+int mmngr_alloc_in_user(MMNGR_ID *pid,
+			unsigned long size,
+			unsigned long *pphy_addr,
+			unsigned long *phard_addr,
+			unsigned long *puser_virt_addr,
+			unsigned long flag);
+int mmngr_free_in_user(MMNGR_ID id);
+#define mmngr_debug_map_va(a, b, c, d) \
+		mmngr_share_in_user(a, b, c, d)
+#define mmngr_debug_unmap_va(a) \
+		mmngr_release_in_user(a)
+int mmngr_share_in_user(MMNGR_ID *pid,
+			unsigned long size,
+			unsigned long hard_addr,
+			unsigned long *puser_virt_addr);
+int mmngr_release_in_user(MMNGR_ID id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#define R_MM_OK			0
+#define R_MM_FATAL		-1
+#define R_MM_SEQE		-2
+#define R_MM_PARE		-3
+#define R_MM_NOMEM		-4
+
+#define MMNGR_VA_SUPPORT	MM_KERNELHEAP
+#define MMNGR_PA_SUPPORT	MM_CARVEOUT
+#define MMNGR_PA_SUPPORT_SSP	MM_CARVEOUT_SSP
+#define MMNGR_PA_SUPPORT_LOSSY	MM_CARVEOUT_LOSSY
+
+#define MM_FUNC_LOSSY_DISABLE		0x0
+#define MM_FUNC_LOSSY_ENABLE		0x1
+#define MM_FUNC_TYPE_LOSSY_AREA		0x1
+#define MM_FUNC_TYPE_LOSSY_SHADOW	0x2
+#define MM_FUNC_FMT_LOSSY_YUVPLANAR	0x1
+#define MM_FUNC_FMT_LOSSY_YUV422INTLV	0x2
+#define MM_FUNC_FMT_LOSSY_ARGB8888	0x3
+#define MM_FUNC_STAT_LOSSY_NOT_SUPPORT	0x0
+#define MM_FUNC_STAT_LOSSY_SUPPORT	0x1
+
+#endif	/* __MMNGR_USER_PUBLIC_H__ */
diff --git a/third_party/openmax/README.chromium b/third_party/openmax/README.chromium
new file mode 100644
index 0000000..5794ff7
--- /dev/null
+++ b/third_party/openmax/README.chromium
@@ -0,0 +1,15 @@
+Name: OpenMAX IL
+Short Name: openmax
+URL: http://www.khronos.org/openmax/
+Version: 1.1.2
+License: BSD
+License File: il/LICENSE
+Security Critical: yes
+
+Description:
+Header files required to work with OpenMAX IL.
+From http://www.khronos.org/openmax/headers/omx_il_v1_1/omx_il_v1_1_2_headers.zip
+
+Local Modifications:
+- Converted to utf-8 with: vim +"argdo write ++enc=utf-8" *.h
+
diff --git a/third_party/openmax/il/BUILD.gn b/third_party/openmax/il/BUILD.gn
new file mode 100644
index 0000000..84f15a9
--- /dev/null
+++ b/third_party/openmax/il/BUILD.gn
@@ -0,0 +1,13 @@
+# Copyright 2018 Igel Co., Ltd. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+config("openmax_il_config") {
+  include_dirs = [ "." ]
+}
+group("openmax_il") {
+  all_dependent_configs = [
+     ":openmax_il_config"
+  ]
+}
+
diff --git a/third_party/openmax/il/LICENSE b/third_party/openmax/il/LICENSE
new file mode 100644
index 0000000..8d288f0
--- /dev/null
+++ b/third_party/openmax/il/LICENSE
@@ -0,0 +1,21 @@
+Copyright (c) 1998-2000 Thai Open Source Software Center Ltd and Clark Cooper
+Copyright (c) 2001-2017 Expat maintainers
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/third_party/openmax/il/LICENSE.rej b/third_party/openmax/il/LICENSE.rej
new file mode 100644
index 0000000..c6bb4e0
--- /dev/null
+++ b/third_party/openmax/il/LICENSE.rej
@@ -0,0 +1,28 @@
+--- third_party/expat/files/COPYING
++++ third_party/openmax/il/LICENSE
+@@ -1,20 +1,17 @@
+-Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
+-                               and Clark Cooper
+-Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006 Expat maintainers.
++Copyright (c) 2008 The Khronos Group Inc.
+ 
+ Permission is hereby granted, free of charge, to any person obtaining
+ a copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to
+-permit persons to whom the Software is furnished to do so, subject to
+-the following conditions:
+-
++permit persons to whom the Software is furnished to do so, subject
++to the following conditions:
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+ 
+-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
++OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
diff --git a/third_party/openmax/il/OMXR_Extension.h b/third_party/openmax/il/OMXR_Extension.h
new file mode 100644
index 0000000..475a632
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright(C) 2015-2017 Renesas Electronics Corporation. All Rights Reserved.
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ */
+/**
+ * The OMXR Extension header contains vendor-defined extension api and definitions.
+ *
+ * \file OMXR_Extension.h
+ */
+
+#ifndef OMXR_EXTENSION_H
+#define OMXR_EXTENSION_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Files                                                        */
+/***************************************************************************/
+#include "OMX_Types.h"
+#include "OMX_Core.h"
+#include "OMX_Component.h"
+#include "OMX_Index.h"
+#include "OMX_Audio.h"
+#include "OMX_Video.h"
+#include "OMX_Image.h"
+#include "OMX_IVCommon.h"
+#include "OMX_Other.h"
+
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+
+/**
+ * Base offset of the vendor-defined extensions for each domain (OMX_INDEXTYPE)
+ */
+enum {
+    OMXR_MC_IndexVendorBaseVideo                    = (OMX_IndexVendorStartUnused + 0x00000000),    /**< Video domain */
+    OMXR_MC_IndexVendorBaseAudio                    = (OMX_IndexVendorStartUnused + 0x00010000),    /**< Audio domain */
+    OMXR_MC_IndexVendorBaseImage                    = (OMX_IndexVendorStartUnused + 0x00020000),    /**< Image domain */
+    OMXR_MC_IndexVendorBaseOther                    = (OMX_IndexVendorStartUnused + 0x00030000)     /**< other */
+};
+
+/**
+ * Base offset of the vendor-defined extensions for each domain (OMX_EVENTTYPE)
+ */
+enum {
+    OMXR_MC_EventVendorBaseVideo                    = (OMX_EventVendorStartUnused + 0x00000000),    /**< Video domain */
+    OMXR_MC_EventVendorBaseAudio                    = (OMX_EventVendorStartUnused + 0x00010000),    /**< Audio domain */
+    OMXR_MC_EventVendorBaseImage                    = (OMX_EventVendorStartUnused + 0x00020000),    /**< Image domain */
+    OMXR_MC_EventVendorBaseOther                    = (OMX_EventVendorStartUnused + 0x00030000)     /**< other */
+};
+
+/**
+ * Base offset of the vendor-defined extensions for each domain (OMX_ERRORTYPE)
+ */
+enum {
+    OMXR_ErrorBase                                  = (OMX_ErrorVendorStartUnused + 0x00000000),    /**< Common */
+    OMXR_UTIL_ErrorBase                             = (OMX_ErrorVendorStartUnused + 0x00008000),    /**< Utility */
+    OMXR_MC_ErrorBaseVideo                          = (OMX_ErrorVendorStartUnused + 0x00010000),    /**< Video domain */
+    OMXR_MC_ErrorBaseAudio                          = (OMX_ErrorVendorStartUnused + 0x00020000),    /**< Audio domain */
+    OMXR_MC_ErrorBaseImage                          = (OMX_ErrorVendorStartUnused + 0x00030000),    /**< Image domain */
+    OMXR_MC_ErrorBaseOther                          = (OMX_ErrorVendorStartUnused + 0x00040000)     /**< other */
+};
+
+/* Error codes */
+#define OMXR_ErrorFileNotFound                      (OMX_S32)(OMXR_ErrorBase + 0x00000000)      /**< file is not found */
+#define OMXR_ErrorFileRead                          (OMX_S32)(OMXR_ErrorBase + 0x00000001)      /**< It isn't able to read the file */
+#define OMXR_ErrorIllegalConfig                     (OMX_S32)(OMXR_ErrorBase + 0x00000002)      /**< Illigal configuration file */
+
+/* Log message level */
+#define OMXR_LOG_LEVEL_NONE     0x0         /**< (not support) */
+#define OMXR_LOG_LEVEL_ERROR    0x1         /**< (not support) */
+#define OMXR_LOG_LEVEL_HIGH     0x2         /**< (not support) */
+#define OMXR_LOG_LEVEL_LOW      0x4         /**< (not support) */
+#define OMXR_LOG_LEVEL_DEBUG    0x8         /**< (not support) */
+#define OMXR_LOG_LEVEL_COMM     0x10        /**< (not support) */
+
+#define OMXR_BASE_LOG_LEVEL_ERROR    0x1    /**< bit pattern of error log level */
+#define OMXR_BASE_LOG_LEVEL_WARN     0x3    /**< bit pattern of warning log level */
+#define OMXR_BASE_LOG_LEVEL_INFO     0x7    /**< bit pattern of information log level */
+#define OMXR_BASE_LOG_LEVEL_DEBUG    0xf    /**< bit pattern of debug log level */
+
+#define OMXR_LOG_LEVEL_SHIFT_CORE     8     /**< core module */
+#define OMXR_LOG_LEVEL_SHIFT_UTIL    12     /**< utility module */
+#define OMXR_LOG_LEVEL_SHIFT_CMN     16     /**< common module */
+#define OMXR_LOG_LEVEL_SHIFT_VIDEO   20     /**< video module */
+#define OMXR_LOG_LEVEL_SHIFT_AUDIO   24     /**< audio module */
+#define OMXR_LOG_LEVEL_SHIFT_CNV     28     /**< video converter module */
+
+/* Log level for OMX Core module */
+#define OMXR_CORE_LOG_LEVEL_ERROR	(OMXR_BASE_LOG_LEVEL_ERROR << OMXR_LOG_LEVEL_SHIFT_CORE)    /**< error log level for OMX Core */
+#define OMXR_CORE_LOG_LEVEL_WARN	(OMXR_BASE_LOG_LEVEL_WARN  << OMXR_LOG_LEVEL_SHIFT_CORE)    /**< warning log level for OMX Core */
+#define OMXR_CORE_LOG_LEVEL_INFO	(OMXR_BASE_LOG_LEVEL_INFO  << OMXR_LOG_LEVEL_SHIFT_CORE)    /**< information log level for OMX Core */
+#define OMXR_CORE_LOG_LEVEL_DEBUG	(OMXR_BASE_LOG_LEVEL_DEBUG << OMXR_LOG_LEVEL_SHIFT_CORE)    /**< debug log level for OMX Core */
+
+/* Log level for OMX Utility(os/system depend) module */
+#define OMXR_UTIL_LOG_LEVEL_ERROR	(OMXR_BASE_LOG_LEVEL_ERROR << OMXR_LOG_LEVEL_SHIFT_UTIL)    /**< error log level for OMX Utility */
+#define OMXR_UTIL_LOG_LEVEL_WARN	(OMXR_BASE_LOG_LEVEL_WARN  << OMXR_LOG_LEVEL_SHIFT_UTIL)    /**< warning log level for OMX Utility */
+#define OMXR_UTIL_LOG_LEVEL_INFO	(OMXR_BASE_LOG_LEVEL_INFO  << OMXR_LOG_LEVEL_SHIFT_UTIL)    /**< information log level for OMX Utility */
+#define OMXR_UTIL_LOG_LEVEL_DEBUG	(OMXR_BASE_LOG_LEVEL_DEBUG << OMXR_LOG_LEVEL_SHIFT_UTIL)    /**< debug log level for OMX Utility */
+
+/* Log level for OMX MC Common module */
+#define OMXR_CMN_LOG_LEVEL_ERROR	(OMXR_BASE_LOG_LEVEL_ERROR << OMXR_LOG_LEVEL_SHIFT_CMN)     /**< error log level for OMX MC Common */
+#define OMXR_CMN_LOG_LEVEL_WARN		(OMXR_BASE_LOG_LEVEL_WARN  << OMXR_LOG_LEVEL_SHIFT_CMN)     /**< warning log level for OMX MC Common */
+#define OMXR_CMN_LOG_LEVEL_INFO		(OMXR_BASE_LOG_LEVEL_INFO  << OMXR_LOG_LEVEL_SHIFT_CMN)     /**< information log level for OMX MC Common */
+#define OMXR_CMN_LOG_LEVEL_DEBUG	(OMXR_BASE_LOG_LEVEL_DEBUG << OMXR_LOG_LEVEL_SHIFT_CMN)     /**< debug log level for OMX MC Common */
+
+/* Log level for OMX MC Video module */
+#define OMXR_VIDEO_LOG_LEVEL_ERROR	(OMXR_BASE_LOG_LEVEL_ERROR << OMXR_LOG_LEVEL_SHIFT_VIDEO)   /**< error log level for OMX MC Video */
+#define OMXR_VIDEO_LOG_LEVEL_WARN	(OMXR_BASE_LOG_LEVEL_WARN  << OMXR_LOG_LEVEL_SHIFT_VIDEO)   /**< warning log level for OMX MC Video */
+#define OMXR_VIDEO_LOG_LEVEL_INFO	(OMXR_BASE_LOG_LEVEL_INFO  << OMXR_LOG_LEVEL_SHIFT_VIDEO)   /**< information log level for OMX MC Video */
+#define OMXR_VIDEO_LOG_LEVEL_DEBUG	(OMXR_BASE_LOG_LEVEL_DEBUG << OMXR_LOG_LEVEL_SHIFT_VIDEO)   /**< debug log level for OMX MC Video */
+
+/* Log level for OMX MC Audio module */
+#define OMXR_AUDIO_LOG_LEVEL_ERROR	(OMXR_BASE_LOG_LEVEL_ERROR << OMXR_LOG_LEVEL_SHIFT_AUDIO)   /**< error log level for OMX MC Audio */
+#define OMXR_AUDIO_LOG_LEVEL_WARN	(OMXR_BASE_LOG_LEVEL_WARN  << OMXR_LOG_LEVEL_SHIFT_AUDIO)   /**< warning log level for OMX MC Audio */
+#define OMXR_AUDIO_LOG_LEVEL_INFO	(OMXR_BASE_LOG_LEVEL_INFO  << OMXR_LOG_LEVEL_SHIFT_AUDIO)   /**< information log level for OMX MC Audio */
+#define OMXR_AUDIO_LOG_LEVEL_DEBUG	(OMXR_BASE_LOG_LEVEL_DEBUG << OMXR_LOG_LEVEL_SHIFT_AUDIO)   /**< debug log level for OMX MC Audio */
+
+/* Log level for OMX MC Video Converter module */
+#define OMXR_CNV_LOG_LEVEL_ERROR	(OMXR_BASE_LOG_LEVEL_ERROR << OMXR_LOG_LEVEL_SHIFT_CNV)     /**< error log level for OMX MC Video Converter */
+#define OMXR_CNV_LOG_LEVEL_WARN		(OMXR_BASE_LOG_LEVEL_WARN  << OMXR_LOG_LEVEL_SHIFT_CNV)     /**< warning log level for OMX MC Video Converter */
+#define OMXR_CNV_LOG_LEVEL_INFO		(OMXR_BASE_LOG_LEVEL_INFO  << OMXR_LOG_LEVEL_SHIFT_CNV)     /**< information log level for OMX MC Video Converter */
+#define OMXR_CNV_LOG_LEVEL_DEBUG	(OMXR_BASE_LOG_LEVEL_DEBUG << OMXR_LOG_LEVEL_SHIFT_CNV)     /**< debug log level for OMX MC Video Converter */
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+
+/***************************************************************************/
+/*    Function Prototypes                                                  */
+/***************************************************************************/
+/**
+ * Set log mode
+ *
+ * This function sets Log mode. It will change the display pattern of the log by the Log mode.
+ *
+ * \param[in]	u32LogMode	log mode.
+ * \return		OMX_ERRORTYPE
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMXR_SetLogMode(OMX_IN OMX_U32 u32LogMode);
+
+/**
+ * Get configuraion file name
+ *
+ * This function returns the configuration definition file name stored in OMX Core.
+ *
+ * \param[out]		cConfigName	Configuration file name
+ * \param[in,out]	*pu32Length	Buffer size / Length of configuration file name
+ * \return		OMX_ERRORTYPE
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMXR_GetConfiguration(OMX_OUT OMX_STRING cConfigName, OMX_U32* pu32Length);
+
+/**
+ * Set configuraion file name
+ *
+ * This function sets the configuration definition file name to OMX Core.
+ *
+ * \param[in]	cConfigName	Configuration file name
+ * \return		OMX_ERRORTYPE
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMXR_SetConfiguration(OMX_IN OMX_STRING cConfigName);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_H */
diff --git a/third_party/openmax/il/OMXR_Extension_audio.h b/third_party/openmax/il/OMXR_Extension_audio.h
new file mode 100644
index 0000000..7dc3ce1
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension_audio.h
@@ -0,0 +1,91 @@
+/**********************************************************************
+ *
+ * PURPOSE
+ *   Media Component Library Header File
+ *
+ * AUTHOR
+ *   Renesas Electronics Corporation
+ *
+ * DATE
+ *   2013/06/17
+ *
+ **********************************************************************/
+/*
+ * Copyright (C) Renesas Electronics Corporation 2013
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ *
+ **********************************************************************/
+
+#ifndef OMXR_EXTENSION_AUDIO_H
+#define OMXR_EXTENSION_AUDIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Header Files                                                 */
+/***************************************************************************/
+#include "OMXR_Extension.h"
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+/*******************/
+/* Extended Index. */
+/*******************/
+enum {
+    OMXR_MC_IndexParamAudioPortSettingMask           = (OMXR_MC_IndexVendorBaseAudio + 0x00000000),  /* OMX.RENESAS.INDEX.PARAM.AUDIO.PORTSETTINGSEVENTMASK */
+    OMXR_MC_IndexParamAudioOutputUnit                = (OMXR_MC_IndexVendorBaseAudio + 0x00000001)  /* OMX.RENESAS.INDEX.PARAM.AUDIO.OUTPUTUNIT */
+};
+
+#define OMXR_MC_AUDIO_EVENTMASK_SAMPLINGRATE   ((OMX_U32)0x00000001U)
+#define OMXR_MC_AUDIO_EVENTMASK_CHANNELS       ((OMX_U32)0x00000002U)
+#define OMXR_MC_AUDIO_EVENTMASK_CHANNELMAPPING ((OMX_U32)0x00000004U)
+
+/**************************/
+/* Extended Unit Type. */
+/**************************/
+typedef enum tagOMXR_MC_AUIDO_UNITTYPE {
+    OMXR_MC_AUDIO_UnitFrame      = 0x00,
+    OMXR_MC_AUDIO_UnitFull       = 0x01,
+    OMXR_MC_AUDIO_UnitPayload    = 0x02,
+    OMXR_MC_AUDIO_UintMax        = 0x7FFFFFFF
+} OMXR_MC_AUIDO_UNITTYPE;
+
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+/******************************/
+/* Extended Output Unit Type. */
+/******************************/
+typedef struct tagOMXR_MC_AUDIO_PARAM_OUTPUTUNITTYPE {
+    OMX_U32                 nSize;
+    OMX_VERSIONTYPE         nVersion;
+    OMX_U32                 nPortIndex;
+    OMXR_MC_AUIDO_UNITTYPE  eUnit;
+} OMXR_MC_AUDIO_PARAM_OUTPUTUNITTYPE;
+
+/*******************************************/
+/* Extended PortSettingChenges Event Mask. */
+/*******************************************/
+typedef struct tagOMXR_MC_AUDIO_PARAM_PORTSETTINGSEVENTMASKTYPE {
+    OMX_U32             nSize;
+    OMX_VERSIONTYPE     nVersion;
+    OMX_U32             nPortIndex;
+    OMX_U32             nMaskedBits;
+} OMXR_MC_AUDIO_PARAM_PORTSETTINGSEVENTMASKTYPE;
+
+/***************************************************************************/
+/* End of module                                                           */
+/***************************************************************************/
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_AUDIO_H */
diff --git a/third_party/openmax/il/OMXR_Extension_h264.h b/third_party/openmax/il/OMXR_Extension_h264.h
new file mode 100644
index 0000000..d353df8
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension_h264.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright(C) 2015-2017 Renesas Electronics Corporation. All Rights Reserved.
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ */
+/**
+ * OMXR Extension header for H.264 
+ * 
+ * This file contains vendor-defined extension definitions.
+ *
+ * \file OMXR_Extension_h264.h
+ * 
+ */
+
+#ifndef OMXR_EXTENSION_H264_H
+#define OMXR_EXTENSION_H264_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Files                                                        */
+/***************************************************************************/
+#include "OMXR_Extension_video.h"
+
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+#define OMXR_MC_VendorBaseOffsetH264     (0x000001000)		/**< base offset for H.264 (internal use) */
+
+#define OMXR_MC_IndexVendorBaseH264      (OMXR_MC_IndexVendorBaseVideo + OMXR_MC_VendorBaseOffsetH264)  /**< base value of extended OMX_INDEXTYPE for H.264  */
+#define OMXR_MC_EventVendorBaseH264      (OMXR_MC_EventVendorBaseVideo + OMXR_MC_VendorBaseOffsetH264)  /**< base value of extended OMX_EVENTTYPE for H.264  */
+#define OMXR_MC_ErrorVendorBaseH264      (OMXR_MC_ErrorVendorBaseVideo + OMXR_MC_VendorBaseOffsetH264)  /**< base value of extended OMX_ERRORTYPE for H.264  */
+
+/** 
+ * Enumeration of extended #OMX_VIDEO_AVCPROFILETYPE 
+ */
+enum {
+    OMXR_MC_VIDEO_AVCProfileMultiviewHigh = OMX_VIDEO_AVCProfileVendorStartUnused,	/**< Multiview profile            */
+    OMXR_MC_VIDEO_AVCProfileStereoHigh,												/**< Stereo High profile          */
+    OMXR_MC_VIDEO_AVCProfileConstrainedBaseline,									/**< Constrained baseline profile */
+    OMXR_MC_VIDEO_AVCProfileUnknown,												/**< unknown profile              */
+    OMXR_MC_VIDEO_AVCProfileNone,                                                   /**< no profile                   */
+    OMXR_MC_VIDEO_AVCProfileCustomizeStartUnused                                    /**< reserved to customize        */
+};
+
+/** 
+ * Enumeration of extended #OMX_VIDEO_AVCLEVELTYPE 
+ */
+enum {
+    OMXR_MC_VIDEO_AVCLevelUnknown = OMX_VIDEO_AVCLevelVendorStartUnused,			/**< unknown level         */
+    OMXR_MC_VIDEO_AVCLevelNone,                                             		/**< no level              */
+    OMXR_MC_VIDEO_AVCLevelCustomizeStartUnused                              		/**< reserved to customize */
+};
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+
+/***************************************************************************/
+/*    Function Prototypes                                                  */
+/***************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_H264_H */
diff --git a/third_party/openmax/il/OMXR_Extension_h264d.h b/third_party/openmax/il/OMXR_Extension_h264d.h
new file mode 100644
index 0000000..2cd7870
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension_h264d.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright(C) 2015-2017 Renesas Electronics Corporation. All Rights Reserved.
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ */
+
+/**
+ * OMXR Extension header for H.264 decoder 
+ * 
+ * This file contains vendor-defined extension definitions.
+ *
+ * \file OMXR_Extension_h264d.h
+ * 
+ */
+
+#ifndef OMXR_EXTENSION_H264D_H
+#define OMXR_EXTENSION_H264D_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Files                                                        */
+/***************************************************************************/
+#include "OMXR_Extension_vdcmn.h"
+#include "OMXR_Extension_h264.h"
+
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+#define OMXR_MC_IndexVendorBaseH264Decoder     (OMXR_MC_IndexVendorBaseVideoDecoder + OMXR_MC_VendorBaseOffsetH264)        /**< base value of extended OMX_INDEXTYPE for H.264 decoder  */
+#define OMXR_MC_EventVendorBaseH264Decoder     (OMXR_MC_EventVendorBaseVideoDecoder + OMXR_MC_VendorBaseOffsetH264)        /**< base value of extended OMX_EVENTTYPE for H.264 decoder  */
+#define OMXR_MC_ErrorVendorBaseH264Decoder     (OMXR_MC_ErrorVendorBaseVideoDecoder + OMXR_MC_VendorBaseOffsetH264)        /**< base value of extended OMX_ERRORTYPE for H.264 decoder  */
+
+#define OMXR_MC_SyntaxIndexBaseH264Decoder     (OMXR_MC_VideoSyntaxIndexBase + OMXR_MC_VendorBaseOffsetH264)
+
+#define OMXR_MC_VIDEO_NOEL_AVC_CONST     (6u)
+#define OMXR_MC_VIDEO_NOEL_AVC_NRF_POC   (255u)
+#define OMXR_MC_VIDEO_NOEL_AVC_HRD       (32u)
+
+/**
+ * extended #OMX_INDEXTYPE for H.264 decoder
+ */
+enum {
+    OMXR_MC_IndexParamVideoStreamStoreUnit = (OMXR_MC_IndexVendorBaseH264Decoder + 0x0000),   /**< stream store unit. parameter name:OMX.RENESAS.INDEX.PARAM.VIDEO.STREAM.STORE.UNIT */
+    OMXR_MC_IndexParamVideoAvcIgnoreLowDelayHint = (OMXR_MC_IndexVendorBaseH264Decoder + 0x0001)   /**< stream store unit. parameter name:OMX.RENESAS.INDEX.PARAM.VIDEO.IGNORE.LOW.DELAY.HINT */
+};
+
+enum {
+    OMXR_MC_IndexConfigVideoInfoAvcSyntax = (OMXR_MC_SyntaxIndexBaseH264Decoder + 0x0000)
+};
+
+/**
+ * stream store unit type
+ */
+typedef enum OMXR_MC_VIDEO_STOREUNITTYPE {
+    OMXR_MC_VIDEO_StoreUnitEofSeparated       = 0,            /**< EOF separated mode        */
+    OMXR_MC_VIDEO_StoreUnitTimestampSeparated = 1,            /**< time stamp separated mode */
+    OMXR_MC_VIDEO_StoreUnitEnd                = 0x7FFFFFFF    /**< definition end            */
+} OMXR_MC_VIDEO_STOREUNITTYPE;
+
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+/**
+ * Structure to Set/Get stream store unit type
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_STREAM_STORE_UNITTYPE {
+    OMX_U32                       nSize;             /**< Size of the structure in bytes   */
+    OMX_VERSIONTYPE               nVersion;          /**< OMX specification version info   */
+    OMX_U32                       nPortIndex;        /**< Port that this struct applies to */
+    OMXR_MC_VIDEO_STOREUNITTYPE   eStoreUnit;        /**< Stream store unit type           */
+} OMXR_MC_VIDEO_PARAM_STREAM_STORE_UNITTYPE;
+
+/**
+* Ignore low-delay hint type
+*
+* Ignore low-delay hint in input stream, and use this specified parameter instead.
+* This parameter works well  when input stream contains wrong low-delay hint information.
+*/
+typedef struct tagOMXR_MC_VIDEO_PARAM_IGNORE_LOW_DELAY_HINTTYPE {
+    OMX_U32           nSize;                /**< Size of the structure */
+    OMX_VERSIONTYPE   nVersion;             /**< OMX specification version info */
+    OMX_U32           nPortIndex;           /**< Target port index */
+    OMX_BOOL          bEnable;              /**< Default: False, Use max_num_reorder_frames in stream. OMX_TRUE: Ignore max_num_reorder_frames in stream .  */
+}OMXR_MC_VIDEO_PARAM_IGNORE_LOW_DELAY_HINTTYPE;
+
+/**
+* vui syntax information
+*/
+typedef struct tagOMXR_MC_VIDEO_INFO_AVC_VUI_SYNTAX {
+    OMX_U32    aspect_ratio_info_present_flag;
+    OMX_U32    aspect_ratio_idc;
+    OMX_U32    sar_width;
+    OMX_U32    sar_height;
+    OMX_U32    overscan_info_present_flag;
+    OMX_U32    overscan_appropriate_flag;
+    OMX_U32    video_signal_type_present_flag;
+    OMX_U32    video_format;
+    OMX_U32    video_full_range_flag;
+    OMX_U32    colour_description_present_flag;
+    OMX_U32    colour_primaries;
+    OMX_U32    transfer_characteristics;
+    OMX_U32    matrix_coefficients;
+    OMX_U32    chroma_loc_info_present_flag;
+    OMX_U32    chroma_sample_loc_type_top_field;
+    OMX_U32    chroma_sample_loc_type_bottom_field;
+    OMX_U32    timing_info_present_flag;
+    OMX_U32    num_units_in_tick;
+    OMX_U32    time_scale;
+    OMX_U32    fixed_frame_rate_flag;
+    OMX_U32    nal_hrd_parameters_present_flag;
+    OMX_U32    nal_hrd_cpb_cnt_minus1;
+    OMX_U32    nal_hrd_bit_rate_scale;
+    OMX_U32    nal_hrd_cpb_size_scale;
+    OMX_U32    nal_hrd_bit_rate_value_minus1[OMXR_MC_VIDEO_NOEL_AVC_HRD];
+    OMX_U32    nal_hrd_cpb_size_value_minus1[OMXR_MC_VIDEO_NOEL_AVC_HRD];
+    OMX_U32    nal_hrd_cbr_flag[OMXR_MC_VIDEO_NOEL_AVC_HRD];
+    OMX_U32    nal_hrd_initial_cpb_removal_delay_length_minus1;
+    OMX_U32    nal_hrd_cpb_removal_delay_length_minus1;
+    OMX_U32    nal_hrd_dpb_output_delay_length_minus1;
+    OMX_U32    nal_hrd_time_offset_length;
+    OMX_U32    vcl_hrd_parameters_present_flag;
+    OMX_U32    vcl_hrd_cpb_cnt_minus1;
+    OMX_U32    vcl_hrd_bit_rate_scale;
+    OMX_U32    vcl_hrd_cpb_size_scale;
+    OMX_U32    vcl_hrd_bit_rate_value_minus1[OMXR_MC_VIDEO_NOEL_AVC_HRD];
+    OMX_U32    vcl_hrd_cpb_size_value_minus1[OMXR_MC_VIDEO_NOEL_AVC_HRD];
+    OMX_U32    vcl_hrd_cbr_flag[OMXR_MC_VIDEO_NOEL_AVC_HRD];
+    OMX_U32    vcl_hrd_initial_cpb_removal_delay_length_minus1;
+    OMX_U32    vcl_hrd_cpb_removal_delay_length_minus1;
+    OMX_U32    vcl_hrd_dpb_output_delay_length_minus1;
+    OMX_U32    vcl_hrd_time_offset_length;
+    OMX_U32    low_delay_hrd_flag;
+    OMX_U32    pic_struct_present_flag;
+    OMX_U32    bitstream_restriction_flag;
+    OMX_U32    motion_vectors_over_pic_boundaries_flag;
+    OMX_U32    max_bytes_per_pic_denom;
+    OMX_U32    max_bits_per_mb_denom;
+    OMX_U32    log2_max_mv_length_horizontal;
+    OMX_U32    log2_max_mv_length_vertical;
+    OMX_U32    max_num_reorder_frames;
+    OMX_U32    max_dec_frame_buffering;
+} OMXR_MC_VIDEO_INFO_AVC_VUI_SYNTAXTYPE;
+
+/**
+* sps syntax information
+*/
+typedef struct tagOMXR_MC_VIDEO_INFO_AVC_SPS_SYNTAX {
+    OMX_U32    struct_size;
+    OMXR_MC_VIDEO_SYNTAX_STATUS    status;
+    OMX_U32    nal_ref_idc;
+    OMX_U32    nal_unit_type;
+    OMX_U32    profile_idc;
+    OMX_U32    constraint_setx_flag[OMXR_MC_VIDEO_NOEL_AVC_CONST];
+    OMX_U32    level_idc;
+    OMX_U32    seq_parameter_set_id;
+    OMX_U32    chroma_format_idc;
+    OMX_U32    log2_max_frame_num_minus4;
+    OMX_U32    pic_order_cnt_type;
+    OMX_U32    log2_max_pic_order_cnt_lsb_minus4;
+    OMX_U32    delta_pic_order_always_zero_flag;
+    OMX_S32    offset_for_non_ref_pic;
+    OMX_S32    offset_for_top_to_bottom_field;
+    OMX_U32    num_ref_frames_in_pic_order_cnt_cycle;
+    OMX_S32    offset_for_ref_frame[OMXR_MC_VIDEO_NOEL_AVC_NRF_POC];
+    OMX_U32    max_num_ref_frames;
+    OMX_U32    gaps_in_frame_num_value_allowed_flag;
+    OMX_U32    pic_width_in_mbs_minus1;
+    OMX_U32    pic_height_in_map_units_minus1;
+    OMX_U32    frame_mbs_only_flag;
+    OMX_U32    mb_adaptive_frame_field_flag;
+    OMX_U32    direct_8x8_inference_flag;
+    OMX_U32    frame_cropping_flag;
+    OMX_U32    frame_crop_left_offset;
+    OMX_U32    frame_crop_right_offset;
+    OMX_U32    frame_crop_top_offset;
+    OMX_U32    frame_crop_bottom_offset;
+    OMX_U32    vui_parameters_present_flag;
+    OMXR_MC_VIDEO_INFO_AVC_VUI_SYNTAXTYPE vui;
+    OMX_PTR    reserved;
+}OMXR_MC_VIDEO_INFO_AVC_SPS_SYNTAXTYPE;
+
+
+/***************************************************************************/
+/*    Function Prototypes                                                  */
+/***************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_H264D_H */
diff --git a/third_party/openmax/il/OMXR_Extension_h264e.h b/third_party/openmax/il/OMXR_Extension_h264e.h
new file mode 100644
index 0000000..39976f8
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension_h264e.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright(C) 2015-2017 Renesas Electronics Corporation. All Rights Reserved.
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ */
+/**
+ * OMXR Extension header for H.264 encoder 
+ * 
+ * This file contains vendor-defined extension definitions.
+ *
+ * \file OMXR_Extension_h264e.h
+ */
+#ifndef OMXR_EXTENSION_H264E_H
+#define OMXR_EXTENSION_H264E_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Files                                                        */
+/***************************************************************************/
+#include "OMXR_Extension_vecmn.h"
+#include "OMXR_Extension_h264.h"
+
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+#define OMXR_MC_IndexVendorBaseH264Encoder     (OMXR_MC_IndexVendorBaseVideoEncoder + OMXR_MC_VendorBaseOffsetH264)		/**< base value of extended OMX_INDEXTYPE for H.264 encoder  */
+#define OMXR_MC_EventVendorBaseH264Encoder     (OMXR_MC_EventVendorBaseVideoEncoder + OMXR_MC_VendorBaseOffsetH264)		/**< base value of extended OMX_EVENTTYPE for H.264 encoder  */
+#define OMXR_MC_ErrorVendorBaseH264Encoder     (OMXR_MC_ErrorVendorBaseVideoEncoder + OMXR_MC_VendorBaseOffsetH264)		/**< base value of extended OMX_ERRORTYPE for H.264 encoder  */
+
+/**
+ * extended #OMX_INDEXTYPE for H.264 encoder
+ */
+enum {
+    OMXR_MC_IndexParamVideoSequenceHeaderWithIDR     = (OMXR_MC_IndexVendorBaseH264Encoder + 0x0000),  /**< OMX.RENESAS.INDEX.PARAM.VIDEO.SEQUENCE.HEADER.WITH.IDR */
+    OMXR_MC_IndexParamVideoAVCSyntaxOption           = (OMXR_MC_IndexVendorBaseH264Encoder + 0x0001),  /**< OMX.RENESAS.INDEX.PARAM.VIDEO.AVC.SYNTAX.OPTION */
+    OMXR_MC_IndexParamVideoAVCVuiProperty            = (OMXR_MC_IndexVendorBaseH264Encoder + 0x0002)   /**< OMX.RENESAS.INDEX.PARAM.VIDEO.AVC.VUI.PROPERTY */
+};
+
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+/**
+ * Extended Sequence Header With IDR Type. 
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_SEQUENCE_HEADER_WITH_IDRTYPE{
+    OMX_U32             nSize;                  /**< size of the structure */
+    OMX_VERSIONTYPE     nVersion;               /**< OMX specification version info */
+    OMX_U32             nPortIndex;             /**< target port index */
+    OMX_BOOL            bSequenceHeaderWithIDR; /**< flag indicating the insertion of sequence header */
+} OMXR_MC_VIDEO_PARAM_SEQUENCE_HEADER_WITH_IDRTYPE;
+
+/**
+ * Extended AVC Syntax Option Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_AVC_SYNTAX_OPTION{
+    OMX_U32           nSize;            /**< size of the structure  */
+    OMX_VERSIONTYPE   nVersion;         /**< OMX specification version info */
+    OMX_U32           nPortIndex;       /**< target port index */
+    OMX_BOOL          bAUDEnable;       /**< flag indicating the insertion of AUD */
+    OMX_BOOL          bVUIEnable;       /**< flag indicating the insertion of VUI */
+    OMX_U32           u32PPSNum;        /**< flag indicating the number of insertion of PPS */
+} OMXR_MC_VIDEO_PARAM_AVC_SYNTAX_OPTION;
+
+/**
+* Extended AVC YUI Property Type.
+*/
+typedef struct tagOMXR_MC_VIDEO_PARAM_AVC_VUI_PROPERTY {
+    OMX_U32           nSize;                         /**< size of the structure  */
+    OMX_VERSIONTYPE   nVersion;                      /**< OMX specification version info */
+    OMX_U32           nPortIndex;                    /**< target port index */
+    OMX_BOOL          bAspectRatioInfoPresentFlag;   /**< aspect_ratio_info_present_flag */
+    OMX_U32           u32AspectRatioIdc;             /**< aspect_ratio_idc */
+    OMX_U32           u32SarWidth;                   /**< sar_width */
+    OMX_U32           u32SarHeight;                  /**< sar_height */
+    OMX_BOOL          bVideoSignalTypePresentFlag;   /**< video_signal_type_present_flag */
+    OMX_U32           u32VideoFormat;                /**< video_format */
+    OMX_BOOL          bVideoFullRangeFlag;           /**< video_full_range_flag */
+    OMX_BOOL          bColourDescriptionPresentFlag; /**< colour_description_present_flag */
+    OMX_U32           u32ColourPrimaries;            /**< colour_primaries */
+    OMX_U32           u32TransferCharacteristics;    /**< transfer_characteristics */
+    OMX_U32           u32MatrixCoefficients;         /**< matrix_coefficients */
+    OMX_BOOL          bTimingInfoPresentFlag;        /**< timing_info_present_flag */
+    OMX_U32           u32NumUnitsInTick;             /**< num_units_in_tick */
+    OMX_U32           u32TimeScale;                  /**< time_scale */
+    OMX_BOOL          bFixedFrameRateFlag;           /**< fixed_frame_rate_flag */
+} OMXR_MC_VIDEO_PARAM_AVC_VUI_PROPERTY;
+
+/***************************************************************************/
+/*    Function Prototypes                                                  */
+/***************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_H264E_H */
diff --git a/third_party/openmax/il/OMXR_Extension_vdcmn.h b/third_party/openmax/il/OMXR_Extension_vdcmn.h
new file mode 100644
index 0000000..1094b14
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension_vdcmn.h
@@ -0,0 +1,298 @@
+/*
+ * Copyright(C) 2015-2017 Renesas Electronics Corporation. All Rights Reserved.
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ */
+/**
+ * OMXR Extension header for video decoder common
+ * 
+ * This file contains vendor-defined extension definitions.
+ *
+ * \file OMXR_Extension_vdcmn.h
+ */
+
+#ifndef OMXR_EXTENSION_VDCMN_H
+#define OMXR_EXTENSION_VDCMN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Header Files                                                 */
+/***************************************************************************/
+#include "OMXR_Extension_video.h"
+
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+/* Flag indicating the cause of decoding error. */
+#define OMXR_MC_VIDEO_DECODE_ERROR_FLAG_CAUTION  0x00000001 /**< If this value is set in u32DecodeError, it indicates that it has detected a minor error that have no effects on output picture data. */
+#define OMXR_MC_VIDEO_DECODE_ERROR_FLAG_CONCEAL  0x00000002 /**< If this value is set in u32DecodeError, it indicates that it has detected a minor error that need error concealment. */
+
+#define OMXR_MC_VIDEO_PARAM_MAXIMUM_DECODE_CAPABILITY_MAXIMUM_LEVEL ( 0xFFFFFFFFu )    /**< The value of the maximum level for eMaxLevel */
+
+/**
+* Extended Work Buffer Preference.
+*/
+#define OMXR_MC_VIDEO_WORKBUFFER_PREFERENCE_BUFFER_SIZE_MIN (4096)
+#define OMXR_MC_VIDEO_WORKBUFFER_PREFERENCE_BUFFER_SIZE_FOR_2K (1572864)
+#define OMXR_MC_VIDEO_WORKBUFFER_PREFERENCE_BUFFER_SIZE_FOR_4K (6291456)
+#define OMXR_MC_VIDEO_WORKBUFFER_PREFERENCE_DEFAULT_NUM_BUFFERING_PIC (3)
+
+
+enum {
+    OMXR_MC_IndexParamVideoReorder                     = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0000),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.REORDER           */
+    OMXR_MC_IndexParamVideoDeinterlaceMode             = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0001),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.DEINITERLACEMODE  */
+    OMXR_MC_IndexParamVideoErrorConcealment            = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0002),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.ERROR.CONCEALMENT */
+    OMXR_MC_IndexParamVideoDynamicPortReconfInDecoding = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0003),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.DYNAMIC.PORTRECONF.INDECODING */
+    OMXR_MC_IndexParamVideoMaximumDecodeCapability     = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0004),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.MAXIMUM.DECODE.CAPABILITY */
+    OMXR_MC_IndexParamVideoWorkBufferPreference        = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0005),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.WORKBUFFERPREFERENCE */
+    OMXR_MC_IndexParamVideoBypassPostprocessing        = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0006),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.BYPASSPOSTPROCESSING */
+    OMXR_MC_IndexParamVideoLossyCompression            = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0007),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.LOSSY.COMPRESSION */
+    OMXR_MC_IndexConfigVideoSyntaxInfo                 = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0008),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.SYNTAXINFO */
+    OMXR_MC_IndexParamVideoTimeStampMode               = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x0009),  /* OMX.RENESAS.INDEX.PARAM.VIDEO.TIMESTAMPMODE */
+    OMXR_MC_IndexParamVideoEnableExtendedPSCEvent      = (OMXR_MC_IndexVendorBaseVideoDecoder + 0x000A)   /* OMX.RENESAS.INDEX.PARAM.VIDEO.ENABLEEXTENDEDPSCEVENT */
+};
+
+/**
+ * Extended Deinterlace Mode Type.
+ */
+typedef enum OMXR_MC_VIDEO_DEINTERLACE_MODETYPE {
+    OMXR_MC_VIDEO_DeinterlaceNone   = 0,            /**< Not applying IP */
+    OMXR_MC_VIDEO_Deinterlace2DHalf = 1,            /**< 2D IP Conversion with half rate output */
+    OMXR_MC_VIDEO_Deinterlace2DFull = 2,            /**< 2D IP Conversion with full rate output */
+    OMXR_MC_VIDEO_Deinterlace3DHalf = 3,            /**< 3D IP Conversion with half rate output */
+    OMXR_MC_VIDEO_Deinterlace3DFull = 4,            /**< 3D IP Conversion with full rate output */
+    OMXR_MC_VIDEO_DeinterlaceEnd    = 0x7FFFFFFF    /**< terminate values */
+} OMXR_MC_VIDEO_DEINTERLACE_MODETYPE;
+
+/**
+ * Extended TimeStamp Mode Type.
+ */
+typedef enum OMXR_MC_VIDEO_TIMESTAMPMODETYPE {
+    OMXR_MC_VIDEO_TimeStampModeDisplayOrder = 0,
+    OMXR_MC_VIDEO_TimeStampModeDecodeOrder  = 1,
+    OMXR_MC_VIDEO_TimeStampModeEnd          = 0x7FFFFFFF
+} OMXR_MC_VIDEO_TIMESTAMPMODETYPE;
+
+/**
+ * Display information of output picture 
+ */
+typedef enum OMXR_PICTURETYPE{
+    OMXR_MC_VIDEO_DispOrderProgressive     = 0,
+    OMXR_MC_VIDEO_DispOrderTopFieldFirst   = 1,
+    OMXR_MC_VIDEO_DispOrderBotFieldFirst   = 2,
+    OMXR_MC_VIDEO_DispOrderTopField        = 3,
+    OMXR_MC_VIDEO_DispOrderBotField        = 4,
+    OMXR_MC_VIDEO_DispOrderEnd             = 0x7FFFFFFF
+} OMXR_PICTURETYPE;
+
+/**
+ * Syntax status
+ */
+typedef enum {
+	OMXR_DEC_SYNTAX_STATUS_NONE      = 0x00,
+	OMXR_DEC_SYNTAX_STATUS_VALID     = 0x01,
+	OMXR_DEC_SYNTAX_STATUS_CAUTION   = 0x10,
+	OMXR_DEC_SYNTAX_STATUS_UNSUPPORT = 0x11,
+	OMXR_DEC_SYNTAX_STATUS_ERROR     = 0x02
+} OMXR_MC_VIDEO_SYNTAX_STATUS;
+
+/**
+ * Syntax index base
+ */
+enum {
+	OMXR_MC_VideoSyntaxIndexBase = 0x00000
+} ;
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+
+/**
+ * Extended Reorder Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_REORDERTYPE {
+    OMX_U32                       nSize;            /**< Size of the structure */
+    OMX_VERSIONTYPE               nVersion;         /**< OMX specification version info */
+    OMX_U32                       nPortIndex;       /**< Target port index */
+    OMX_BOOL                      bReorder;         /**< The reorder flags */
+} OMXR_MC_VIDEO_PARAM_REORDERTYPE;
+
+/**
+ * Extended Decode Result Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_EXTENDED_DECODERESULTTYPE {
+    OMX_U32          nSize;
+    OMX_PTR          pvVirtAddr[2][3];
+    OMX_U32          u32HwipAddr[2][3];
+    OMX_U32          u32HwipAncAddr[2][3];
+    OMXR_PICTURETYPE eDispOrder;
+    OMX_PTR          pvReserved;
+    OMX_PTR          pvReserved2;
+} OMXR_MC_VIDEO_EXTENDED_DECODERESULTTYPE;
+
+/**
+ * Decode Result Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_DECODERESULTTYPE {
+    OMX_U32 nSize;                                               /**< Size of the structure */
+    OMX_PTR pvPhysImageAddressY;                                 /**< Top physical address of dacoded picture data */
+    OMX_U32 u32PictWidth;                                        /**< The width of the decoded picture data */
+    OMX_U32 u32PictHeight;                                       /**< The height of the decoded picture data */
+    OMX_U32 u32DecodeError;                                      /**< The decoded error flags. */
+    OMX_U32 u32PhyAddr;                                          /**< This member is not used */
+    OMX_U32 u32Stride;                                           /**< This member is not used */
+    OMX_U32 u32Area;                                             /**< This member is not used */
+    OMXR_MC_VIDEO_EXTENDED_DECODERESULTTYPE sExtendDecodeResult; /**< Extended Decode Result information */
+    OMX_PTR pvReserved;                                          /**< This member is not used */
+} OMXR_MC_VIDEO_DECODERESULTTYPE;
+
+/**
+ * Extended Deinterlace Mode Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_DEINTERLACE_MODETYPE {
+    OMX_U32                    nSize;                        /**< Size of the structure */
+    OMX_VERSIONTYPE            nVersion;                     /**< OMX specification version info */
+    OMX_U32                    nPortIndex;                   /**< Target port index */
+    OMXR_MC_VIDEO_DEINTERLACE_MODETYPE    eDeinterlace;      /**< The de-interlace mode flags */
+    OMX_BOOL                   bDisableInterpolateTimeStamp; /**< Disable interpolate timestamp */
+    OMX_U32                    nTimeStampOffset;             /**< Offset of timestamp is used by OMXR_MC_VIDEO_Deinterlace2DFull or OMXR_MC_VIDEO_Deinterlace3DFull case */
+} OMXR_MC_VIDEO_PARAM_DEINTERLACE_MODETYPE;
+
+/**
+ * Extended Error Concealment Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_ERROR_CONCEALMENTTYPE {
+    OMX_U32            nSize;                               /**< Size of the structure */
+    OMX_VERSIONTYPE    nVersion;                            /**< OMX specification version info */
+    OMX_U32            nPortIndex;                          /**< Target port index */
+    OMX_BOOL           bSkipInterframe;                     /**< Skip output until first valid frame has input. :     default:OMX_FALSE */
+    OMX_BOOL           bSuppressErrorEventUntilValidFrame;  /**< Don't emit Error Event until first frame has input.: default:OMX_FALSE */
+} OMXR_MC_VIDEO_PARAM_ERROR_CONCEALMENTTYPE;
+
+/**
+ * Extended Dynamic Port Reconf In Decoding Type.
+ * - If the IL client has set the bEnable of "Dynamic Port Reconf in Decoding" index to TRUE, 
+ *   Media Component notifies the PortSettingChanged Event in accordance with the change of the output port information, 
+ *   and wait for the re-configuration of the port.
+ * - Please the IL client processes a sequence of "Dynamic Port Reconfiguration" prescribed in OpenMAX IL standard.
+ * - The output port information after the change will apply after PortDisable.
+ * - The target output port information is nFrameWidth, nFrameHeight, nStride, nSliceHeight.
+ *   nStride and nSliceHeight must not set it to 0 with this mode.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_DYNAMIC_PORT_RECONF_IN_DECODINGTYPE {
+    OMX_U32                       nSize;            /**< Size of the structure */
+    OMX_VERSIONTYPE               nVersion;         /**< OMX specification version info */
+    OMX_U32                       nPortIndex;       /**< Target port index */
+    OMX_BOOL                      bEnable;          /**< Enable dynamic port re-configuration in decoding : default:OMX_FALSE */
+} OMXR_MC_VIDEO_PARAM_DYNAMIC_PORT_RECONF_IN_DECODINGTYPE;
+
+/**
+ * Extended Muximum Decode Capability.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_MAXIMUM_DECODE_CAPABILITY {
+    OMX_U32         nSize;              /**< Size of the structure */
+    OMX_VERSIONTYPE nVersion;           /**< OMX specification version info */
+    OMX_U32         nPortIndex;         /**< Target port index */
+    OMX_U32         nMaxDecodedWidth;   /**< Max width : default:1920(Full HD) / Set range w | 80 <= w <= 1920 ( 4096 if support 4K resolution ) */
+    OMX_U32         nMaxDecodedHeight;  /**< Max height: default:1088(Full HD) / Set range h | 80 <= h <= 1920 ( 4096 if support 4K resolution ) */
+    OMX_U32         eMaxLevel;          /**< Max level : default:OMXR_MC_VIDEO_PARAM_MAXIMUM_DECODE_CAPABILITY_MAXIMUM_LEVEL */
+    OMX_BOOL        bForceEnable;       /**< If specified OMX_TRUE, ensure sufficient memory in order to decode with the given parameters.
+                                             Otherwise, there's possibility of the memory shortage if the image size is changed during decoding.
+
+                                              - The maximum value of OMX_VIDEO_PORTDEFINITIONTYPE.nSliceHeight is 1152 if all of the following conditions are satisfied:
+                                                - bForceEnable == OMX_TRUE
+                                                - OMXR_MC_VIDEO_PARAM_DEINTERLACE_MODETYPE.eDeinterlace == OMXR_MC_VIDEO_DeinterlaceNone,
+
+                                              - The memory arrangement format is described in below if all of the following conditions are satisfied:
+                                                - H264D
+                                                - bForceEnable == OMX_TRUE
+                                                - OMXR_MC_VIDEO_PARAM_DEINTERLACE_MODETYPE.eDeinterlace == OMXR_MC_VIDEO_DeinterlaceNone
+
+                                              The memory arrangement changes according to the OMX_VIDEO_PORTDEFINITIONTYPE.eColorformat, as shown in the figures below:
+
+                                              \image html YUV420_Planar_field.png "OMX_VIDEO_PORTDEFINITIONTYPE.eColorformat==OMX_COLOR_FormatYUV420Planar" 
+
+                                              \image html YUV420_SemiPlanar_field.png "OMX_VIDEO_PORTDEFINITIONTYPE.eColorformat==OMX_COLOR_FormatYUV420SemiPlanar"
+                                        */
+} OMXR_MC_VIDEO_PARAM_MAXIMUM_DECODE_CAPABILITYTYPE;
+
+/**
+ * Extended Work Buffer Preference.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_WORKBUFFER_PREFERENCE {
+    OMX_U32           nSize;
+    OMX_VERSIONTYPE   nVersion;
+    OMX_U32           nPortIndex;
+    OMX_U32           nInputWorkbufferNum;
+    OMX_U32           nInputWorkbufferSize;
+    OMX_U32           nBufferingPicNum;
+	OMX_U32           nDpbAdditionalNum;
+	OMX_BOOL          bDisable3DIPConversion;
+} OMXR_MC_VIDEO_PARAM_WORKBUFFER_PREFERENCETYPE;
+
+/**
+ * Extended Lossy compression mode type
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_LOSSY_COMPRESSION {
+    OMX_U32          nSize;
+    OMX_VERSIONTYPE  nVersion;
+    OMX_U32          nPortIndex;
+    OMX_BOOL         bEnable;
+} OMXR_MC_VIDEO_PARAM_LOSSY_COMPRESSIONTYPE;
+
+/**
+ * Extended Time Stamp Mode Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_TIME_STAMP_MODETYPE {
+    OMX_U32                                nSize;
+    OMX_VERSIONTYPE                        nVersion;
+    OMX_U32                                nPortIndex;
+    OMXR_MC_VIDEO_TIMESTAMPMODETYPE        eTimeStampMode;
+} OMXR_MC_VIDEO_PARAM_TIME_STAMP_MODETYPE;
+
+/**
+  * Extended PortSettingChanged Event Type.
+*/
+typedef struct tagOMXR_MC_VIDEO_PARAM_ENABLE_EXTENDED_PSC_EVENTTYPE {
+    OMX_U32                       nSize;            /**< Size of the structure */
+    OMX_VERSIONTYPE               nVersion;         /**< OMX specification version info */
+    OMX_U32                       nPortIndex;       /**< Target port index */
+    OMX_BOOL                      bEnable;          /**< Enable notification of Extended PSC event : default:OMX_FALSE */
+} OMXR_MC_VIDEO_PARAM_ENABLE_EXTENDED_PSC_EVENTTYPE;
+
+
+typedef struct tagOMXR_MC_VIDEO_PARAM_BYPASS_POSTPROCESSINGTYPE {
+    OMX_U32         nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32         nPortIndex;
+    OMX_BOOL        bEnable;
+    OMX_BOOL        bLosslessCompression;
+} OMXR_MC_VIDEO_PARAM_BYPASS_POSTPROCESSINGTYPE ;
+
+/**
+  * Extended SyntaxInfo Type.
+*/
+typedef struct tagOMXR_MC_VIDEO_CONFIG_SYNTAX_INFOTYPE {
+    OMX_U32           nSize;
+    OMX_VERSIONTYPE   nVersion;
+    OMX_U32           nPortIndex;
+    OMX_U32           u32SyntaxIndex;
+    OMX_PTR           pvSyntaxInfo;
+}OMXR_MC_VIDEO_CONFIG_SYNTAX_INFOTYPE;
+
+/***************************************************************************/
+/* End of module                                                           */
+/***************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_VDCMN_H */
diff --git a/third_party/openmax/il/OMXR_Extension_vecmn.h b/third_party/openmax/il/OMXR_Extension_vecmn.h
new file mode 100644
index 0000000..5cf00b6
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension_vecmn.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright(C) 2015-2017 Renesas Electronics Corporation. All Rights Reserved.
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ */
+/**
+ * OMXR Extension header for video encoder common
+ * 
+ * This file contains vendor-defined extension definitions.
+ *
+ * \file OMXR_Extension_vecmn.h
+ */
+
+#ifndef OMXR_EXTENSION_VECMN_H
+#define OMXR_EXTENSION_VECMN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Header Files                                                 */
+/***************************************************************************/
+#include "OMXR_Extension_video.h"
+
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+/**
+ * extended #OMX_INDEXTYPE for video encoder
+ */
+enum {
+    OMXR_MC_IndexParamVideoPictureMemoryAlloc               = (OMXR_MC_IndexVendorBaseVideoEncoder + 0x0000),   /**< OMX.RENESAS.INDEX.PARAM.VIDEO.PICTURE.MEMORY.ALLOC */
+    OMXR_MC_IndexParamVideoRatecontrolPreference            = (OMXR_MC_IndexVendorBaseVideoEncoder + 0x0001),   /**< OMX.RENESAS.INDEX.PARAM.VIDEO.RATECONTROL.PREFERENCE */
+    OMXR_MC_IndexParamVideoHierarchicalEncodingPreference   = (OMXR_MC_IndexVendorBaseVideoEncoder + 0x0002),   /**< OMX.RENESAS.INDEX.PARAM.VIDEO.HIERARCHICAL.ENCODING.PREFERENCE */
+    OMXR_MC_IndexParamVideoIntraRefresh                     = (OMXR_MC_IndexVendorBaseVideoEncoder + 0x0003)    /**< OMX.RENESAS.INDEX.PARAM.VIDEO.INTRA.REFRESH */
+};
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+/**
+ * Extended MemoryAlloc Mode.
+ */
+typedef enum OMXR_MC_VIDEO_MEMORYALLOCTYPE {
+	OMXR_MC_VIDEO_MemAllocFrame        = 0,         /**< frame structure */
+	OMXR_MC_VIDEO_MemAllocFrameTff     = 1,         /**< frame structure and top filed first */
+	OMXR_MC_VIDEO_MemAllocFrameBff     = 2,         /**< frame structure and bottom filed first */
+	OMXR_MC_VIDEO_MemAllocField        = 3,         /**< filed structure */
+	OMXR_MC_VIDEO_MemAllocFieldTff     = 4,         /**< filed structure and top filed first */
+	OMXR_MC_VIDEO_MemAllocFieldBff     = 5,         /**< filed structure and bottom filed first */
+	OMXR_MC_VIDEO_MemAllocFrameOrField = 6,         /**< frame or filed structure */
+	OMXR_MC_VIDEO_MemAllocEnd          = 0x7FFFFFFF /**< type end */
+} OMXR_MC_VIDEO_MEMORYALLOCTYPE;
+
+/**
+ * Extended MemoryAlloc Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_PICTURE_MEMORY_ALLOCTYPE {
+    OMX_U32                       nSize;            /**< size of the structure  */
+    OMX_VERSIONTYPE               nVersion;         /**< OMX specification version info */
+    OMX_U32                       nPortIndex;       /**< target port index */
+    OMXR_MC_VIDEO_MEMORYALLOCTYPE eMemoryAlloc;     /**< memory structure */
+    OMX_BOOL                      bIPConvert;       /**< (not support member) */
+    OMX_BOOL                      bTLConvert;       /**< (not support member) */
+} OMXR_MC_VIDEO_PARAM_PICTURE_MEMORY_ALLOCTYPE;
+
+/**
+ * Extended RatecontrolPreference Type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_RATECONTROL_PREFERENCETYPE {
+    OMX_U32         nSize;            /**< size of the structure  */
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version info */
+    OMX_U32         nPortIndex;       /**< target port index */
+    OMX_U32         nMinQpI;          /**< the minimum value of quantization for I picture. Supported range is relied on codec type. */
+    OMX_U32         nMinQpP;          /**< the minimum value of quantization for P picture. Supported range is relied on codec type. */
+    OMX_U32         nMinQpB;          /**< the minimum value of quantization for B picture. Supported range is relied on codec type. */
+    OMX_U32         nMaxQpI;          /**< the maximum value of quantization for I picture. Supported range is relied on codec type. */
+    OMX_U32         nMaxQpP;          /**< the maximum value of quantization for P picture. Supported range is relied on codec type. */
+    OMX_U32         nMaxQpB;          /**< the maximum value of quantization for B picture. Supported range is relied on codec type. */
+    OMX_U32         nMaxPicBitsI;     /**< Set the largest bit amount about target picture type. If this parameter was set 0 (default value), this library does not clip amount of bitstream by this value. The valid range of this value is 0, 200 to 40000000. */
+    OMX_U32         nMaxPicBitsP;     /**< Set the largest bit amount about target picture type. If this parameter was set 0 (default value), this library does not clip amount of bitstream by this value. The valid range of this value is 0, 200 to 40000000. */
+    OMX_U32         nMaxPicBitsB;     /**< Set the largest bit amount about target picture type. If this parameter was set 0 (default value), this library does not clip amount of bitstream by this value. The valid range of this value is 0, 200 to 40000000. */
+    OMX_U32         nMaxEsBytes;      /**< the maximum elementary stream size in bytes of a picture */
+} OMXR_MC_VIDEO_PARAM_RATECONTROL_PREFERENCETYPE;
+
+/**
+* Extended HierarchicalEncodingPreference Type.
+*/
+typedef struct tagOMXR_MC_VIDEO_PARAM_HIERARCHICAL_ENCODING_PREFERENCETYPE {
+	OMX_U32         nSize;             /**< size of the structure  */
+	OMX_VERSIONTYPE nVersion;          /**< OMX specification version info */
+	OMX_U32         nPortIndex;        /**< target port index */
+	OMX_U32         nLevel;            /**< Set the level of hierarchical encoding. 0: Non-hierarchical coding (default), 1: Hierarchical encoding level 1, 2: Hierarchical encoding level 2.  */
+	OMX_U32         nNumNonRefPFrames; /**< Set the number of non-reference P-frames for hierarchical encoding. 0: Non-hierarchical coding(default) */
+} OMXR_MC_VIDEO_PARAM_HIERARCHICAL_ENCODING_PREFERENCETYPE;
+
+/**
+ * Extended IntraRefresh type.
+ */
+typedef struct tagOMXR_MC_VIDEO_PARAM_INTRA_REFRESHTYPE {
+       OMX_U32         nSize;             /**< size of the structure  */
+       OMX_VERSIONTYPE nVersion;          /**< OMX specification version info */
+       OMX_U32         nPortIndex;        /**< target port index */
+       OMX_U32         nIntraRefreshCycle;/**< intra refresh cycle */
+} OMXR_MC_VIDEO_PARAM_INTRA_REFRESHTYPE;
+
+/***************************************************************************/
+/*    Function Prototypes                                                  */
+/***************************************************************************/
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_VECMN_H */
diff --git a/third_party/openmax/il/OMXR_Extension_video.h b/third_party/openmax/il/OMXR_Extension_video.h
new file mode 100644
index 0000000..6996d1d
--- /dev/null
+++ b/third_party/openmax/il/OMXR_Extension_video.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright(C) 2015-2017 Renesas Electronics Corporation. All Rights Reserved.
+ * RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
+ * This program must be used solely for the purpose for which
+ * it was furnished by Renesas Electronics Corporation.
+ * No part of this program may be reproduced or disclosed to
+ * others, in any form, without the prior written permission
+ * of Renesas Electronics Corporation.
+ */
+/**
+ * OMXR Extension header for video common
+ * 
+ * This file contains vendor-defined extension definitions.
+ *
+ * \file OMXR_Extension_video.h
+ */
+
+#ifndef OMXR_EXTENSION_VIDEO_H
+#define OMXR_EXTENSION_VIDEO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/***************************************************************************/
+/*    Include Files                                                        */
+/***************************************************************************/
+#include "OMXR_Extension.h"
+#include "OMX_VideoExt.h"
+#include "OMX_IndexExt.h"
+
+/***************************************************************************/
+/*    Macro Definitions                                                    */
+/***************************************************************************/
+/**
+ * Base offset of the vendor-defined extensions for video (OMX_INDEXTYPE)
+ */
+enum {
+    OMXR_MC_IndexVendorBaseVideoDecoder = OMXR_MC_IndexVendorBaseVideo + 0x00004000,    /**< Video decoder domain */
+    OMXR_MC_IndexVendorBaseVideoEncoder = OMXR_MC_IndexVendorBaseVideo + 0x00008000     /**< Video encoder domain */
+};
+
+/**
+ * Base offset of the vendor-defined extensions for video (OMX_EVENTTYPE)
+ */
+enum {
+    OMXR_MC_EventVendorBaseVideoDecoder = OMXR_MC_EventVendorBaseVideo + 0x00004000,    /**< Video decoder domain */
+    OMXR_MC_EventVendorBaseVideoEncoder = OMXR_MC_EventVendorBaseVideo + 0x00008000     /**< Video encoder domain */
+};
+
+/**
+ * Base offset of the vendor-defined extensions for video (OMX_ERRORTYPE)
+ */
+enum {
+    OMXR_MC_ErrorBaseVideoDecoder = OMXR_MC_ErrorBaseVideo + 0x00004000,                /**< Video decoder domain */
+    OMXR_MC_ErrorBaseVideoEncoder = OMXR_MC_ErrorBaseVideo + 0x00008000                 /**< Video encoder domain */
+};
+
+
+/**
+ * Enumeration defining possible uncompressed video formats
+ */
+enum {
+    OMX_COLOR_FormatYVU420Planar               = OMX_COLOR_FormatVendorStartUnused + 0x00000000,  /**< YVU Planar format */
+    OMX_COLOR_FormatYVU420SemiPlanar           = OMX_COLOR_FormatVendorStartUnused + 0x00000001,  /**< YVU Semi-Planar format */
+    OMX_COLOR_FormatYUV420PlanarMultiPlane     = OMX_COLOR_FormatVendorStartUnused + 0x00000002,
+    OMX_COLOR_FormatYUV420SemiPlanarMultiPlane = OMX_COLOR_FormatVendorStartUnused + 0x00000003
+};
+
+/***************************************************************************/
+/*    Type  Definitions                                                    */
+/***************************************************************************/
+
+/**
+* Extended physical image address Type.
+*/
+
+#define OMXR_EXTEND_ADDRESS_PLANE_NUM	3
+
+typedef struct tagOMXR_MC_VIDEO_EXTEND_ADDRESSTYPE {
+    OMX_U32    nSize;                                            /**< Size of the structure */
+	OMX_PTR    pvVirtAddr[OMXR_EXTEND_ADDRESS_PLANE_NUM];        /**< Top address of Virtual Address */
+	OMX_U32    u32HwipAddr[OMXR_EXTEND_ADDRESS_PLANE_NUM];       /**< Top address of HWIP Address */
+	OMX_U32    u32AllocateSize[OMXR_EXTEND_ADDRESS_PLANE_NUM];   /**< Allocate Size */
+} OMXR_MC_VIDEO_EXTEND_ADDRESSTYPE;
+
+
+/***************************************************************************/
+/*    Function Prototypes                                                  */
+/***************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMXR_EXTENSION_VIDEO_H */
diff --git a/third_party/openmax/il/OMX_Audio.h b/third_party/openmax/il/OMX_Audio.h
new file mode 100644
index 0000000..66d48af
--- /dev/null
+++ b/third_party/openmax/il/OMX_Audio.h
@@ -0,0 +1,1311 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Audio.h - OpenMax IL version 1.1.2
+ *  The structures needed by Audio components to exchange
+ *  parameters and configuration data with the componenmilts.
+ */
+
+#ifndef OMX_Audio_h
+#define OMX_Audio_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup midi MIDI
+ * @ingroup audio
+ */
+ 
+/** @defgroup effects Audio effects
+ * @ingroup audio
+ */
+
+/** @defgroup audio OpenMAX IL Audio Domain
+ * Structures for OpenMAX IL Audio domain
+ * @{
+ */
+
+/** Enumeration used to define the possible audio codings.  
+ *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must 
+ *  be done in a vendor specific way.  Since this is for an audio 
+ *  processing element this enum is relevant.  However, for another 
+ *  type of component other enums would be in this area.
+ */
+typedef enum OMX_AUDIO_CODINGTYPE {
+    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
+    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
+    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
+    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
+    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
+    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
+    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
+    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
+    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
+    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
+    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
+    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
+    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
+    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
+    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
+    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
+    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
+    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
+    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
+    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
+    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
+    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
+    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
+    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
+    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
+    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
+    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
+    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
+    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CodingMax = 0x7FFFFFFF
+} OMX_AUDIO_CODINGTYPE;
+
+
+/** The PortDefinition structure is used to define all of the parameters 
+ *  necessary for the compliant component to setup an input or an output audio 
+ *  path.  If additional information is needed to define the parameters of the
+ *  port (such as frequency), additional structures must be sent such as the
+ *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
+ */
+typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
+    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
+                                               for an output device, 
+                                               otherwise this field is 0 */
+    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is 
+                                          supported by the OMX component */
+    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this 
+                                          port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PORTDEFINITIONTYPE;
+
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nPortIndex;             /**< Indicates which port to set */
+    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PARAM_PORTFORMATTYPE;
+
+
+/** PCM mode type  */ 
+typedef enum OMX_AUDIO_PCMMODETYPE { 
+    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */ 
+    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */ 
+    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */ 
+    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF 
+} OMX_AUDIO_PCMMODETYPE; 
+
+
+typedef enum OMX_AUDIO_CHANNELTYPE {
+    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
+    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
+    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
+    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
+    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
+    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
+    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
+    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
+    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
+    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
+    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF 
+} OMX_AUDIO_CHANNELTYPE;
+
+#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
+#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
+
+/** PCM format description */ 
+typedef struct OMX_AUDIO_PARAM_PCMMODETYPE { 
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
+    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */ 
+    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */ 
+    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */ 
+    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for 
+                                           non-interleaved data (e.g. block data) */ 
+    OMX_U32 nBitPerSample;            /**< Bit per sample */ 
+    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for 
+                                           variable or unknown sampling rate. */ 
+    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */ 
+    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
+
+} OMX_AUDIO_PARAM_PCMMODETYPE; 
+
+
+/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
+ * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC. 
+ */
+typedef enum OMX_AUDIO_CHANNELMODETYPE {
+    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those 
+                                          two channels changes accordingly to each channel information */
+    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between 
+                                           2 channels for higher compression gain */
+    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half 
+                                           the bitrate of the overall bitrate */
+    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
+    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
+} OMX_AUDIO_CHANNELMODETYPE;
+
+
+typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
+    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MP3STREAMFORMATTYPE;
+
+/** MP3 params */
+typedef struct OMX_AUDIO_PARAM_MP3TYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
+} OMX_AUDIO_PARAM_MP3TYPE;
+
+
+typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
+    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
+    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
+    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
+    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
+    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
+    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
+    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
+    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_AACSTREAMFORMATTYPE;
+
+
+/** AAC mode type.  Note that the term profile is used with the MPEG-2
+ * standard and the term object type and profile is used with MPEG-4 */
+typedef enum OMX_AUDIO_AACPROFILETYPE{
+  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
+  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
+  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
+  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
+  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
+  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
+  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
+  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
+  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
+  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
+  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
+} OMX_AUDIO_AACPROFILETYPE;
+
+
+/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for encoder configuration and optional as decoder info output.
+ * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
+#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
+#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
+#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
+#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
+#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
+#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
+#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
+
+/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for ER encoder configuration and optional as decoder info output */
+#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
+#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
+#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
+#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
+#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
+
+
+/** AAC params */
+typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
+    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
+                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
+                                        Use 0 to let encoder decide */
+    OMX_U32 nAACtools;             /**< AAC tool usage */
+    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
+    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
+    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+} OMX_AUDIO_PARAM_AACPROFILETYPE;
+
+
+/** VORBIS params */
+typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
+                                   rate or unknown bit rates. Encoding is set to the
+                                   bitrate closest to specified  value (in bps) */
+    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
+    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
+
+    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
+                                   variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
+                                   limit the audio signal. Use 0 to let encoder decide */
+    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
+                                   In the default mode of operation, teh quality level is 3.
+                                   Normal quality range is 0 - 10. */
+    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
+                                   normal VBR encoding, but allows hard or soft bitrate
+                                   constraints to be enforced by the encoder. This mode can
+                                   be slower, and may also be lower quality. It is
+                                   primarily useful for streaming. */
+    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on 
+                                   non-stereo streams). Useful for lower-bitrate encoding. */     
+} OMX_AUDIO_PARAM_VORBISTYPE;
+
+
+/** WMA Version */
+typedef enum OMX_AUDIO_WMAFORMATTYPE {
+  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
+  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
+  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
+  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
+  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAFORMATTYPE;
+
+
+/** WMA Profile */
+typedef enum OMX_AUDIO_WMAPROFILETYPE {
+  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
+  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
+  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
+  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
+  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAPROFILETYPE;
+
+
+/** WMA params */
+typedef struct OMX_AUDIO_PARAM_WMATYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U16 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
+                                   rate or unknown bit rates */
+    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
+	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
+    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
+    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
+    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
+    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
+} OMX_AUDIO_PARAM_WMATYPE;
+
+/** 
+ * RealAudio format
+ */
+typedef enum OMX_AUDIO_RAFORMATTYPE {
+    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
+    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
+    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
+    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
+    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
+    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
+    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
+    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
+    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_RAFORMATTYPE;
+
+/** RA (Real Audio) params */ 
+typedef struct OMX_AUDIO_PARAM_RATYPE { 
+    OMX_U32 nSize;              /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels */ 
+    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */ 
+    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */ 
+    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */ 
+    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */ 
+    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */ 
+    OMX_U32 nNumRegions;        /**< is the number of regions value */ 
+    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
+} OMX_AUDIO_PARAM_RATYPE; 
+
+
+/** SBC Allocation Method Type */
+typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
+  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
+  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
+  OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
+} OMX_AUDIO_SBCALLOCMETHODTYPE;
+
+
+/** SBC params */
+typedef struct OMX_AUDIO_PARAM_SBCTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_U32 nChannels;         /**< Number of channels */
+    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
+                                    rate or unknown bit rates */
+    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+    OMX_U32 nBlocks;           /**< Number of blocks */
+    OMX_U32 nSubbands;         /**< Number of subbands */
+    OMX_U32 nBitPool;          /**< Bitpool value */
+    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
+    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
+} OMX_AUDIO_PARAM_SBCTYPE;
+
+
+/** ADPCM stream format parameters */ 
+typedef struct OMX_AUDIO_PARAM_ADPCMTYPE { 
+    OMX_U32 nSize;              /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
+                                     necessarily the same as the number of channels 
+                                     to be rendered. */ 
+    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */ 
+    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for 
+                                    variable or unknown sampling rate. */ 
+} OMX_AUDIO_PARAM_ADPCMTYPE; 
+
+
+/** G723 rate */
+typedef enum OMX_AUDIO_G723RATE {
+    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
+    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
+    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G723RATE;
+
+
+/** G723 - Sample rate must be 8 KHz */
+typedef struct OMX_AUDIO_PARAM_G723TYPE { 
+    OMX_U32 nSize;                /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */ 
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not 
+                                       necessarily the same as the number of channels 
+                                       to be rendered. */ 
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */ 
+    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */ 
+    OMX_BOOL bPostFilter;         /**< Enable Post Filter */ 
+} OMX_AUDIO_PARAM_G723TYPE; 
+
+
+/** ITU G726 (ADPCM) rate */
+typedef enum OMX_AUDIO_G726MODE {
+    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
+    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
+    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
+    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
+    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
+    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G726MODE;
+
+
+/** G.726 stream format parameters - must be at 8KHz */ 
+typedef struct OMX_AUDIO_PARAM_G726TYPE { 
+    OMX_U32 nSize;              /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
+                                     necessarily the same as the number of channels 
+                                     to be rendered. */ 
+     OMX_AUDIO_G726MODE eG726Mode;
+} OMX_AUDIO_PARAM_G726TYPE; 
+
+
+/** G729 coder type */
+typedef enum OMX_AUDIO_G729TYPE {
+    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
+    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
+    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
+    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
+    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G729Max = 0x7FFFFFFF
+} OMX_AUDIO_G729TYPE;
+
+
+/** G729 stream format parameters - fixed 6KHz sample rate */
+typedef struct OMX_AUDIO_PARAM_G729TYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
+                                   necessarily the same as the number of channels
+                                   to be rendered. */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_AUDIO_G729TYPE eBitType;
+} OMX_AUDIO_PARAM_G729TYPE;
+
+
+/** AMR Frame format */ 
+typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE { 
+    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance 
+                                                   (Standard) Format */ 
+    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface 
+                                                   Format 1 */ 
+    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface 
+                                                   Format 2*/ 
+    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage 
+                                                   Format */ 
+    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time 
+                                                   Transport Protocol Payload Format */ 
+    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */ 
+    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF 
+} OMX_AUDIO_AMRFRAMEFORMATTYPE; 
+
+
+/** AMR band mode */
+typedef enum OMX_AUDIO_AMRBANDMODETYPE {
+    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
+    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
+    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */ 
+    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
+    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
+    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
+    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
+    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
+    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
+    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
+    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */ 
+    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */ 
+    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
+    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
+    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
+    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
+    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */      
+    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRBANDMODETYPE;
+     
+
+/** AMR Discontinuous Transmission mode */ 
+typedef enum OMX_AUDIO_AMRDTXMODETYPE { 
+    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */ 
+    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using 
+                                             Voice Activity Detector 1 (VAD1) is enabled */ 
+    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using 
+                                             Voice Activity Detector 2 (VAD2) is enabled */       
+    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between 
+                                             Off, VAD1 or VAD2 modes */ 
+
+    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
+
+    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF 
+} OMX_AUDIO_AMRDTXMODETYPE; 
+ 
+
+/** AMR params */
+typedef struct OMX_AUDIO_PARAM_AMRTYPE {
+    OMX_U32 nSize;                          /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
+    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
+    OMX_U32 nChannels;                      /**< Number of channels */
+    OMX_U32 nBitRate;                       /**< Bit rate read only field */
+    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */ 
+    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
+    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
+} OMX_AUDIO_PARAM_AMRTYPE;
+
+
+/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMFRTYPE;
+
+
+/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMHRTYPE;
+
+
+/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMEFRTYPE;
+
+
+/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAFRTYPE;
+
+
+/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAEFRTYPE;
+
+
+/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCFRTYPE;
+
+
+/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCEFRTYPE;
+
+/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCHRTYPE;
+
+
+/** CDMA Rate types */
+typedef enum OMX_AUDIO_CDMARATETYPE {
+    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
+    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
+    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
+    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
+    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
+    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
+    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
+} OMX_AUDIO_CDMARATETYPE;
+
+
+/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
+                                       rate or unknown bit rates */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP8TYPE;
+
+
+/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP13TYPE;
+
+
+/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
+    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
+} OMX_AUDIO_PARAM_EVRCTYPE;
+
+
+/** SMV ( up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_SMVTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
+} OMX_AUDIO_PARAM_SMVTYPE;
+
+
+/** MIDI Format 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIFORMATTYPE
+{
+    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
+    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
+    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
+    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
+    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
+    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
+    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
+    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
+    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIFORMATTYPE;
+
+
+/** MIDI params 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDITYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire 
+                                        MIDI file passed in, otherwise if 0x0, the MIDI data 
+                                        is merged and streamed (instead of passed as an 
+                                        entire MIDI file) */
+    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
+                                        voices. A value of zero indicates that the default 
+                                        polyphony of the device is used  */                                    
+    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound 
+                                        bank at initialization */
+    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */                                                                           
+} OMX_AUDIO_PARAM_MIDITYPE;
+
+
+/** Type of the MIDI sound bank 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
+    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
+    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
+    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
+    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
+    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
+    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKTYPE;
+
+
+/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
+   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
+   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
+   OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
+
+
+/** MIDI params to load/unload user soundbank 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
+    OMX_U32 nDLSSize;         /**< Size in bytes */
+    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
+    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
+    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
+} OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
+
+
+/** Structure for Live MIDI events and MIP messages. 
+ * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.) 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
+    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
+                                   array for the MIP message buffer, where the size is 
+                                   indicated by nMidiEventSize */
+} OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
+
+
+/** MIDI sound bank/ program pair in a given channel 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
+    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
+    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
+    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks 
+                                     by index if multiple banks are present */
+} OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
+
+
+/** MIDI control 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10 
+                                       format based on JAVA MMAPI (JSR-135) requirement */
+    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
+                                       number based on JSR-135 requirement */
+    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10 
+                                       fixed-point number based on JSR-135 requirement */
+    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
+                                       voices. A value of zero indicates that the default 
+                                       polyphony of the device is used  */
+    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
+    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback 
+                                       will stop automatically.  Set to zero if not used */
+    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
+    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
+    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
+    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
+
+} OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
+
+
+/** MIDI Playback States 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
+  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to 
+  													other defined states */
+  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open. 
+                                                    The MIDI engine is currently processing 
+                                                    MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being 
+                                                    primed. The MIDI engine is currently 
+                                                    processing MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but 
+                                                    not playing. The MIDI engine is currently
+                                                    processing MIDI events. The transition to
+                                                    this state is only possible from the 
+                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
+                                                    when the 'playback head' reaches the end
+                                                    of media data or the playback stops due
+                                                    to stop time set.*/
+  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
+                                                    playing. The MIDI engine is currently
+                                                    processing MIDI events.*/
+  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
+                                                    resource constraints */
+  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
+                                                    SP-MIDI content constraints, there is
+                                                    no audible MIDI content during playback
+                                                    currently. The situation may change if
+                                                    resources are freed later.*/
+  OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
+
+
+/** MIDI status 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field. 
+                                     NOTE: May not return a meaningful value until the entire 
+                                     file is parsed and buffered.  */
+    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource 
+                                     in milliseconds. NOTE: May not return a meaningful value 
+                                     until the entire file is parsed and buffered.  */  
+    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played 
+                                     in milliseconds */
+    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful 
+                                     value until the entire file is parsed and buffered. */
+    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently 
+                                     open MIDI resource. NOTE: May not return a meaningful value 
+                                     until the entire file is parsed and buffered.  */
+    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing 
+                                     MIDI resource. NOTE: May not return a meaningful value until 
+                                     the entire file is parsed and buffered. */
+    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
+} OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
+
+
+/** MIDI Meta Event structure one per Meta Event.
+ *  MIDI Meta Events are like audio metadata, except that they are interspersed 
+ *  with the MIDI content throughout the file and are not localized in the header. 
+ *  As such, it is necessary to retrieve information about these Meta Events from 
+ *  the engine, as it encounters these Meta Events within the MIDI content. 
+ *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright, 
+ *  author, default tempo, etc.) scattered throughout the file. 
+ *  @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{ 
+    OMX_U32 nSize;            /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
+    OMX_U32 nIndex;           /**< Index of Meta Event */ 
+    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */ 
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
+    OMX_U32 nTrack;           /**< track number for the meta event */
+    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
+} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE; 
+
+
+/** MIDI Meta Event Data structure - one per Meta Event. 
+ * @ingroup midi
+ */ 
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{ 
+    OMX_U32 nSize;            /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
+    OMX_U32 nIndex;           /**< Index of Meta Event */ 
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
+    OMX_U8 nData[1];          /**< array of one or more bytes of meta data 
+                                   as indicated by the nMetaEventSize field */ 
+} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE; 
+
+
+/** Audio Volume adjustment for a port */
+typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's volume.  Select the 
+                                     output port to adjust the master 
+                                     volume. */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) 
+                                     or logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  The values
+                                     for volume are in mB (millibels = 1/100 dB) relative
+                                     to a gain of 1 (e.g. the output is the same as the 
+                                     input level).  Values are in mB from nMax 
+                                     (maximum volume) to nMin mB (typically negative).
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the 
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+} OMX_AUDIO_CONFIG_VOLUMETYPE;
+
+
+/** Audio Volume adjustment for a channel */
+typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's volume.  Select the 
+                                     output port to adjust the master 
+                                     volume. */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+                                     using OMX_ALL to apply volume settings
+                                     to all channels */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or 
+                                     logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  
+                                     The values for volume are in mB 
+                                     (millibels = 1/100 dB) relative to a gain
+                                     of 1 (e.g. the output is the same as the 
+                                     input level).  Values are in mB from nMax 
+                                     (maximum volume) to nMin mB (typically negative).  
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the 
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */
+} OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
+
+
+/** Audio balance setting */
+typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's balance.  Select the 
+                                     output port to adjust the master 
+                                     balance. */
+    OMX_S32 nBalance;           /**< balance setting for this port 
+                                     (-100 to 100, where -100 indicates
+                                     all left, and no right */
+} OMX_AUDIO_CONFIG_BALANCETYPE;
+
+
+/** Audio Port mute */
+typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's mute.  Select the 
+                                     output port to adjust the master 
+                                     mute. */
+    OMX_BOOL bMute;             /**< Mute setting for this port */
+} OMX_AUDIO_CONFIG_MUTETYPE;
+
+
+/** Audio Channel mute */
+typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+                                     using OMX_ALL to apply mute settings
+                                     to all channels */
+    OMX_BOOL bMute;             /**< Mute setting for this channel */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */ 
+} OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
+
+
+
+/** Enable / Disable for loudness control, which boosts bass and to a 
+ *  smaller extent high end frequencies to compensate for hearing
+ *  ability at the extreme ends of the audio spectrum
+ */ 
+typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
+} OMX_AUDIO_CONFIG_LOUDNESSTYPE;
+
+
+/** Enable / Disable for bass, which controls low frequencies
+ */ 
+typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
+    OMX_S32 nBass;             /**< bass setting for the port, as a 
+                                    continuous value from -100 to 100  
+                                    (0 means no change in bass level)*/
+} OMX_AUDIO_CONFIG_BASSTYPE;
+
+
+/** Enable / Disable for treble, which controls high frequencies tones
+ */ 
+typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
+    OMX_S32  nTreble;          /**< treble setting for the port, as a
+                                    continuous value from -100 to 100  
+                                    (0 means no change in treble level) */
+} OMX_AUDIO_CONFIG_TREBLETYPE;
+
+
+/** An equalizer is typically used for two reasons: to compensate for an 
+ *  sub-optimal frequency response of a system to make it sound more natural 
+ *  or to create intentionally some unnatural coloring to the sound to create
+ *  an effect.
+ *  @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
+    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is 
+                                    N-1, where N is the number of bands, lower limit is 0 */
+    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
+                                    read only element and is used to determine 
+                                    the lower, center and upper frequency of 
+                                    this band.  */
+    OMX_BS32 sBandLevel;       /**< band level in millibels */
+} OMX_AUDIO_CONFIG_EQUALIZERTYPE;
+
+
+/** Stereo widening mode type 
+ * @ingroup effects
+ */ 
+typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
+    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
+    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
+    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
+} OMX_AUDIO_STEREOWIDENINGTYPE;
+
+
+/** Control for stereo widening, which is a special 2-channel
+ *  case of the audio virtualizer effect. For example, for 5.1-channel 
+ *  output, it translates to virtual surround sound. 
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
+    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
+    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
+                                    as a continuous value from 0 to 100  */
+} OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
+
+
+/** The chorus effect (or ``choralizer'') is any signal processor which makes
+ *  one sound source (such as a voice) sound like many such sources singing 
+ *  (or playing) in unison. Since performance in unison is never exact, chorus 
+ *  effects simulate this by making independently modified copies of the input 
+ *  signal. Modifications may include (1) delay, (2) frequency shift, and 
+ *  (3) amplitude modulation.
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
+    OMX_BU32 sDelay;           /**< average delay in milliseconds */
+    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
+    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of 
+                                    delay (i.e. 0 to 100) */
+    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
+} OMX_AUDIO_CONFIG_CHORUSTYPE;
+
+
+/** Reverberation is part of the reflected sound that follows the early 
+ *  reflections. In a typical room, this consists of a dense succession of 
+ *  echoes whose energy decays exponentially. The reverberation effect structure 
+ *  as defined here includes both (early) reflections as well as (late) reverberations. 
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
+    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect 
+                                       (i.e. both early reflections and late 
+                                       reverberation) in millibels */
+    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
+                                       relative to the intensity at low
+                                       frequencies in millibels */
+    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
+                                       (relative to room value), in millibels */
+    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative 
+                                       to the direct path, in milliseconds */
+    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
+                                       relative to room level, in millibels */
+    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection 
+                                       to the beginning of the late reverberation 
+                                       section, in milliseconds */
+    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
+                                       frequencies, in milliseconds */
+    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative 
+                                       to low frequency decay time in percent  */
+    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is 
+                                       the frequency used as the reference for all 
+                                       the high-frequency settings above */
+
+} OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
+
+
+/** Possible settings for the Echo Cancelation structure to use 
+ * @ingroup effects
+ */
+typedef enum OMX_AUDIO_ECHOCANTYPE {
+   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
+   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation - 
+                                     echo from plastics and face */
+   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for 
+                                     Hands Free operation */
+   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for 
+                                     Car Kit (longer echo) */
+   OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
+} OMX_AUDIO_ECHOCANTYPE;
+
+
+/** Enable / Disable for echo cancelation, which removes undesired echo's
+ *  from the audio
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
+} OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
+
+
+/** Enable / Disable for noise reduction, which undesired noise from
+ * the audio
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
+} OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/third_party/openmax/il/OMX_Component.h b/third_party/openmax/il/OMX_Component.h
new file mode 100644
index 0000000..63e51cb
--- /dev/null
+++ b/third_party/openmax/il/OMX_Component.h
@@ -0,0 +1,579 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Component.h - OpenMax IL version 1.1.2
+ *  The OMX_Component header file contains the definitions used to define
+ *  the public interface of a component.  This header file is intended to
+ *  be used by both the application and the component.
+ */
+
+#ifndef OMX_Component_h
+#define OMX_Component_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Audio.h>
+#include <OMX_Video.h>
+#include <OMX_Image.h>
+#include <OMX_Other.h>
+
+/** @ingroup comp */
+typedef enum OMX_PORTDOMAINTYPE { 
+    OMX_PortDomainAudio, 
+    OMX_PortDomainVideo, 
+    OMX_PortDomainImage, 
+    OMX_PortDomainOther,
+    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_PortDomainMax = 0x7ffffff
+} OMX_PORTDOMAINTYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
+    OMX_U32 nSize;                 /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< Port number the structure applies to */
+    OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
+    OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
+    OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
+    OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
+    OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
+                                        OMX_CommandPortEnable/OMX_CommandPortDisable.
+                                        When disabled a port is unpopulated. A disabled port
+                                        is not populated with buffers on a transition to IDLE. */
+    OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
+                                        nBufferCountActual. A disabled port is always unpopulated. 
+                                        An enabled port is populated on a transition to OMX_StateIdle
+                                        and unpopulated on a transition to loaded. */
+    OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
+    union {
+        OMX_AUDIO_PORTDEFINITIONTYPE audio;
+        OMX_VIDEO_PORTDEFINITIONTYPE video;
+        OMX_IMAGE_PORTDEFINITIONTYPE image;
+        OMX_OTHER_PORTDEFINITIONTYPE other;
+    } format;
+    OMX_BOOL bBuffersContiguous;
+    OMX_U32 nBufferAlignment;
+} OMX_PARAM_PORTDEFINITIONTYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_U32TYPE { 
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
+    OMX_U32 nU32;                     /**< U32 value */
+} OMX_PARAM_U32TYPE;
+
+/** @ingroup rpm */
+typedef enum OMX_SUSPENSIONPOLICYTYPE {
+    OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
+    OMX_SuspensionEnabled,  /**< Suspension allowed */   
+    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_SuspensionPolicyMax = 0x7fffffff
+} OMX_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
+    OMX_U32 nSize;                  
+    OMX_VERSIONTYPE nVersion;        
+    OMX_SUSPENSIONPOLICYTYPE ePolicy;
+} OMX_PARAM_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef enum OMX_SUSPENSIONTYPE {
+    OMX_NotSuspended, /**< component is not suspended */
+    OMX_Suspended,    /**< component is suspended */
+    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_SuspendMax = 0x7FFFFFFF
+} OMX_SUSPENSIONTYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_PARAM_SUSPENSIONTYPE {
+    OMX_U32 nSize;                  
+    OMX_VERSIONTYPE nVersion;       
+    OMX_SUSPENSIONTYPE eType;             
+} OMX_PARAM_SUSPENSIONTYPE ;
+
+typedef struct OMX_CONFIG_BOOLEANTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bEnabled;    
+} OMX_CONFIG_BOOLEANTYPE;
+
+/* Parameter specifying the content uri to use. */
+/** @ingroup cp */
+typedef struct OMX_PARAM_CONTENTURITYPE
+{
+    OMX_U32 nSize;                      /**< size of the structure in bytes, including
+                                             actual URI name */
+    OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
+    OMX_U8 contentURI[1];               /**< The URI name */
+} OMX_PARAM_CONTENTURITYPE;
+
+/* Parameter specifying the pipe to use. */
+/** @ingroup cp */
+typedef struct OMX_PARAM_CONTENTPIPETYPE
+{
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
+} OMX_PARAM_CONTENTPIPETYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_RESOURCECONCEALMENTTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment 
+                                            methods (like degrading algorithm quality to 
+                                            lower resource consumption or functional bypass) 
+                                            on a component as a resolution to resource conflicts. */
+} OMX_RESOURCECONCEALMENTTYPE;
+
+
+/** @ingroup metadata */
+typedef enum OMX_METADATACHARSETTYPE {
+    OMX_MetadataCharsetUnknown = 0,
+    OMX_MetadataCharsetASCII,
+    OMX_MetadataCharsetBinary,
+    OMX_MetadataCharsetCodePage1252,
+    OMX_MetadataCharsetUTF8,
+    OMX_MetadataCharsetJavaConformantUTF8,
+    OMX_MetadataCharsetUTF7,
+    OMX_MetadataCharsetImapUTF7,
+    OMX_MetadataCharsetUTF16LE, 
+    OMX_MetadataCharsetUTF16BE,
+    OMX_MetadataCharsetGB12345,
+    OMX_MetadataCharsetHZGB2312,
+    OMX_MetadataCharsetGB2312,
+    OMX_MetadataCharsetGB18030,
+    OMX_MetadataCharsetGBK,
+    OMX_MetadataCharsetBig5,
+    OMX_MetadataCharsetISO88591,
+    OMX_MetadataCharsetISO88592,
+    OMX_MetadataCharsetISO88593,
+    OMX_MetadataCharsetISO88594,
+    OMX_MetadataCharsetISO88595,
+    OMX_MetadataCharsetISO88596,
+    OMX_MetadataCharsetISO88597,
+    OMX_MetadataCharsetISO88598,
+    OMX_MetadataCharsetISO88599,
+    OMX_MetadataCharsetISO885910,
+    OMX_MetadataCharsetISO885913,
+    OMX_MetadataCharsetISO885914,
+    OMX_MetadataCharsetISO885915,
+    OMX_MetadataCharsetShiftJIS,
+    OMX_MetadataCharsetISO2022JP,
+    OMX_MetadataCharsetISO2022JP1,
+    OMX_MetadataCharsetISOEUCJP,
+    OMX_MetadataCharsetSMS7Bit,
+    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
+} OMX_METADATACHARSETTYPE;
+
+/** @ingroup metadata */
+typedef enum OMX_METADATASCOPETYPE
+{
+    OMX_MetadataScopeAllLevels,
+    OMX_MetadataScopeTopLevel,
+    OMX_MetadataScopePortLevel,
+    OMX_MetadataScopeNodeLevel,
+    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataScopeTypeMax = 0x7fffffff
+} OMX_METADATASCOPETYPE;
+
+/** @ingroup metadata */
+typedef enum OMX_METADATASEARCHMODETYPE
+{
+    OMX_MetadataSearchValueSizeByIndex,
+    OMX_MetadataSearchItemByIndex,
+    OMX_MetadataSearchNextItemByKey,
+    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataSearchTypeMax = 0x7fffffff
+} OMX_METADATASEARCHMODETYPE;
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_METADATASCOPETYPE eScopeMode;
+    OMX_U32 nScopeSpecifier;
+    OMX_U32 nMetadataItemCount;
+} OMX_CONFIG_METADATAITEMCOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_METADATAITEMTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_METADATASCOPETYPE eScopeMode;
+    OMX_U32 nScopeSpecifier;
+    OMX_U32 nMetadataItemIndex;  
+    OMX_METADATASEARCHMODETYPE eSearchMode;
+    OMX_METADATACHARSETTYPE eKeyCharset;
+    OMX_U8 nKeySizeUsed;
+    OMX_U8 nKey[128];
+    OMX_METADATACHARSETTYPE eValueCharset;
+    OMX_STRING sLanguageCountry;
+    OMX_U32 nValueMaxSize;
+    OMX_U32 nValueSizeUsed;
+    OMX_U8 nValue[1];
+} OMX_CONFIG_METADATAITEMTYPE;
+
+/* @ingroup metadata */
+typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;
+    OMX_U32 nParentNodeID;
+    OMX_U32 nNumNodes;
+} OMX_CONFIG_CONTAINERNODECOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;
+    OMX_U32 nParentNodeID;
+    OMX_U32 nNodeIndex; 
+    OMX_U32 nNodeID; 
+    OMX_STRING cNodeName;
+    OMX_BOOL bIsLeafType;
+} OMX_CONFIG_CONTAINERNODEIDTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_PARAM_METADATAFILTERTYPE 
+{ 
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and 
+                         * the three key fields below are ignored */
+    OMX_METADATACHARSETTYPE eKeyCharset;
+    OMX_U32 nKeySizeUsed; 
+    OMX_U8   nKey [128]; 
+    OMX_U32 nLanguageCountrySizeUsed;
+    OMX_U8 nLanguageCountry[128];
+    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g. 
+                         * retained for query later). If false then
+                         * key is not part of filter */
+} OMX_PARAM_METADATAFILTERTYPE; 
+
+/** The OMX_HANDLETYPE structure defines the component handle.  The component 
+ *  handle is used to access all of the component's public methods and also
+ *  contains pointers to the component's private data area.  The component
+ *  handle is initialized by the OMX core (with help from the component)
+ *  during the process of loading the component.  After the component is
+ *  successfully loaded, the application can safely access any of the
+ *  component's public functions (although some may return an error because
+ *  the state is inappropriate for the access).
+ * 
+ *  @ingroup comp
+ */
+typedef struct OMX_COMPONENTTYPE
+{
+    /** The size of this structure, in bytes.  It is the responsibility
+        of the allocator of this structure to fill in this value.  Since
+        this structure is allocated by the GetHandle function, this
+        function will fill in this value. */
+    OMX_U32 nSize;
+
+    /** nVersion is the version of the OMX specification that the structure 
+        is built against.  It is the responsibility of the creator of this 
+        structure to initialize this value and every user of this structure 
+        should verify that it knows how to use the exact version of 
+        this structure found herein. */
+    OMX_VERSIONTYPE nVersion;
+
+    /** pComponentPrivate is a pointer to the component private data area.  
+        This member is allocated and initialized by the component when the 
+        component is first loaded.  The application should not access this 
+        data area. */
+    OMX_PTR pComponentPrivate;
+
+    /** pApplicationPrivate is a pointer that is a parameter to the 
+        OMX_GetHandle method, and contains an application private value 
+        provided by the IL client.  This application private data is 
+        returned to the IL Client by OMX in all callbacks */
+    OMX_PTR pApplicationPrivate;
+
+    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL 
+        specification for details on the GetComponentVersion method.
+     */
+    OMX_ERRORTYPE (*GetComponentVersion)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STRING pComponentName,
+            OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
+            OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
+            OMX_OUT OMX_UUIDTYPE* pComponentUUID);
+
+    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL 
+        specification for details on the SendCommand method.
+     */
+    OMX_ERRORTYPE (*SendCommand)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_COMMANDTYPE Cmd,
+            OMX_IN  OMX_U32 nParam1,
+            OMX_IN  OMX_PTR pCmdData);
+
+    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL 
+        specification for details on the GetParameter method.
+     */
+    OMX_ERRORTYPE (*GetParameter)(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nParamIndex,  
+            OMX_INOUT OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL 
+        specification for details on the SetParameter method.
+     */
+    OMX_ERRORTYPE (*SetParameter)(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nIndex,
+            OMX_IN  OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL 
+        specification for details on the GetConfig method.
+     */
+    OMX_ERRORTYPE (*GetConfig)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_INOUT OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL 
+        specification for details on the SetConfig method.
+     */
+    OMX_ERRORTYPE (*SetConfig)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_IN  OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL 
+        specification for details on the GetExtensionIndex method.
+     */
+    OMX_ERRORTYPE (*GetExtensionIndex)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_STRING cParameterName,
+            OMX_OUT OMX_INDEXTYPE* pIndexType);
+
+
+    /** refer to OMX_GetState in OMX_core.h or the OMX IL 
+        specification for details on the GetState method.
+     */
+    OMX_ERRORTYPE (*GetState)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STATETYPE* pState);
+
+    
+    /** The ComponentTunnelRequest method will interact with another OMX
+        component to determine if tunneling is possible and to setup the
+        tunneling.  The return codes for this method can be used to 
+        determine if tunneling is not possible, or if tunneling is not
+        supported.  
+        
+        Base profile components (i.e. non-interop) do not support this
+        method and should return OMX_ErrorNotImplemented 
+
+        The interop profile component MUST support tunneling to another 
+        interop profile component with a compatible port parameters.  
+        A component may also support proprietary communication.
+        
+        If proprietary communication is supported the negotiation of 
+        proprietary communication is done outside of OMX in a vendor 
+        specific way. It is only required that the proper result be 
+        returned and the details of how the setup is done is left 
+        to the component implementation.  
+    
+        When this method is invoked when nPort in an output port, the
+        component will:
+        1.  Populate the pTunnelSetup structure with the output port's 
+            requirements and constraints for the tunnel.
+
+        When this method is invoked when nPort in an input port, the
+        component will:
+        1.  Query the necessary parameters from the output port to 
+            determine if the ports are compatible for tunneling
+        2.  If the ports are compatible, the component should store
+            the tunnel step provided by the output port
+        3.  Determine which port (either input or output) is the buffer
+            supplier, and call OMX_SetParameter on the output port to
+            indicate this selection.
+        
+        The component will return from this call within 5 msec.
+    
+        @param [in] hComp
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the OMX_GetHandle method.
+        @param [in] nPort
+            nPort is used to select the port on the component to be used
+            for tunneling.
+        @param [in] hTunneledComp
+            Handle of the component to tunnel with.  This is the component 
+            handle returned by the call to the OMX_GetHandle method.  When
+            this parameter is 0x0 the component should setup the port for
+            communication with the application / IL Client.
+        @param [in] nPortOutput
+            nPortOutput is used indicate the port the component should
+            tunnel with.
+        @param [in] pTunnelSetup
+            Pointer to the tunnel setup structure.  When nPort is an output port
+            the component should populate the fields of this structure.  When
+            When nPort is an input port the component should review the setup
+            provided by the component with the output port.
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        @ingroup tun
+    */
+
+    OMX_ERRORTYPE (*ComponentTunnelRequest)(
+        OMX_IN  OMX_HANDLETYPE hComp,
+        OMX_IN  OMX_U32 nPort,
+        OMX_IN  OMX_HANDLETYPE hTunneledComp,
+        OMX_IN  OMX_U32 nTunneledPort,
+        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup); 
+
+    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL 
+        specification for details on the UseBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*UseBuffer)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes,
+            OMX_IN OMX_U8* pBuffer);
+
+    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL 
+        specification for details on the AllocateBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*AllocateBuffer)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes);
+
+    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL 
+        specification for details on the FreeBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FreeBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_U32 nPortIndex,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL 
+        specification for details on the EmptyThisBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*EmptyThisBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL 
+        specification for details on the FillThisBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FillThisBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The SetCallbacks method is used by the core to specify the callback
+        structure from the application to the component.  This is a blocking
+        call.  The component will return from this call within 5 msec.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param [in] pCallbacks
+            pointer to an OMX_CALLBACKTYPE structure used to provide the 
+            callback information to the component
+        @param [in] pAppData
+            pointer to an application defined value.  It is anticipated that 
+            the application will pass a pointer to a data structure or a "this
+            pointer" in this area to allow the callback (in the application)
+            to determine the context of the call
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    OMX_ERRORTYPE (*SetCallbacks)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_CALLBACKTYPE* pCallbacks, 
+            OMX_IN  OMX_PTR pAppData);
+
+    /** ComponentDeInit method is used to deinitialize the component
+        providing a means to free any resources allocated at component
+        initialization.  NOTE:  After this call the component handle is
+        not valid for further use.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    OMX_ERRORTYPE (*ComponentDeInit)(
+            OMX_IN  OMX_HANDLETYPE hComponent);
+
+    /** @ingroup buf */
+    OMX_ERRORTYPE (*UseEGLImage)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN void* eglImage);
+
+    OMX_ERRORTYPE (*ComponentRoleEnum)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+		OMX_OUT OMX_U8 *cRole,
+		OMX_IN OMX_U32 nIndex);
+
+} OMX_COMPONENTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_ComponentExt.h b/third_party/openmax/il/OMX_ComponentExt.h
new file mode 100644
index 0000000..24ec20c
--- /dev/null
+++ b/third_party/openmax/il/OMX_ComponentExt.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_ComponentExt.h - OpenMax IL version 1.1.2
+ * The OMX_ComponentExt header file contains extensions to the definitions used
+ * by both the application and the component to access common items.
+ */
+
+#ifndef OMX_ComponentExt_h
+#define OMX_ComponentExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully 
+ */
+#include <OMX_Types.h>
+
+
+/** Set/query the commit mode */
+typedef struct OMX_CONFIG_COMMITMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bDeferred;
+} OMX_CONFIG_COMMITMODETYPE;
+
+/** Explicit commit */
+typedef struct OMX_CONFIG_COMMITTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+} OMX_CONFIG_COMMITTYPE;
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_ComponentExt_h */
diff --git a/third_party/openmax/il/OMX_ContentPipe.h b/third_party/openmax/il/OMX_ContentPipe.h
new file mode 100644
index 0000000..79b0bb7
--- /dev/null
+++ b/third_party/openmax/il/OMX_ContentPipe.h
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_ContentPipe.h - OpenMax IL version 1.1.2
+ *  The OMX_ContentPipe header file contains the definitions used to define
+ *  the public interface for content piples.  This header file is intended to
+ *  be used by the component.
+ */
+
+#ifndef OMX_CONTENTPIPE_H
+#define OMX_CONTENTPIPE_H
+
+#ifndef KD_EACCES
+/* OpenKODE error codes. CPResult values may be zero (indicating success
+   or one of the following values) */
+#define KD_EACCES (1)
+#define KD_EADDRINUSE (2)
+#define KD_EAGAIN (5)
+#define KD_EBADF (7)
+#define KD_EBUSY (8)
+#define KD_ECONNREFUSED (9)
+#define KD_ECONNRESET (10)
+#define KD_EDEADLK (11)
+#define KD_EDESTADDRREQ (12)
+#define KD_ERANGE (35)
+#define KD_EEXIST (13)
+#define KD_EFBIG (14)
+#define KD_EHOSTUNREACH (15)
+#define KD_EINVAL (17)
+#define KD_EIO (18)
+#define KD_EISCONN (20)
+#define KD_EISDIR (21)
+#define KD_EMFILE (22)
+#define KD_ENAMETOOLONG (23)
+#define KD_ENOENT (24)
+#define KD_ENOMEM (25)
+#define KD_ENOSPC (26)
+#define KD_ENOSYS (27)
+#define KD_ENOTCONN (28)
+#define KD_EPERM (33)
+#define KD_ETIMEDOUT (36)
+#define KD_EILSEQ (19)
+#endif
+
+/** Map types from OMX standard types only here so interface is as generic as possible. */
+typedef OMX_U32    CPresult;
+typedef char *     CPstring;  
+typedef void *     CPhandle;
+typedef OMX_U32    CPuint;
+typedef OMX_S32    CPint;  
+typedef char       CPbyte;  
+typedef OMX_BOOL   CPbool;
+
+/** enumeration of origin types used in the CP_PIPETYPE's Seek function 
+ * @ingroup cp
+ */
+typedef enum CP_ORIGINTYPE {
+    CP_OriginBegin,      
+    CP_OriginCur,      
+    CP_OriginEnd,      
+    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_OriginMax = 0X7FFFFFFF
+} CP_ORIGINTYPE;
+
+/** enumeration of contact access types used in the CP_PIPETYPE's Open function 
+ * @ingroup cp
+ */
+typedef enum CP_ACCESSTYPE {
+    CP_AccessRead,      
+    CP_AccessWrite,  
+    CP_AccessReadWrite ,  
+    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_AccessMax = 0X7FFFFFFF
+} CP_ACCESSTYPE;
+
+/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function 
+ * @ingroup cp
+ */
+typedef enum CP_CHECKBYTESRESULTTYPE
+{
+    CP_CheckBytesOk,                    /**< There are at least the request number 
+                                              of bytes available */
+    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes 
+                                              and presently lacks sufficient bytes. 
+                                              Client will be called when they are 
+                                              sufficient bytes are available. */
+    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes 
+                                              but those available are less than those 
+                                              requested */
+    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
+                                              and no more bytes are available. */
+    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
+    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_CheckBytesMax = 0X7FFFFFFF
+} CP_CHECKBYTESRESULTTYPE;
+
+/** enumeration of content pipe events sent to the client callback. 
+ * @ingroup cp
+ */
+typedef enum CP_EVENTTYPE{
+    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
+    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
+    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
+    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_EventMax = 0X7FFFFFFF
+} CP_EVENTTYPE;
+
+/** content pipe definition 
+ * @ingroup cp
+ */
+typedef struct CP_PIPETYPE
+{
+    /** Open a content stream for reading or writing. */ 
+    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
+
+    /** Close a content stream. */ 
+    CPresult (*Close)( CPhandle hContent );
+
+    /** Create a content source and open it for writing. */ 
+    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
+
+    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
+    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
+
+    /** Seek to certain position in the content relative to the specified origin. */
+    CPresult (*SetPosition)( CPhandle  hContent, CPint nOffset, CP_ORIGINTYPE eOrigin);
+
+    /** Retrieve the current position relative to the start of the content. */
+    CPresult (*GetPosition)( CPhandle hContent, CPuint *pPosition);
+
+    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
+    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize); 
+
+    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes. 
+       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
+       returns the size of the block actually read. Content pointer advances the by the returned size. 
+       Note: pipe provides pointer. This function is appropriate for large reads. The client must call 
+       ReleaseReadBuffer when done with buffer. 
+
+       In some cases the requested block may not reside in contiguous memory within the
+       pipe implementation. For instance if the pipe leverages a circular buffer then the requested 
+       block may straddle the boundary of the circular buffer. By default a pipe implementation 
+       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
+       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory 
+       boundary. Here the client may retrieve the data in segments over successive calls. */
+    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
+
+    /** Release a buffer obtained by ReadBuffer back to the pipe. */
+    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
+
+    /** Write data of the specified size to the content (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
+    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize); 
+
+    /** Retrieve a buffer allocated by the pipe used to write data to the content. 
+       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
+       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
+    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
+
+    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the 
+       the contents of the buffer to content and advance content pointer by the size of the buffer */
+    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
+
+    /** Register a per-handle client callback with the content pipe. */
+    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
+
+} CP_PIPETYPE;
+
+#endif
+
diff --git a/third_party/openmax/il/OMX_Core.h b/third_party/openmax/il/OMX_Core.h
new file mode 100644
index 0000000..ab9adc8
--- /dev/null
+++ b/third_party/openmax/il/OMX_Core.h
@@ -0,0 +1,1431 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Core.h - OpenMax IL version 1.1.2
+ *  The OMX_Core header file contains the definitions used by both the
+ *  application and the component to access common items.
+ */
+
+#ifndef OMX_Core_h
+#define OMX_Core_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header shall include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Index.h>
+
+
+/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
+ *  OMX_SendCommand macro.  
+ *  @ingroup core
+ */
+typedef enum OMX_COMMANDTYPE
+{
+    OMX_CommandStateSet,    /**< Change the component state */
+    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
+    OMX_CommandPortDisable, /**< Disable a port on a component. */
+    OMX_CommandPortEnable,  /**< Enable a port on a component. */
+    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
+    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_CommandMax = 0X7FFFFFFF
+} OMX_COMMANDTYPE;
+
+
+
+/** The OMX_STATETYPE enumeration is used to indicate or change the component
+ *  state.  This enumeration reflects the current state of the component when
+ *  used with the OMX_GetState macro or becomes the parameter in a state change
+ *  command when used with the OMX_SendCommand macro.
+ *
+ *  The component will be in the Loaded state after the component is initially
+ *  loaded into memory.  In the Loaded state, the component is not allowed to
+ *  allocate or hold resources other than to build it's internal parameter
+ *  and configuration tables.  The application will send one or more
+ *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
+ *  component and the component will record each of these parameter and
+ *  configuration changes for use later.  When the application sends the
+ *  Idle command, the component will acquire the resources needed for the
+ *  specified configuration and will transition to the idle state if the
+ *  allocation is successful.  If the component cannot successfully
+ *  transition to the idle state for any reason, the state of the component
+ *  shall be fully rolled back to the Loaded state (e.g. all allocated 
+ *  resources shall be released).  When the component receives the command
+ *  to go to the Executing state, it shall begin processing buffers by
+ *  sending all input buffers it holds to the application.  While
+ *  the component is in the Idle state, the application may also send the
+ *  Pause command.  If the component receives the pause command while in the
+ *  Idle state, the component shall send all input buffers it holds to the 
+ *  application, but shall not begin processing buffers.  This will allow the
+ *  application to prefill buffers.
+ * 
+ *  @ingroup comp
+ */
+
+typedef enum OMX_STATETYPE
+{
+    OMX_StateInvalid,      /**< component has detected that it's internal data 
+                                structures are corrupted to the point that
+                                it cannot determine it's state properly */
+    OMX_StateLoaded,      /**< component has been loaded but has not completed
+                                initialization.  The OMX_SetParameter macro
+                                and the OMX_GetParameter macro are the only 
+                                valid macros allowed to be sent to the 
+                                component in this state. */
+    OMX_StateIdle,        /**< component initialization has been completed
+                                successfully and the component is ready to
+                                to start. */
+    OMX_StateExecuting,   /**< component has accepted the start command and
+                                is processing data (if data is available) */
+    OMX_StatePause,       /**< component has received pause command */
+    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
+                                preemption or before it gets the resources requested.
+                                See specification for complete details. */
+    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_StateMax = 0X7FFFFFFF
+} OMX_STATETYPE;
+
+/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
+ *  errors should cover most of the common failure cases.  However, 
+ *  vendors are free to add additional error messages of their own as 
+ *  long as they follow these rules:
+ *  1.  Vendor error messages shall be in the range of 0x90000000 to
+ *      0x9000FFFF.
+ *  2.  Vendor error messages shall be defined in a header file provided
+ *      with the component.  No error messages are allowed that are
+ *      not defined.
+ */
+typedef enum OMX_ERRORTYPE
+{
+  OMX_ErrorNone = 0,
+
+  /** There were insufficient resources to perform the requested operation */
+  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
+
+  /** There was an error, but the cause of the error could not be determined */
+  OMX_ErrorUndefined = (OMX_S32) 0x80001001,
+
+  /** The component name string was not valid */
+  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
+
+  /** No component with the specified name string was found */
+  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
+
+  /** The component specified did not have a "OMX_ComponentInit" or
+      "OMX_ComponentDeInit entry point */
+  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
+
+  /** One or more parameters were not valid */
+  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
+
+  /** The requested function is not implemented */
+  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
+
+  /** The buffer was emptied before the next buffer was ready */
+  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
+
+  /** The buffer was not available when it was needed */
+  OMX_ErrorOverflow = (OMX_S32) 0x80001008,
+
+  /** The hardware failed to respond as expected */
+  OMX_ErrorHardware = (OMX_S32) 0x80001009,
+
+  /** The component is in the state OMX_StateInvalid */
+  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
+
+  /** Stream is found to be corrupt */
+  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
+
+  /** Ports being connected are not compatible */
+  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
+
+  /** Resources allocated to an idle component have been
+      lost resulting in the component returning to the loaded state */
+  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
+
+  /** No more indicies can be enumerated */
+  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
+
+  /** The component detected a version mismatch */
+  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
+
+  /** The component is not ready to return data at this time */
+  OMX_ErrorNotReady = (OMX_S32) 0x80001010,
+
+  /** There was a timeout that occurred */
+  OMX_ErrorTimeout = (OMX_S32) 0x80001011,
+
+  /** This error occurs when trying to transition into the state you are already in */
+  OMX_ErrorSameState = (OMX_S32) 0x80001012,
+
+  /** Resources allocated to an executing or paused component have been 
+      preempted, causing the component to return to the idle state */
+  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013, 
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
+      on a port restart) when it deems that it has waited an unusually long time for the supplier 
+      to send it an allocated buffer via a UseBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
+      on a port stop) when it deems that it has waited an unusually long time for the supplier 
+      to request the deallocation of a buffer header via a FreeBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
+
+  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the stopping of a port (either on a transition from the IDLE to LOADED 
+      state or a port stop) when it deems that it has waited an unusually long time for 
+      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
+
+  /** Attempting a state transtion that is not allowed */
+  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
+
+  /* Attempting a command that is not allowed during the present state. */
+  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018, 
+
+  /** The values encapsulated in the parameter or config structure are not supported. */
+  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
+
+  /** The parameter or config indicated by the given index is not supported. */
+  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
+
+  /** The port index supplied is incorrect. */
+  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
+
+  /** The port has lost one or more of its buffers and it thus unpopulated. */
+  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
+
+  /** Component suspended due to temporary loss of resources */
+  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
+
+  /** Component suspended due to an inability to acquire dynamic resources */
+  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
+
+  /** When the macroblock error reporting is enabled the component returns new error 
+  for every frame that has errors */
+  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
+
+  /** A component reports this error when it cannot parse or determine the format of an input stream. */
+  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020, 
+
+  /** The content open operation failed. */
+  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
+
+  /** The content creation operation failed. */
+  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
+
+  /** Separate table information is being used */
+  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
+
+  /** Tunneling is unsupported by the component*/
+  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
+
+  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_ErrorMax = 0x7FFFFFFF
+} OMX_ERRORTYPE;
+
+/** @ingroup core */
+typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
+
+/** @ingroup core */
+typedef struct OMX_COMPONENTREGISTERTYPE
+{
+  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
+  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
+} OMX_COMPONENTREGISTERTYPE;
+
+/** @ingroup core */
+extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];
+
+/** @ingroup rpm */
+typedef struct OMX_PRIORITYMGMTTYPE {
+ OMX_U32 nSize;             /**< size of the structure in bytes */
+ OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+ OMX_U32 nGroupPriority;            /**< Priority of the component group */
+ OMX_U32 nGroupID;                  /**< ID of the component group */
+} OMX_PRIORITYMGMTTYPE;
+
+/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
+#define OMX_MAX_STRINGNAME_SIZE 128
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_COMPONENTROLETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
+} OMX_PARAM_COMPONENTROLETYPE;
+
+/** End of Stream Buffer Flag: 
+  *
+  * A component sets EOS when it has no more data to emit on a particular 
+  * output port. Thus an output port shall set EOS on the last buffer it 
+  * emits. A component's determination of when an output port should 
+  * cease sending data is implemenation specific.
+  * @ingroup buf
+  */
+
+#define OMX_BUFFERFLAG_EOS 0x00000001 
+
+/** Start Time Buffer Flag: 
+ *
+ * The source of a stream (e.g. a demux component) sets the STARTTIME
+ * flag on the buffer that contains the starting timestamp for the
+ * stream. The starting timestamp corresponds to the first data that
+ * should be displayed at startup or after a seek.
+ * The first timestamp of the stream is not necessarily the start time.
+ * For instance, in the case of a seek to a particular video frame, 
+ * the target frame may be an interframe. Thus the first buffer of 
+ * the stream will be the intra-frame preceding the target frame and
+ * the starttime will occur with the target frame (with any other
+ * required frames required to reconstruct the target intervening).
+ *
+ * The STARTTIME flag is directly associated with the buffer's 
+ * timestamp ' thus its association to buffer data and its 
+ * propagation is identical to the timestamp's.
+ *
+ * When a Sync Component client receives a buffer with the 
+ * STARTTIME flag it shall perform a SetConfig on its sync port 
+ * using OMX_ConfigTimeClientStartTime and passing the buffer's
+ * timestamp.
+ * 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_STARTTIME 0x00000002
+
+ 
+
+/** Decode Only Buffer Flag: 
+ *
+ * The source of a stream (e.g. a demux component) sets the DECODEONLY
+ * flag on any buffer that should shall be decoded but should not be
+ * displayed. This flag is used, for instance, when a source seeks to 
+ * a target interframe that requires the decode of frames preceding the 
+ * target to facilitate the target's reconstruction. In this case the 
+ * source would emit the frames preceding the target downstream 
+ * but mark them as decode only.
+ *
+ * The DECODEONLY is associated with buffer data and propagated in a 
+ * manner identical to the buffer timestamp.
+ *
+ * A component that renders data should ignore all buffers with 
+ * the DECODEONLY flag set.
+ * 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DECODEONLY 0x00000004
+
+
+/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
+
+/* End of Frame: The buffer contains exactly one end of frame and no data
+ *  occurs after the end of frame. This flag is an optional hint. The absence
+ *  of this flag does not imply the absence of an end of frame within the buffer. 
+ * @ingroup buf
+*/
+#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
+
+/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
+ *  a frame that has no dependency on any other frame information 
+ *  @ingroup buf
+ */
+#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
+
+/* Extra data present flag: there is extra data appended to the data stream
+ * residing in the buffer 
+ * @ingroup buf  
+ */
+#define OMX_BUFFERFLAG_EXTRADATA 0x00000040
+
+/** Codec Config Buffer Flag: 
+* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
+* output port when all bytes in the buffer form part or all of a set of
+* codec specific configuration data.  Examples include SPS/PPS nal units
+* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
+* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets 
+* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
+* with frame data in the same buffer, and shall send all buffers
+* containing codec configuration bytes before any buffers containing
+* frame data that those configurations bytes describe.
+* If the stream format for a particular codec has a frame specific
+* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
+* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
+* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
+ * @ingroup buf
+ */
+#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080
+
+
+
+/** @ingroup buf */
+typedef struct OMX_BUFFERHEADERTYPE
+{
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
+                                     that is acting as the buffer */
+    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
+    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
+                                     buffer */
+    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
+                                     the start of the buffer */
+    OMX_PTR pAppPrivate;        /**< pointer to any data the application
+                                     wants to associate with this buffer */
+    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
+                                     wants to associate with this buffer */ 
+    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
+                                     wants to associate with this buffer */
+    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
+                                     wants to associate with this buffer */
+    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
+                                              mark event upon processing this buffer. */
+    OMX_PTR pMarkData;          /**< Application specific data associated with 
+                                     the mark sent on a mark event to disambiguate 
+                                     this mark from others. */
+    OMX_U32 nTickCount;         /**< Optional entry that the component and
+                                     application can update with a tick count
+                                     when they access the component.  This
+                                     value should be in microseconds.  Since
+                                     this is a value relative to an arbitrary
+                                     starting point, this value cannot be used 
+                                     to determine absolute time.  This is an
+                                     optional entry and not all components
+                                     will update it.*/
+ OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
+                                     starting at the first logical sample 
+                                     boundary in the buffer. Timestamps of 
+                                     successive samples within the buffer may
+                                     be inferred by adding the duration of the 
+                                     of the preceding buffer to the timestamp
+                                     of the preceding buffer.*/
+  OMX_U32     nFlags;           /**< buffer specific flags */
+  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
+                                     this buffer */
+  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
+                                     this buffer */
+} OMX_BUFFERHEADERTYPE;
+
+/** The OMX_EXTRADATATYPE enumeration is used to define the 
+ * possible extra data payload types.
+ * NB: this enum is binary backwards compatible with the previous
+ * OMX_EXTRADATA_QUANT define.  This should be replaced with
+ * OMX_ExtraDataQuantization.
+ */
+typedef enum OMX_EXTRADATATYPE
+{
+   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */        
+   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
+   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_ExtraDataMax = 0x7FFFFFFF
+} OMX_EXTRADATATYPE;
+
+
+typedef struct OMX_OTHER_EXTRADATATYPE  {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;
+    OMX_EXTRADATATYPE eType;       /* Extra Data type */
+    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
+    OMX_U8  data[1];     /* Supporting data hint  */
+} OMX_OTHER_EXTRADATATYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PORT_PARAM_TYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPorts;             /**< The number of ports for this component */
+    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
+} OMX_PORT_PARAM_TYPE; 
+
+/** @ingroup comp */
+typedef enum OMX_EVENTTYPE
+{
+    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
+    OMX_EventError,               /**< component has detected an error condition */
+    OMX_EventMark,                /**< component has detected a buffer mark */
+    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
+    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
+    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
+                                       automatically starting the state change from
+                                       OMX_StateWaitForResources to OMX_StateIdle. */
+   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
+   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
+   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
+   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_EventMax = 0x7FFFFFFF
+} OMX_EVENTTYPE;
+
+typedef struct OMX_CALLBACKTYPE
+{
+    /** The EventHandler method is used to notify the application when an
+        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
+        enumeration.  Please see that enumeration for details of what will
+        be returned for each type of event. Callbacks should not return
+        an error to the component, so if an error occurs, the application 
+        shall handle it internally.  This is a blocking call.
+
+        The application should return from this call within 5 msec to avoid
+        blocking the component for an excessively long period of time.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param eEvent
+            Event that the component wants to notify the application about.
+        @param nData1
+            nData will be the OMX_ERRORTYPE for an error event and will be 
+            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
+         @param nData2
+            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
+            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
+            Default value is 0 if not used. )
+        @param pEventData
+            Pointer to additional event-specific data (see spec for meaning).
+      */
+
+   OMX_ERRORTYPE (*EventHandler)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_EVENTTYPE eEvent,
+        OMX_IN OMX_U32 nData1,
+        OMX_IN OMX_U32 nData2,
+        OMX_IN OMX_PTR pEventData);
+
+    /** The EmptyBufferDone method is used to return emptied buffers from an
+        input port back to the application for reuse.  This is a blocking call 
+        so the application should not attempt to refill the buffers during this
+        call, but should queue them and refill them in another thread.  There
+        is no error return, so the application shall handle any errors generated
+        internally.  
+        
+        The application should return from this call within 5 msec.
+        
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was emptied.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*EmptyBufferDone)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The FillBufferDone method is used to return filled buffers from an
+        output port back to the application for emptying and then reuse.  
+        This is a blocking call so the application should not attempt to 
+        empty the buffers during this call, but should queue the buffers 
+        and empty them in another thread.  There is no error return, so 
+        the application shall handle any errors generated internally.  The 
+        application shall also update the buffer header to indicate the
+        number of bytes placed into the buffer.  
+
+        The application should return from this call within 5 msec.
+        
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was filled.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FillBufferDone)(
+        OMX_OUT OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_PTR pAppData,
+        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
+
+} OMX_CALLBACKTYPE;
+
+/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
+    preference when tunneling between two ports.
+    @ingroup tun buf
+*/
+typedef enum OMX_BUFFERSUPPLIERTYPE
+{
+    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
+                                              or don't care */
+    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
+    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
+    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_BufferSupplyMax = 0x7FFFFFFF
+} OMX_BUFFERSUPPLIERTYPE;
+
+
+/** buffer supplier parameter 
+ * @ingroup tun
+ */
+typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< port that this structure applies to */
+    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
+} OMX_PARAM_BUFFERSUPPLIERTYPE;
+
+
+/**< indicates that buffers received by an input port of a tunnel 
+     may not modify the data in the buffers 
+     @ingroup tun
+ */
+#define OMX_PORTTUNNELFLAG_READONLY 0x00000001 
+
+
+/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
+    port to an input port as part the two ComponentTunnelRequest calls
+    resulting from a OMX_SetupTunnel call from the IL Client. 
+    @ingroup tun
+ */   
+typedef struct OMX_TUNNELSETUPTYPE
+{
+    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
+    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
+} OMX_TUNNELSETUPTYPE; 
+
+/* OMX Component headers is included to enable the core to use
+   macros for functions into the component for OMX release 1.0.  
+   Developers should not access any structures or data from within
+   the component header directly */
+/* TO BE REMOVED - #include <OMX_Component.h> */
+
+/** GetComponentVersion will return information about the component.  
+    This is a blocking call.  This macro will go directly from the
+    application to the component (via a core macro).  The
+    component will return from this call within 5 msec.
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [out] pComponentName
+        pointer to an empty string of length 128 bytes.  The component 
+        will write its name into this string.  The name will be 
+        terminated by a single zero byte.  The name of a component will 
+        be 127 bytes or less to leave room for the trailing zero byte.  
+        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
+    @param [out] pComponentVersion
+        pointer to an OMX Version structure that the component will fill 
+        in.  The component will fill in a value that indicates the 
+        component version.  NOTE: the component version is NOT the same 
+        as the OMX Specification version (found in all structures).  The 
+        component version is defined by the vendor of the component and 
+        its value is entirely up to the component vendor.
+    @param [out] pSpecVersion
+        pointer to an OMX Version structure that the component will fill 
+        in.  The SpecVersion is the version of the specification that the 
+        component was built against.  Please note that this value may or 
+        may not match the structure's version.  For example, if the 
+        component was built against the 2.0 specification, but the 
+        application (which creates the structure is built against the 
+        1.0 specification the versions would be different.
+    @param [out] pComponentUUID
+        pointer to the UUID of the component which will be filled in by 
+        the component.  The UUID is a unique identifier that is set at 
+        RUN time for the component and is unique to each instantion of 
+        the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetComponentVersion(                            \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                                     \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                 /* Macro End */
+
+
+/** Send a command to the component.  This call is a non-blocking call.
+    The component should check the parameters and then queue the command
+    to the component thread to be executed.  The component thread shall 
+    send the EventHandler() callback at the conclusion of the command. 
+    This macro will go directly from the application to the component (via
+    a core macro).  The component will return from this call within 5 msec.
+    
+    When the command is "OMX_CommandStateSet" the component will queue a
+    state transition to the new state idenfied in nParam.
+    
+    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
+    the command will force the component to return all buffers NOT CURRENTLY 
+    BEING PROCESSED to the application, in the order in which the buffers 
+    were received.
+    
+    When the command is "OMX_CommandPortDisable" or 
+    "OMX_CommandPortEnable", the component's port (given by the value of
+    nParam) will be stopped or restarted. 
+    
+    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
+    pCmdData will point to a OMX_MARKTYPE structure containing the component
+    handle of the component to examine the buffer chain for the mark.  nParam1
+    contains the index of the port on which the buffer mark is applied.
+
+    Specification text for more details. 
+    
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [in] Cmd
+        Command for the component to execute
+    @param [in] nParam
+        Parameter for the command to be executed.  When Cmd has the value 
+        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has 
+        the value OMX_CommandFlush, value of nParam indicates which port(s) 
+        to flush. -1 is used to flush all ports a single port index will 
+        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
+        or "OMX_CommandPortEnable", the component's port is given by 
+        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
+        the components pot is given by the value of nParam.
+    @param [in] pCmdData
+        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
+        "OMX_CommandMarkBuffer".     
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SendCommand(                                    \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                                          \
+     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                          /* Macro End */
+
+
+/** The OMX_GetParameter macro will get one of the current parameter 
+    settings from the component.  This macro cannot only be invoked when 
+    the component is in the OMX_StateInvalid state.  The nParamIndex
+    parameter is used to indicate which structure is being requested from
+    the component.  The application shall allocate the correct structure 
+    and shall fill in the structure size and version information before 
+    invoking this macro.  When the parameter applies to a port, the
+    caller shall fill in the appropriate nPortIndex value indicating the
+    port on which the parameter applies. If the component has not had 
+    any settings changed, then the component should return a set of 
+    valid DEFAULT  parameters for the component.  This is a blocking 
+    call.  
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nParamIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentParameterStructure
+        Pointer to application allocated structure to be filled by the 
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_SetParameter macro will send an initialization parameter
+    structure to a component.  Each structure shall be sent one at a time,
+    in a separate invocation of the macro.  This macro can only be
+    invoked when the component is in the OMX_StateLoaded state, or the
+    port is disabled (when the parameter applies to a port). The 
+    nParamIndex parameter is used to indicate which structure is being
+    passed to the component.  The application shall allocate the 
+    correct structure and shall fill in the structure size and version 
+    information (as well as the actual data) before invoking this macro.
+    The application is free to dispose of this structure after the call
+    as the component is required to copy any data it shall retain.  This 
+    is a blocking call.  
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in] pComponentParameterStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_GetConfig macro will get one of the configuration structures 
+    from a component.  This macro can be invoked anytime after the 
+    component has been loaded.  The nParamIndex call parameter is used to 
+    indicate which structure is being requested from the component.  The 
+    application shall allocate the correct structure and shall fill in the 
+    structure size and version information before invoking this macro.  
+    If the component has not had this configuration parameter sent before, 
+    then the component should return a set of valid DEFAULT values for the 
+    component.  This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentConfigStructure
+        pointer to application allocated structure to be filled by the 
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+*/        
+#define OMX_GetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_SetConfig macro will send one of the configuration 
+    structures to a component.  Each structure shall be sent one at a time,
+    each in a separate invocation of the macro.  This macro can be invoked 
+    anytime after the component has been loaded.  The application shall 
+    allocate the correct structure and shall fill in the structure size 
+    and version information (as well as the actual data) before invoking 
+    this macro.  The application is free to dispose of this structure after 
+    the call as the component is required to copy any data it shall retain.  
+    This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nConfigIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration above.
+    @param [in] pComponentConfigStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_GetExtensionIndex macro will invoke a component to translate 
+    a vendor specific configuration or parameter string into an OMX 
+    structure index.  There is no requirement for the vendor to support 
+    this command for the indexes already found in the OMX_INDEXTYPE 
+    enumeration (this is done to save space in small components).  The 
+    component shall support all vendor supplied extension indexes not found
+    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @param [in] cParameterName
+        OMX_STRING that shall be less than 128 characters long including
+        the trailing null byte.  This is the string that will get 
+        translated by the component into a configuration index.
+    @param [out] pIndexType
+        a pointer to a OMX_INDEXTYPE to receive the index value.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetExtensionIndex(                              \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                     /* Macro End */
+
+
+/** The OMX_GetState macro will invoke the component to get the current 
+    state of the component and place the state value into the location
+    pointed to by pState.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] pState
+        pointer to the location to receive the state.  The value returned
+        is one of the OMX_STATETYPE members 
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetState(                                       \
+        hComponent,                                         \
+        pState)                                             \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
+        hComponent,                                         \
+        pState)                         /* Macro End */
+
+
+/** The OMX_UseBuffer macro will request that the component use
+    a buffer (and allocate its own buffer header) already allocated 
+    by another component, or by the IL Client. This is a blocking 
+    call.
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to the buffer header
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+
+#define OMX_UseBuffer(                                      \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)
+
+
+/** The OMX_AllocateBuffer macro will request that the component allocate 
+    a new buffer and buffer header.  The component will allocate the 
+    buffer and the buffer header and return a pointer to the buffer 
+    header.  This is a blocking call.
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
+        the pointer to the buffer header
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the 
+        buffer header structure.
+    @param [in] nSizeBytes
+        size of the buffer to allocate.  Used when bAllocateNew is true.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */    
+#define OMX_AllocateBuffer(                                 \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                     /* Macro End */
+
+
+/** The OMX_FreeBuffer macro will release a buffer header from the component
+    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
+    the component allocated the buffer (see the OMX_UseBuffer macro) then 
+    the component shall free the buffer and buffer header. This is a 
+    blocking call. 
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FreeBuffer(                                     \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
+    input port of a component.  The buffer will be emptied by the component
+    and returned to the application via the EmptyBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then empty the buffer, later, at the proper 
+    time.  As expected, this macro may be invoked only while the component 
+    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
+    port, the component shall return an error.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_EmptyThisBuffer(                                \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_FillThisBuffer macro will send an empty buffer to an 
+    output port of a component.  The buffer will be filled by the component
+    and returned to the application via the FillBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then fill the buffer, later, at the proper 
+    time.  As expected, this macro may be invoked only while the component 
+    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
+    port, the component shall return an error.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FillThisBuffer(                                 \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+
+/** The OMX_UseEGLImage macro will request that the component use
+    a EGLImage provided by EGL (and allocate its own buffer header)
+    This is a blocking call.
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to the buffer header.  Note that the memory location used
+        for this buffer is NOT visible to the IL Client.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the 
+        buffer header structure.
+    @param [in] eglImage
+        eglImage contains the handle of the EGLImage to use as a buffer on the
+        specified port.  The component is expected to validate properties of 
+        the EGLImage against the configuration of the port to ensure the component
+        can use the EGLImage as a buffer.          
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_UseEGLImage(                                    \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)                                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)
+
+/** The OMX_Init method is used to initialize the OMX core.  It shall be the
+    first call made into OMX and it should only be executed one time without
+    an interviening OMX_Deinit call.  
+    
+    The core should return from this call within 20 msec.
+
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
+
+
+/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
+    the last call made into OMX. In the event that the core determines that 
+    thare are components loaded when this call is made, the core may return 
+    with an error rather than try to unload the components.
+        
+    The core should return from this call within 20 msec.
+    
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);
+
+
+/** The OMX_ComponentNameEnum method will enumerate through all the names of
+    recognised valid components in the system. This function is provided
+    as a means to detect all the components in the system run-time. There is
+    no strict ordering to the enumeration order of component names, although
+    each name will only be enumerated once.  If the OMX core supports run-time
+    installation of new components, it is only requried to detect newly
+    installed components when the first call to enumerate component names
+    is made (i.e. when nIndex is 0x0).
+    
+    The core should return from this call in 20 msec.
+    
+    @param [out] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example 
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
+        assigned by the vendor, but shall start with "OMX." and then have 
+        the Vendor designation next.
+    @param [in] nNameLength
+        number of characters in the cComponentName string.  With all 
+        component name strings restricted to less than 128 characters 
+        (including the trailing null) it is recomended that the caller
+        provide a input string for the cComponentName of 128 characters.
+    @param [in] nIndex
+        number containing the enumeration index for the component. 
+        Multiple calls to OMX_ComponentNameEnum with increasing values
+        of nIndex will enumerate through the component names in the
+        system until OMX_ErrorNoMore is returned.  The value of nIndex
+        is 0 to (N-1), where N is the number of valid installed components
+        in the system.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  When the value of nIndex exceeds the number of 
+        components in the system minus 1, OMX_ErrorNoMore will be
+        returned. Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
+    OMX_OUT OMX_STRING cComponentName,
+    OMX_IN  OMX_U32 nNameLength,
+    OMX_IN  OMX_U32 nIndex);
+
+
+/** The OMX_GetHandle method will locate the component specified by the
+    component name given, load that component into memory and then invoke
+    the component's methods to create an instance of the component.  
+    
+    The core should return from this call within 20 msec.
+    
+    @param [out] pHandle
+        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
+    @param [in] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example 
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
+        assigned by the vendor, but shall start with "OMX." and then have 
+        the Vendor designation next.
+    @param [in] pAppData
+        pointer to an application defined value that will be returned
+        during callbacks so that the application can identify the source
+        of the callback.
+    @param [in] pCallBacks
+        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
+        component to initialize it with.  
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
+    OMX_OUT OMX_HANDLETYPE* pHandle, 
+    OMX_IN  OMX_STRING cComponentName,
+    OMX_IN  OMX_PTR pAppData,
+    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
+
+
+/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
+    method.  If the component reference count goes to zero, the component will
+    be unloaded from memory.  
+    
+    The core should return from this call within 20 msec when the component is 
+    in the OMX_StateLoaded state.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
+    OMX_IN  OMX_HANDLETYPE hComponent);
+
+
+
+/** The OMX_SetupTunnel method will handle the necessary calls to the components
+    to setup the specified tunnel the two components.  NOTE: This is
+    an actual method (not a #define macro).  This method will make calls into
+    the component ComponentTunnelRequest method to do the actual tunnel 
+    connection.  
+
+    The ComponentTunnelRequest method on both components will be called. 
+    This method shall not be called unless the component is in the 
+    OMX_StateLoaded state except when the ports used for the tunnel are
+    disabled. In this case, the component may be in the OMX_StateExecuting,
+    OMX_StatePause, or OMX_StateIdle states. 
+
+    The core should return from this call within 20 msec.
+    
+    @param [in] hOutput
+        Handle of the component to be accessed.  Also this is the handle
+        of the component whose port, specified in the nPortOutput parameter
+        will be used the source for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a 
+        requirement that hOutput be the source for the data when
+        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
+        specified in hInput will have it's port specified in nPortInput
+        setup for communication with the application / IL client.
+    @param [in] nPortOutput
+        nPortOutput is used to select the source port on component to be
+        used in the tunnel. 
+    @param [in] hInput
+        This is the component to setup the tunnel with. This is the handle
+        of the component whose port, specified in the nPortInput parameter
+        will be used the destination for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a 
+        requirement that hInput be the destination for the data when
+        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
+        specified in hOutput will have it's port specified in nPortPOutput
+        setup for communication with the application / IL client.
+    @param [in] nPortInput
+        nPortInput is used to select the destination port on component to be
+        used in the tunnel.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        When OMX_ErrorNotImplemented is returned, one or both components is 
+        a non-interop component and does not support tunneling.
+        
+        On failure, the ports of both components are setup for communication
+        with the application / IL Client.
+    @ingroup core tun
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
+    OMX_IN  OMX_HANDLETYPE hOutput,
+    OMX_IN  OMX_U32 nPortOutput,
+    OMX_IN  OMX_HANDLETYPE hInput,
+    OMX_IN  OMX_U32 nPortInput);
+    
+/** @ingroup cp */
+OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
+    OMX_OUT OMX_HANDLETYPE *hPipe,
+    OMX_IN OMX_STRING szURI);
+
+/** The OMX_GetComponentsOfRole method will return the number of components that support the given
+    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the compNames field NULL to determine the number of component names
+        * second call this function with the compNames field pointing to an array of names allocated 
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+    
+    @param [in] role
+        This is generic standard component name consisting only of component class 
+        name and the type within that class (e.g. 'audio_decoder.aac').
+    @param [inout] pNumComps
+        This is used both as input and output. 
+ 
+        If compNames is NULL, the input is ignored and the output specifies how many components support
+        the given role.
+     
+        If compNames is not NULL, on input it bounds the size of the input structure and 
+        on output, it specifies the number of components string names listed within the compNames parameter.
+    @param [inout] compNames
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
+        a list of the names of all physical components that implement the specified standard component name. 
+        Each name is NULL terminated. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
+	OMX_IN      OMX_STRING role,
+    OMX_INOUT   OMX_U32 *pNumComps,
+    OMX_INOUT   OMX_U8  **compNames);
+
+/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
+    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the roles field NULL to determine the number of role names
+        * second call this function with the roles field pointing to an array of names allocated 
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+
+    @param [in] compName
+        This is the name of the component being queried about.
+    @param [inout] pNumRoles
+        This is used both as input and output. 
+ 
+        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
+     
+        If compNames is not NULL, on input it bounds the size of the input structure and 
+        on output, it specifies the number of roles string names listed within the roles parameter.
+    @param [out] roles
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
+        which accepts a list of the names of all standard components roles implemented on the 
+        specified component name. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
+	OMX_IN      OMX_STRING compName, 
+    OMX_INOUT   OMX_U32 *pNumRoles,
+    OMX_OUT     OMX_U8 **roles);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/third_party/openmax/il/OMX_CoreExt.h b/third_party/openmax/il/OMX_CoreExt.h
new file mode 100644
index 0000000..e2e21cc
--- /dev/null
+++ b/third_party/openmax/il/OMX_CoreExt.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_CoreExt.h - OpenMax IL version 1.1.2
+ * The OMX_CoreExt header file contains extensions to the definitions used
+ * by both the application and the component to access common items.
+ */
+
+#ifndef OMX_CoreExt_h
+#define OMX_CoreExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Core.h>
+
+/** Extensions to the standard IL errors. */ 
+typedef enum OMX_ERROREXTTYPE 
+{
+    OMX_ErrorInvalidMode = (OMX_S32) (OMX_ErrorKhronosExtensions + 0x00000001),
+    OMX_ErrorExtMax = 0x7FFFFFFF
+} OMX_ERROREXTTYPE;
+
+
+/** Event type extensions. */
+typedef enum OMX_EVENTEXTTYPE
+{
+    OMX_EventIndexSettingChanged = OMX_EventKhronosExtensions, /**< component signals the IL client of a change
+                                                                    in a param, config, or extension */
+    OMX_EventExtMax = 0x7FFFFFFF
+} OMX_EVENTEXTTYPE;
+
+
+/** Enable or disable a callback event. */
+typedef struct OMX_CONFIG_CALLBACKREQUESTTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_INDEXTYPE nIndex;       /**< the index the callback is requested for */
+    OMX_BOOL bEnable;           /**< enable (OMX_TRUE) or disable (OMX_FALSE) the callback */
+} OMX_CONFIG_CALLBACKREQUESTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_CoreExt_h */
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_IVCommon.h b/third_party/openmax/il/OMX_IVCommon.h
new file mode 100644
index 0000000..619a91d
--- /dev/null
+++ b/third_party/openmax/il/OMX_IVCommon.h
@@ -0,0 +1,920 @@
+/**
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** 
+ * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
+ *  The structures needed by Video and Image components to exchange
+ *  parameters and configuration data with the components.
+ */
+#ifndef OMX_IVCommon_h
+#define OMX_IVCommon_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**
+ * Each OMX header must include all required header files to allow the header
+ * to compile without errors.  The includes below are required for this header
+ * file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup iv OpenMAX IL Imaging and Video Domain
+ * Common structures for OpenMAX IL Imaging and Video domains
+ * @{
+ */
+
+
+/** 
+ * Enumeration defining possible uncompressed image/video formats. 
+ *
+ * ENUMS:
+ *  Unused                 : Placeholder value when format is N/A
+ *  Monochrome             : black and white
+ *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
+ *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
+ *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
+ *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
+ *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
+ *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
+ *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
+ *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
+ *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
+ *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
+ *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
+ *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
+ *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
+ *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
+ *  YUV411PackedPlanar     : packed per payload in planar slices
+ *  YUV420Planar           : Three arrays Y,U,V.
+ *  YUV420PackedPlanar     : packed per payload in planar slices
+ *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YUV422Planar           : Three arrays Y,U,V.
+ *  YUV422PackedPlanar     : packed per payload in planar slices
+ *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
+ *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
+ *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
+ *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
+ *  YUV444Interleaved      : Each pixel contains equal parts YUV
+ *  RawBayer8bit           : SMIA camera output format
+ *  RawBayer10bit          : SMIA camera output format
+ *  RawBayer8bitcompressed : SMIA camera output format
+ */
+typedef enum OMX_COLOR_FORMATTYPE {
+    OMX_COLOR_FormatUnused,
+    OMX_COLOR_FormatMonochrome,
+    OMX_COLOR_Format8bitRGB332,
+    OMX_COLOR_Format12bitRGB444,
+    OMX_COLOR_Format16bitARGB4444,
+    OMX_COLOR_Format16bitARGB1555,
+    OMX_COLOR_Format16bitRGB565,
+    OMX_COLOR_Format16bitBGR565,
+    OMX_COLOR_Format18bitRGB666,
+    OMX_COLOR_Format18bitARGB1665,
+    OMX_COLOR_Format19bitARGB1666, 
+    OMX_COLOR_Format24bitRGB888,
+    OMX_COLOR_Format24bitBGR888,
+    OMX_COLOR_Format24bitARGB1887,
+    OMX_COLOR_Format25bitARGB1888,
+    OMX_COLOR_Format32bitBGRA8888,
+    OMX_COLOR_Format32bitARGB8888,
+    OMX_COLOR_FormatYUV411Planar,
+    OMX_COLOR_FormatYUV411PackedPlanar,
+    OMX_COLOR_FormatYUV420Planar,
+    OMX_COLOR_FormatYUV420PackedPlanar,
+    OMX_COLOR_FormatYUV420SemiPlanar,
+    OMX_COLOR_FormatYUV422Planar,
+    OMX_COLOR_FormatYUV422PackedPlanar,
+    OMX_COLOR_FormatYUV422SemiPlanar,
+    OMX_COLOR_FormatYCbYCr,
+    OMX_COLOR_FormatYCrYCb,
+    OMX_COLOR_FormatCbYCrY,
+    OMX_COLOR_FormatCrYCbY,
+    OMX_COLOR_FormatYUV444Interleaved,
+    OMX_COLOR_FormatRawBayer8bit,
+    OMX_COLOR_FormatRawBayer10bit,
+    OMX_COLOR_FormatRawBayer8bitcompressed,
+    OMX_COLOR_FormatL2, 
+    OMX_COLOR_FormatL4, 
+    OMX_COLOR_FormatL8, 
+    OMX_COLOR_FormatL16, 
+    OMX_COLOR_FormatL24, 
+    OMX_COLOR_FormatL32,
+    OMX_COLOR_FormatYUV420PackedSemiPlanar,
+    OMX_COLOR_FormatYUV422PackedSemiPlanar,
+    OMX_COLOR_Format18BitBGR666,
+    OMX_COLOR_Format24BitARGB6666,
+    OMX_COLOR_Format24BitABGR6666,
+    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_COLOR_FormatMax = 0x7FFFFFFF
+} OMX_COLOR_FORMATTYPE;
+
+
+/** 
+ * Defines the matrix for conversion from RGB to YUV or vice versa.
+ * iColorMatrix should be initialized with the fixed point values 
+ * used in converting between formats.
+ */
+typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
+    OMX_U32 nSize;              /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */ 
+    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
+    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
+    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
+}OMX_CONFIG_COLORCONVERSIONTYPE;
+
+
+/** 
+ * Structure defining percent to scale each frame dimension.  For example:  
+ * To make the width 50% larger, use fWidth = 1.5 and to make the width
+ * 1/2 the original size, use fWidth = 0.5
+ */
+typedef struct OMX_CONFIG_SCALEFACTORTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */ 
+    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
+    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
+    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
+}OMX_CONFIG_SCALEFACTORTYPE;
+
+
+/** 
+ * Enumeration of possible image filter types 
+ */
+typedef enum OMX_IMAGEFILTERTYPE {
+    OMX_ImageFilterNone,
+    OMX_ImageFilterNoise,
+    OMX_ImageFilterEmboss,
+    OMX_ImageFilterNegative,
+    OMX_ImageFilterSketch,
+    OMX_ImageFilterOilPaint,
+    OMX_ImageFilterHatch,
+    OMX_ImageFilterGpen,
+    OMX_ImageFilterAntialias, 
+    OMX_ImageFilterDeRing,       
+    OMX_ImageFilterSolarize,
+    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ImageFilterMax = 0x7FFFFFFF
+} OMX_IMAGEFILTERTYPE;
+
+
+/** 
+ * Image filter configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes       
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to 
+ *  eImageFilter : Image filter type enumeration      
+ */
+typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGEFILTERTYPE eImageFilter;
+} OMX_CONFIG_IMAGEFILTERTYPE;
+
+
+/** 
+ * Customized U and V for color enhancement 
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information 
+ *  nPortIndex        : Port that this structure applies to
+ *  bColorEnhancement : Enable/disable color enhancement
+ *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for 
+ *                      U component
+ *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for 
+ *                      V component
+ */
+typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;
+    OMX_BOOL bColorEnhancement;
+    OMX_U8 nCustomizedU;
+    OMX_U8 nCustomizedV;
+} OMX_CONFIG_COLORENHANCEMENTTYPE;
+
+
+/** 
+ * Define color key and color key mask 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
+ *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
+ */
+typedef struct OMX_CONFIG_COLORKEYTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nARGBColor;
+    OMX_U32 nARGBMask;
+} OMX_CONFIG_COLORKEYTYPE;
+
+
+/** 
+ * List of color blend types for pre/post processing 
+ *
+ * ENUMS:
+ *  None          : No color blending present
+ *  AlphaConstant : Function is (alpha_constant * src) + 
+ *                  (1 - alpha_constant) * dst)
+ *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
+ *  Alternate     : Function is alternating pixels from src and dst
+ *  And           : Function is (src & dst)
+ *  Or            : Function is (src | dst)
+ *  Invert        : Function is ~src
+ */
+typedef enum OMX_COLORBLENDTYPE {
+    OMX_ColorBlendNone,
+    OMX_ColorBlendAlphaConstant,
+    OMX_ColorBlendAlphaPerPixel,
+    OMX_ColorBlendAlternate,
+    OMX_ColorBlendAnd,
+    OMX_ColorBlendOr,
+    OMX_ColorBlendInvert,
+    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ColorBlendMax = 0x7FFFFFFF
+} OMX_COLORBLENDTYPE;
+
+
+/** 
+ * Color blend configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes                        
+ *  nVersion          : OMX specification version information                
+ *  nPortIndex        : Port that this structure applies to                   
+ *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
+ *  eColorBlend       : Color blend type enumeration                         
+ */
+typedef struct OMX_CONFIG_COLORBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nRGBAlphaConstant;
+    OMX_COLORBLENDTYPE  eColorBlend;
+} OMX_CONFIG_COLORBLENDTYPE;
+
+
+/** 
+ * Hold frame dimension
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes      
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to     
+ *  nWidth     : Frame width in pixels                 
+ *  nHeight    : Frame height in pixels                
+ */
+typedef struct OMX_FRAMESIZETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_FRAMESIZETYPE;
+
+
+/**
+ * Rotation configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes             
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nRotation  : +/- integer rotation value               
+ */
+typedef struct OMX_CONFIG_ROTATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nRotation; 
+} OMX_CONFIG_ROTATIONTYPE;
+
+
+/** 
+ * Possible mirroring directions for pre/post processing 
+ *
+ * ENUMS:
+ *  None       : No mirroring                         
+ *  Vertical   : Vertical mirroring, flip on X axis   
+ *  Horizontal : Horizontal mirroring, flip on Y axis  
+ *  Both       : Both vertical and horizontal mirroring
+ */
+typedef enum OMX_MIRRORTYPE {
+    OMX_MirrorNone = 0,
+    OMX_MirrorVertical,
+    OMX_MirrorHorizontal,
+    OMX_MirrorBoth, 
+    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MirrorMax = 0x7FFFFFFF   
+} OMX_MIRRORTYPE;
+
+
+/** 
+ * Mirroring configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes      
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to  
+ *  eMirror    : Mirror type enumeration              
+ */
+typedef struct OMX_CONFIG_MIRRORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;
+    OMX_MIRRORTYPE  eMirror;
+} OMX_CONFIG_MIRRORTYPE;
+
+
+/** 
+ * Position information only 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes               
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nX         : X coordinate for the point                     
+ *  nY         : Y coordinate for the point 
+ */                      
+typedef struct OMX_CONFIG_POINTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nX;
+    OMX_S32 nY;
+} OMX_CONFIG_POINTTYPE;
+
+
+/** 
+ * Frame size plus position 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes                    
+ *  nVersion   : OMX specification version information      
+ *  nPortIndex : Port that this structure applies to    
+ *  nLeft      : X Coordinate of the top left corner of the rectangle
+ *  nTop       : Y Coordinate of the top left corner of the rectangle
+ *  nWidth     : Width of the rectangle                              
+ *  nHeight    : Height of the rectangle                             
+ */
+typedef struct OMX_CONFIG_RECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;  
+    OMX_U32 nPortIndex; 
+    OMX_S32 nLeft; 
+    OMX_S32 nTop;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_CONFIG_RECTTYPE;
+
+
+/** 
+ * Deblocking state; it is required to be set up before starting the codec 
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes      
+ *  nVersion    : OMX specification version information 
+ *  nPortIndex  : Port that this structure applies to
+ *  bDeblocking : Enable/disable deblocking mode    
+ */
+typedef struct OMX_PARAM_DEBLOCKINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDeblocking;
+} OMX_PARAM_DEBLOCKINGTYPE;
+
+
+/** 
+ * Stabilization state 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes          
+ *  nVersion   : OMX specification version information    
+ *  nPortIndex : Port that this structure applies to   
+ *  bStab      : Enable/disable frame stabilization state
+ */
+typedef struct OMX_CONFIG_FRAMESTABTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bStab;
+} OMX_CONFIG_FRAMESTABTYPE;
+
+
+/** 
+ * White Balance control type 
+ *
+ * STRUCT MEMBERS:
+ *  SunLight : Referenced in JSR-234
+ *  Flash    : Optimal for device's integrated flash
+ */
+typedef enum OMX_WHITEBALCONTROLTYPE {
+    OMX_WhiteBalControlOff = 0,
+    OMX_WhiteBalControlAuto,
+    OMX_WhiteBalControlSunLight,
+    OMX_WhiteBalControlCloudy,
+    OMX_WhiteBalControlShade,
+    OMX_WhiteBalControlTungsten,
+    OMX_WhiteBalControlFluorescent,
+    OMX_WhiteBalControlIncandescent,
+    OMX_WhiteBalControlFlash,
+    OMX_WhiteBalControlHorizon,
+    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_WhiteBalControlMax = 0x7FFFFFFF
+} OMX_WHITEBALCONTROLTYPE;
+
+
+/** 
+ * White Balance control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes       
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to                 
+ *  eWhiteBalControl : White balance enumeration            
+ */
+typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
+} OMX_CONFIG_WHITEBALCONTROLTYPE;
+
+
+/** 
+ * Exposure control type 
+ */
+typedef enum OMX_EXPOSURECONTROLTYPE {
+    OMX_ExposureControlOff = 0,
+    OMX_ExposureControlAuto,
+    OMX_ExposureControlNight,
+    OMX_ExposureControlBackLight,
+    OMX_ExposureControlSpotLight,
+    OMX_ExposureControlSports,
+    OMX_ExposureControlSnow,
+    OMX_ExposureControlBeach,
+    OMX_ExposureControlLargeAperture,
+    OMX_ExposureControlSmallApperture,
+    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ExposureControlMax = 0x7FFFFFFF
+} OMX_EXPOSURECONTROLTYPE;
+
+
+/** 
+ * White Balance control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes      
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to                
+ *  eExposureControl : Exposure control enumeration         
+ */
+typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_EXPOSURECONTROLTYPE eExposureControl;
+} OMX_CONFIG_EXPOSURECONTROLTYPE;
+
+
+/** 
+ * Defines sensor supported mode. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes           
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to 
+ *  nFrameRate : Single shot mode is indicated by a 0     
+ *  bOneShot   : Enable for single shot, disable for streaming
+ *  sFrameSize : Framesize                                          
+ */
+typedef struct OMX_PARAM_SENSORMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nFrameRate;
+    OMX_BOOL bOneShot;
+    OMX_FRAMESIZETYPE sFrameSize;
+} OMX_PARAM_SENSORMODETYPE;
+
+
+/** 
+ * Defines contrast level 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes                              
+ *  nVersion   : OMX specification version information                
+ *  nPortIndex : Port that this structure applies to                 
+ *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_CONTRASTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nContrast;
+} OMX_CONFIG_CONTRASTTYPE;
+
+
+/** 
+ * Defines brightness level 
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes          
+ *  nVersion    : OMX specification version information 
+ *  nPortIndex  : Port that this structure applies to 
+ *  nBrightness : 0-100%        
+ */
+typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBrightness;
+} OMX_CONFIG_BRIGHTNESSTYPE;
+
+
+/** 
+ * Defines backlight level configuration for a video sink, e.g. LCD panel 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nBacklight : Values allowed for backlight 0-100%
+ *  nTimeout   : Number of milliseconds before backlight automatically turns 
+ *               off.  A value of 0x0 disables backight timeout 
+ */
+typedef struct OMX_CONFIG_BACKLIGHTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBacklight;
+    OMX_U32 nTimeout;
+} OMX_CONFIG_BACKLIGHTTYPE;
+
+
+/** 
+ * Defines setting for Gamma 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_GAMMATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nGamma;
+} OMX_CONFIG_GAMMATYPE;
+
+
+/** 
+ * Define for setting saturation 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nSaturation : Values allowed for saturation -100 to 100, zero means 
+ *                no change
+ */
+typedef struct OMX_CONFIG_SATURATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nSaturation;
+} OMX_CONFIG_SATURATIONTYPE;
+
+
+/** 
+ * Define for setting Lightness 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nLightness : Values allowed for lightness -100 to 100, zero means no 
+ *               change
+ */
+typedef struct OMX_CONFIG_LIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nLightness;
+} OMX_CONFIG_LIGHTNESSTYPE;
+
+
+/** 
+ * Plane blend configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes 
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Index of input port associated with the plane.
+ *  nDepth     : Depth of the plane in relation to the screen. Higher 
+ *               numbered depths are "behind" lower number depths.  
+ *               This number defaults to the Port Index number.
+ *  nAlpha     : Transparency blending component for the entire plane.  
+ *               See blending modes for more detail.
+ */
+typedef struct OMX_CONFIG_PLANEBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nDepth;
+    OMX_U32 nAlpha;
+} OMX_CONFIG_PLANEBLENDTYPE;
+
+
+/** 
+ * Define interlace type
+ *
+ * STRUCT MEMBERS:
+ *  nSize                 : Size of the structure in bytes 
+ *  nVersion              : OMX specification version information 
+ *  nPortIndex            : Port that this structure applies to
+ *  bEnable               : Enable control variable for this functionality 
+ *                          (see below)
+ *  nInterleavePortIndex  : Index of input or output port associated with  
+ *                          the interleaved plane. 
+ *  pPlanarPortIndexes[4] : Index of input or output planar ports.
+ */
+typedef struct OMX_PARAM_INTERLEAVETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_U32 nInterleavePortIndex;
+} OMX_PARAM_INTERLEAVETYPE;
+
+
+/** 
+ * Defines the picture effect used for an input picture 
+ */
+typedef enum OMX_TRANSITIONEFFECTTYPE {
+    OMX_EffectNone,
+    OMX_EffectFadeFromBlack,
+    OMX_EffectFadeToBlack,
+    OMX_EffectUnspecifiedThroughConstantColor,
+    OMX_EffectDissolve,
+    OMX_EffectWipe,
+    OMX_EffectUnspecifiedMixOfTwoScenes,
+    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EffectMax = 0x7FFFFFFF
+} OMX_TRANSITIONEFFECTTYPE;
+
+
+/** 
+ * Structure used to configure current transition effect 
+ *
+ * STRUCT MEMBERS:
+ * nSize      : Size of the structure in bytes
+ * nVersion   : OMX specification version information 
+ * nPortIndex : Port that this structure applies to
+ * eEffect    : Effect to enable
+ */
+typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_TRANSITIONEFFECTTYPE eEffect;
+} OMX_CONFIG_TRANSITIONEFFECTTYPE;
+
+
+/** 
+ * Defines possible data unit types for encoded video data. The data unit 
+ * types are used both for encoded video input for playback as well as
+ * encoded video output from recording. 
+ */
+typedef enum OMX_DATAUNITTYPE {
+    OMX_DataUnitCodedPicture,
+    OMX_DataUnitVideoSegment,
+    OMX_DataUnitSeveralSegments,
+    OMX_DataUnitArbitraryStreamSection,
+    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataUnitMax = 0x7FFFFFFF
+} OMX_DATAUNITTYPE;
+
+
+/** 
+ * Defines possible encapsulation types for coded video data unit. The 
+ * encapsulation information is used both for encoded video input for 
+ * playback as well as encoded video output from recording. 
+ */
+typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
+    OMX_DataEncapsulationElementaryStream,
+    OMX_DataEncapsulationGenericPayload,
+    OMX_DataEncapsulationRtpPayload,
+    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataEncapsulationMax = 0x7FFFFFFF
+} OMX_DATAUNITENCAPSULATIONTYPE;
+
+
+/** 
+ * Structure used to configure the type of being decoded/encoded 
+ */
+typedef struct OMX_PARAM_DATAUNITTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DATAUNITTYPE eUnitType;
+    OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
+} OMX_PARAM_DATAUNITTYPE;
+
+
+/**
+ * Defines dither types 
+ */
+typedef enum OMX_DITHERTYPE {
+    OMX_DitherNone,
+    OMX_DitherOrdered,
+    OMX_DitherErrorDiffusion,
+    OMX_DitherOther,
+    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DitherMax = 0x7FFFFFFF
+} OMX_DITHERTYPE;
+
+
+/** 
+ * Structure used to configure current type of dithering 
+ */
+typedef struct OMX_CONFIG_DITHERTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
+} OMX_CONFIG_DITHERTYPE;
+
+typedef struct OMX_CONFIG_CAPTUREMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
+    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture 
+                             *   data as fast as possible (otherwise obey port's frame rate). */
+    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the 
+                             *   specified number of frames (otherwise the port does not 
+                             *   terminate the capture until instructed to do so by the client). 
+                             *   Even if set, the client may manually terminate the capture prior 
+                             *   to reaching the limit. */
+    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
+                               *   valid if bFrameLimited is set). */
+} OMX_CONFIG_CAPTUREMODETYPE;
+
+typedef enum OMX_METERINGTYPE {
+ 
+    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
+    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
+    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
+ 
+    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EVModeMax = 0x7fffffff
+} OMX_METERINGTYPE;
+ 
+typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_METERINGTYPE eMetering;
+    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
+    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
+    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
+    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */ 
+    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */ 
+    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
+    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
+} OMX_CONFIG_EXPOSUREVALUETYPE;
+
+/** 
+ * Focus region configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  bCenter         : Use center region as focus region of interest
+ *  bLeft           : Use left region as focus region of interest
+ *  bRight          : Use right region as focus region of interest
+ *  bTop            : Use top region as focus region of interest
+ *  bBottom         : Use bottom region as focus region of interest
+ *  bTopLeft        : Use top left region as focus region of interest
+ *  bTopRight       : Use top right region as focus region of interest
+ *  bBottomLeft     : Use bottom left region as focus region of interest
+ *  bBottomRight    : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bCenter;
+    OMX_BOOL bLeft;
+    OMX_BOOL bRight;
+    OMX_BOOL bTop;
+    OMX_BOOL bBottom;
+    OMX_BOOL bTopLeft;
+    OMX_BOOL bTopRight;
+    OMX_BOOL bBottomLeft;
+    OMX_BOOL bBottomRight;
+} OMX_CONFIG_FOCUSREGIONTYPE;
+
+/** 
+ * Focus Status type 
+ */
+typedef enum OMX_FOCUSSTATUSTYPE {
+    OMX_FocusStatusOff = 0,
+    OMX_FocusStatusRequest,
+    OMX_FocusStatusReached,
+    OMX_FocusStatusUnableToReach,
+    OMX_FocusStatusLost,
+    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FocusStatusMax = 0x7FFFFFFF
+} OMX_FOCUSSTATUSTYPE;
+
+/** 
+ * Focus status configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize               : Size of the structure in bytes
+ *  nVersion            : OMX specification version information
+ *  nPortIndex          : Port that this structure applies to
+ *  eFocusStatus        : Specifies the focus status
+ *  bCenterStatus       : Use center region as focus region of interest
+ *  bLeftStatus         : Use left region as focus region of interest
+ *  bRightStatus        : Use right region as focus region of interest
+ *  bTopStatus          : Use top region as focus region of interest
+ *  bBottomStatus       : Use bottom region as focus region of interest
+ *  bTopLeftStatus      : Use top left region as focus region of interest
+ *  bTopRightStatus     : Use top right region as focus region of interest
+ *  bBottomLeftStatus   : Use bottom left region as focus region of interest
+ *  bBottomRightStatus  : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_FOCUSSTATUSTYPE eFocusStatus;
+    OMX_BOOL bCenterStatus;
+    OMX_BOOL bLeftStatus;
+    OMX_BOOL bRightStatus;
+    OMX_BOOL bTopStatus;
+    OMX_BOOL bBottomStatus;
+    OMX_BOOL bTopLeftStatus;
+    OMX_BOOL bTopRightStatus;
+    OMX_BOOL bBottomLeftStatus;
+    OMX_BOOL bBottomRightStatus;
+} OMX_PARAM_FOCUSSTATUSTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_Image.h b/third_party/openmax/il/OMX_Image.h
new file mode 100644
index 0000000..0769d0d
--- /dev/null
+++ b/third_party/openmax/il/OMX_Image.h
@@ -0,0 +1,328 @@
+/**
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ */
+
+/** 
+ * @file OMX_Image.h - OpenMax IL version 1.1.2
+ * The structures needed by Image components to exchange parameters and 
+ * configuration data with the components.
+ */
+#ifndef OMX_Image_h
+#define OMX_Image_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the 
+ * header to compile without errors.  The includes below are required  
+ * for this header file to compile successfully 
+ */
+
+#include <OMX_IVCommon.h>
+
+/** @defgroup imaging OpenMAX IL Imaging Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Imaging domain
+ * @{
+ */
+
+/** 
+ * Enumeration used to define the possible image compression coding. 
+ */
+typedef enum OMX_IMAGE_CODINGTYPE {
+    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
+    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
+    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
+    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
+    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
+    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
+    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
+    OMX_IMAGE_CodingPNG,         /**< PNG image format */
+    OMX_IMAGE_CodingLZW,         /**< LZW image format */
+    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
+    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_CodingMax = 0x7FFFFFFF
+} OMX_IMAGE_CODINGTYPE;
+
+
+/**
+ * Data structure used to define an image path. The number of image paths 
+ * for input and output will vary by type of the image component.  
+ * 
+ *  Input (aka Source) : Zero Inputs, one Output,
+ *  Splitter           : One Input, 2 or more Outputs,
+ *  Processing Element : One Input, one output,
+ *  Mixer              : 2 or more inputs, one output,
+ *  Output (aka Sink)  : One Input, zero outputs.
+ * 
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output  
+ * image path.  If additional vendor specific data is required, it should  
+ * be transmitted to the component using the CustomCommand function.   
+ * Compliant components will prepopulate this structure with optimal  
+ * values during the OMX_GetParameter() command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a 
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on port if 
+ *                          uncompressed format is used.  Use 0 for 
+ *                          unknown, don't care or variable
+ *  nFrameHeight          : Height of frame to be used on port if 
+ *                          uncompressed format is used. Use 0 for 
+ *                          unknown, don't care or variable
+ *  nStride               : Number of bytes per span of an image (i.e. 
+ *                          indicates the number of bytes to get from
+ *                          span N to span N+1, where negative stride 
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of  
+ *                          the component. When OMX_IMAGE_CodingUnused is 
+ *                          specified, eColorFormat is valid
+ *  eColorFormat          : Decompressed format used by this component
+ *  pNativeWindow         : Platform specific reference for a window object if a 
+ *                          display sink , otherwise this field is 0x0. 
+ */
+typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth; 
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;     
+    OMX_U32 nSliceHeight;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_IMAGE_PORTDEFINITIONTYPE;
+
+
+/**  
+ * Port format parameter.  This structure is used to enumerate the various 
+ * data input/output format supported by the port.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from 
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the 
+ *                       component. When OMX_IMAGE_CodingUnused is specified, 
+ *                       eColorFormat is valid
+ *  eColorFormat       : Decompressed format used by this component
+ */
+typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+} OMX_IMAGE_PARAM_PORTFORMATTYPE;
+
+
+/** 
+ * Flash control type 
+ *
+ * ENUMS
+ *  Torch : Flash forced constantly on
+ */
+typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
+    OMX_IMAGE_FlashControlOn = 0,
+    OMX_IMAGE_FlashControlOff,
+    OMX_IMAGE_FlashControlAuto,
+    OMX_IMAGE_FlashControlRedEyeReduction,
+    OMX_IMAGE_FlashControlFillin,
+    OMX_IMAGE_FlashControlTorch,
+    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FLASHCONTROLTYPE;
+
+
+/** 
+ * Flash control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize         : Size of the structure in bytes
+ *  nVersion      : OMX specification version information
+ *  nPortIndex    : Port that this structure applies to
+ *  eFlashControl : Flash control type
+ */
+typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
+} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
+
+
+/** 
+ * Focus control type 
+ */
+typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
+    OMX_IMAGE_FocusControlOn = 0,
+    OMX_IMAGE_FocusControlOff,
+    OMX_IMAGE_FocusControlAuto,
+    OMX_IMAGE_FocusControlAutoLock,
+    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FOCUSCONTROLTYPE;
+
+ 
+/** 
+ * Focus control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  eFocusControl   : Focus control
+ *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
+ *                    Interest is only in number of steps over this range.
+ *  nFocusStepIndex : Current focus step index
+ */
+typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
+    OMX_U32 nFocusSteps;
+    OMX_U32 nFocusStepIndex;
+} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
+
+
+/** 
+ * Q Factor for JPEG compression, which controls the tradeoff between image
+ * quality and size.  Q Factor provides a more simple means of controlling
+ * JPEG compression quality, without directly programming Quantization
+ * tables for chroma and luma 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes         
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to 
+ *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
+ *               produces the smallest, worst quality images, and a factor 
+ *               of 100 produces the largest, best quality images.  A 
+ *               typical default is 75 for small good quality images               
+ */
+typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_U32 nQFactor;                                        
+} OMX_IMAGE_PARAM_QFACTORTYPE;
+
+/** 
+ * Quantization table type 
+ */
+
+typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
+    OMX_IMAGE_QuantizationTableLuma = 0,
+    OMX_IMAGE_QuantizationTableChroma,
+    OMX_IMAGE_QuantizationTableChromaCb,
+    OMX_IMAGE_QuantizationTableChromaCr,
+    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
+} OMX_IMAGE_QUANTIZATIONTABLETYPE;
+
+/** 
+ * JPEG quantization tables are used to determine DCT compression for
+ * YUV data, as an alternative to specifying Q factor, providing exact 
+ * control of compression 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information 
+ *  nPortIndex              : Port that this structure applies to
+ *  eQuantizationTable      : Quantization table type
+ *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
+ *                            in increasing columns then by rows of data (i.e. 
+ *                            row 1, ... row 8). Quantization values are in 
+ *                            the range 0-255 and stored in linear order
+ *                            (i.e. the component will zig-zag the 
+ *                            quantization table data if required internally) 
+ */
+typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
+    OMX_U8 nQuantizationMatrix[64];
+} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
+
+
+/** 
+ * Huffman table type, the same Huffman table is applied for chroma and 
+ * luma component 
+ */
+typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
+    OMX_IMAGE_HuffmanTableAC = 0,
+    OMX_IMAGE_HuffmanTableDC,
+    OMX_IMAGE_HuffmanTableACLuma,
+    OMX_IMAGE_HuffmanTableACChroma,
+    OMX_IMAGE_HuffmanTableDCLuma,
+    OMX_IMAGE_HuffmanTableDCChroma,
+    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
+} OMX_IMAGE_HUFFMANTABLETYPE;
+
+/** 
+ * JPEG Huffman table 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                            : Size of the structure in bytes
+ *  nVersion                         : OMX specification version information
+ *  nPortIndex                       : Port that this structure applies to
+ *  eHuffmanTable                    : Huffman table type
+ *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
+ *                                     possible length
+ *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
+ *                                     HuffmanTable are 16 and 162 
+ */
+typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
+    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
+    OMX_U8 nHuffmanTable[256];
+}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
+
+/** @} */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_ImageExt.h b/third_party/openmax/il/OMX_ImageExt.h
new file mode 100644
index 0000000..e7cae02
--- /dev/null
+++ b/third_party/openmax/il/OMX_ImageExt.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_ImageExt.h - OpenMax IL version 1.1.2
+ * The OMX_ImageExt header file contains extensions to the
+ * definitions used by both the application and the component to
+ * access image items.
+ */
+
+#ifndef OMX_ImageExt_h
+#define OMX_ImageExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Core.h>
+
+/** Enum for standard image codingtype extensions */
+typedef enum OMX_IMAGE_CODINGEXTTYPE {
+    OMX_IMAGE_CodingExtUnused = OMX_IMAGE_CodingKhronosExtensions,
+    OMX_IMAGE_CodingWEBP,         /**< WebP image format */
+} OMX_IMAGE_CODINGEXTTYPE;
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_ImageExt_h */
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_Index.h b/third_party/openmax/il/OMX_Index.h
new file mode 100644
index 0000000..98d1e8e
--- /dev/null
+++ b/third_party/openmax/il/OMX_Index.h
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Index.h - OpenMax IL version 1.1.2
+ *  The OMX_Index header file contains the definitions for both applications
+ *  and components .
+ */
+
+
+#ifndef OMX_Index_h
+#define OMX_Index_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+#include <OMX_Types.h>
+
+
+/** The OMX_INDEXTYPE enumeration is used to select a structure when either
+ *  getting or setting parameters and/or configuration data.  Each entry in 
+ *  this enumeration maps to an OMX specified structure.  When the 
+ *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
+ *  are used, the second parameter will always be an entry from this enumeration
+ *  and the third entry will be the structure shown in the comments for the entry.
+ *  For example, if the application is initializing a cropping function, the 
+ *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter 
+ *  and would send a pointer to an initialized OMX_RECTTYPE structure as the 
+ *  third parameter.
+ *  
+ *  The enumeration entries named with the OMX_Config prefix are sent using
+ *  the OMX_SetConfig command and the enumeration entries named with the
+ *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
+ */
+typedef enum OMX_INDEXTYPE {
+
+    OMX_IndexComponentStartUnused = 0x01000000,
+    OMX_IndexParamPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamAudioInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamImageInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamVideoInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamOtherInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamNumAvailableStreams,      /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
+    OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
+    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
+    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */ 
+    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
+    OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
+    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */ 
+    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
+    OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
+    OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
+    OMX_IndexConfigMetadataItem,            /**< reference: OMX_CONFIG_METADATAITEMTYPE */
+    OMX_IndexConfigCounterNodeID,           /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
+    OMX_IndexParamMetadataFilterType,       /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */
+
+    OMX_IndexPortStartUnused = 0x02000000,
+    OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
+    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */ 
+    OMX_IndexReservedStartUnused = 0x03000000,
+
+    /* Audio parameters and configurations */
+    OMX_IndexAudioStartUnused = 0x04000000,
+    OMX_IndexParamAudioPortFormat,          /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamAudioPcm,                 /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
+    OMX_IndexParamAudioAac,                 /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
+    OMX_IndexParamAudioRa,                  /**< reference: OMX_AUDIO_PARAM_RATYPE */
+    OMX_IndexParamAudioMp3,                 /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
+    OMX_IndexParamAudioAdpcm,               /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
+    OMX_IndexParamAudioG723,                /**< reference: OMX_AUDIO_PARAM_G723TYPE */
+    OMX_IndexParamAudioG729,                /**< reference: OMX_AUDIO_PARAM_G729TYPE */
+    OMX_IndexParamAudioAmr,                 /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
+    OMX_IndexParamAudioWma,                 /**< reference: OMX_AUDIO_PARAM_WMATYPE */
+    OMX_IndexParamAudioSbc,                 /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
+    OMX_IndexParamAudioMidi,                /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
+    OMX_IndexParamAudioGsm_FR,              /**< reference: OMX_AUDIO_PARAM_GSMFRTYPE */
+    OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
+    OMX_IndexParamAudioG726,                /**< reference: OMX_AUDIO_PARAM_G726TYPE */
+    OMX_IndexParamAudioGsm_EFR,             /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
+    OMX_IndexParamAudioGsm_HR,              /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
+    OMX_IndexParamAudioPdc_FR,              /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
+    OMX_IndexParamAudioPdc_EFR,             /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
+    OMX_IndexParamAudioPdc_HR,              /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
+    OMX_IndexParamAudioTdma_FR,             /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
+    OMX_IndexParamAudioTdma_EFR,            /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
+    OMX_IndexParamAudioQcelp8,              /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
+    OMX_IndexParamAudioQcelp13,             /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
+    OMX_IndexParamAudioEvrc,                /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
+    OMX_IndexParamAudioSmv,                 /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
+    OMX_IndexParamAudioVorbis,              /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */
+
+    OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
+    OMX_IndexConfigAudioMidiControl,        /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
+    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
+    OMX_IndexConfigAudioMidiStatus,         /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
+    OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
+    OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
+    OMX_IndexConfigAudioVolume,             /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
+    OMX_IndexConfigAudioBalance,            /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
+    OMX_IndexConfigAudioChannelMute,        /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
+    OMX_IndexConfigAudioMute,               /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
+    OMX_IndexConfigAudioLoudness,           /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
+    OMX_IndexConfigAudioEchoCancelation,    /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
+    OMX_IndexConfigAudioNoiseReduction,     /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
+    OMX_IndexConfigAudioBass,               /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
+    OMX_IndexConfigAudioTreble,             /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
+    OMX_IndexConfigAudioStereoWidening,     /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
+    OMX_IndexConfigAudioChorus,             /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
+    OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
+    OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
+    OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
+
+    /* Image specific parameters and configurations */
+    OMX_IndexImageStartUnused = 0x05000000,
+    OMX_IndexParamImagePortFormat,          /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamFlashControl,             /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+    OMX_IndexConfigFocusControl,            /**< reference: OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
+    OMX_IndexParamQFactor,                  /**< reference: OMX_IMAGE_PARAM_QFACTORTYPE */
+    OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
+    OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
+    OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+
+    /* Video specific parameters and configurations */
+    OMX_IndexVideoStartUnused = 0x06000000,
+    OMX_IndexParamVideoPortFormat,          /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamVideoQuantization,        /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
+    OMX_IndexParamVideoFastUpdate,          /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
+    OMX_IndexParamVideoBitrate,             /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
+    OMX_IndexParamVideoMotionVector,        /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
+    OMX_IndexParamVideoIntraRefresh,        /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
+    OMX_IndexParamVideoErrorCorrection,     /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
+    OMX_IndexParamVideoVBSMC,               /**< reference: OMX_VIDEO_PARAM_VBSMCTYPE */
+    OMX_IndexParamVideoMpeg2,               /**< reference: OMX_VIDEO_PARAM_MPEG2TYPE */
+    OMX_IndexParamVideoMpeg4,               /**< reference: OMX_VIDEO_PARAM_MPEG4TYPE */
+    OMX_IndexParamVideoWmv,                 /**< reference: OMX_VIDEO_PARAM_WMVTYPE */
+    OMX_IndexParamVideoRv,                  /**< reference: OMX_VIDEO_PARAM_RVTYPE */
+    OMX_IndexParamVideoAvc,                 /**< reference: OMX_VIDEO_PARAM_AVCTYPE */
+    OMX_IndexParamVideoH263,                /**< reference: OMX_VIDEO_PARAM_H263TYPE */
+    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexParamVideoProfileLevelCurrent, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexConfigVideoBitrate,            /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
+    OMX_IndexConfigVideoFramerate,          /**< reference: OMX_CONFIG_FRAMERATETYPE */
+    OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
+    OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexConfigVideoMBErrorReporting,   /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
+    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
+    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
+    OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
+    OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
+
+    /* Image & Video common Configurations */
+    OMX_IndexCommonStartUnused = 0x07000000,
+    OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
+    OMX_IndexParamCommonSensorMode,         /**< reference: OMX_PARAM_SENSORMODETYPE */
+    OMX_IndexParamCommonInterleave,         /**< reference: OMX_PARAM_INTERLEAVETYPE */
+    OMX_IndexConfigCommonColorFormatConversion, /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
+    OMX_IndexConfigCommonScale,             /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonImageFilter,       /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
+    OMX_IndexConfigCommonColorEnhancement,  /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
+    OMX_IndexConfigCommonColorKey,          /**< reference: OMX_CONFIG_COLORKEYTYPE */
+    OMX_IndexConfigCommonColorBlend,        /**< reference: OMX_CONFIG_COLORBLENDTYPE */
+    OMX_IndexConfigCommonFrameStabilisation,/**< reference: OMX_CONFIG_FRAMESTABTYPE */
+    OMX_IndexConfigCommonRotate,            /**< reference: OMX_CONFIG_ROTATIONTYPE */
+    OMX_IndexConfigCommonMirror,            /**< reference: OMX_CONFIG_MIRRORTYPE */
+    OMX_IndexConfigCommonOutputPosition,    /**< reference: OMX_CONFIG_POINTTYPE */
+    OMX_IndexConfigCommonInputCrop,         /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonOutputCrop,        /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDigitalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonOpticalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
+    OMX_IndexConfigCommonWhiteBalance,      /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
+    OMX_IndexConfigCommonExposure,          /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
+    OMX_IndexConfigCommonContrast,          /**< reference: OMX_CONFIG_CONTRASTTYPE */
+    OMX_IndexConfigCommonBrightness,        /**< reference: OMX_CONFIG_BRIGHTNESSTYPE */
+    OMX_IndexConfigCommonBacklight,         /**< reference: OMX_CONFIG_BACKLIGHTTYPE */
+    OMX_IndexConfigCommonGamma,             /**< reference: OMX_CONFIG_GAMMATYPE */
+    OMX_IndexConfigCommonSaturation,        /**< reference: OMX_CONFIG_SATURATIONTYPE */
+    OMX_IndexConfigCommonLightness,         /**< reference: OMX_CONFIG_LIGHTNESSTYPE */
+    OMX_IndexConfigCommonExclusionRect,     /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDithering,         /**< reference: OMX_CONFIG_DITHERTYPE */
+    OMX_IndexConfigCommonPlaneBlend,        /**< reference: OMX_CONFIG_PLANEBLENDTYPE */
+    OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
+    OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
+    OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
+    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
+    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
+    OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */
+
+    /* Reserved Configuration range */
+    OMX_IndexOtherStartUnused = 0x08000000,
+    OMX_IndexParamOtherPortFormat,          /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
+    OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
+    OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */
+
+
+    /* Reserved Time range */
+    OMX_IndexTimeStartUnused = 0x09000000,
+    OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
+    OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
+    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
+    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
+    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
+
+
+    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    /* Vendor specific area */
+    OMX_IndexVendorStartUnused = 0x7F000000,
+    /* Vendor specific structures should be in the range of 0x7F000000 
+       to 0x7FFFFFFE.  This range is not broken out by vendor, so
+       private indexes are not guaranteed unique and therefore should
+       only be sent to the appropriate component. */
+
+    OMX_IndexMax = 0x7FFFFFFF
+
+} OMX_INDEXTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_IndexExt.h b/third_party/openmax/il/OMX_IndexExt.h
new file mode 100644
index 0000000..fcbcb94
--- /dev/null
+++ b/third_party/openmax/il/OMX_IndexExt.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_IndexExt.h - OpenMax IL version 1.1.2
+ * The OMX_IndexExt header file contains extensions to the definitions 
+ * for both applications and components .
+ */
+
+#ifndef OMX_IndexExt_h
+#define OMX_IndexExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Index.h>
+
+
+/** Khronos standard extension indices.
+
+This enum lists the current Khronos extension indices to OpenMAX IL.
+*/
+typedef enum OMX_INDEXEXTTYPE {
+
+    /* Component parameters and configurations */
+    OMX_IndexExtComponentStartUnused = OMX_IndexKhronosExtensions + 0x00100000,
+    OMX_IndexConfigCallbackRequest,                 /**< reference: OMX_CONFIG_CALLBACKREQUESTTYPE */
+    OMX_IndexConfigCommitMode,                      /**< reference: OMX_CONFIG_COMMITMODETYPE */
+    OMX_IndexConfigCommit,                          /**< reference: OMX_CONFIG_COMMITTYPE */
+
+    /* Port parameters and configurations */
+    OMX_IndexExtPortStartUnused = OMX_IndexKhronosExtensions + 0x00200000,
+
+    /* Audio parameters and configurations */
+    OMX_IndexExtAudioStartUnused = OMX_IndexKhronosExtensions + 0x00400000,
+
+    /* Image parameters and configurations */
+    OMX_IndexExtImageStartUnused = OMX_IndexKhronosExtensions + 0x00500000,
+
+    /* Video parameters and configurations */
+    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
+    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamVideoVp8,                         /**< reference: OMX_VIDEO_PARAM_VP8TYPE */
+    OMX_IndexConfigVideoVp8ReferenceFrame,          /**< reference: OMX_VIDEO_VP8REFERENCEFRAMETYPE */
+    OMX_IndexConfigVideoVp8ReferenceFrameType,      /**< reference: OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE */
+
+    /* Image & Video common configurations */
+    OMX_IndexExtCommonStartUnused = OMX_IndexKhronosExtensions + 0x00700000,
+
+    /* Other configurations */
+    OMX_IndexExtOtherStartUnused = OMX_IndexKhronosExtensions + 0x00800000,
+
+    /* Time configurations */
+    OMX_IndexExtTimeStartUnused = OMX_IndexKhronosExtensions + 0x00900000,
+
+    OMX_IndexExtMax = 0x7FFFFFFF
+} OMX_INDEXEXTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_IndexExt_h */
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_Other.h b/third_party/openmax/il/OMX_Other.h
new file mode 100644
index 0000000..8fa635a
--- /dev/null
+++ b/third_party/openmax/il/OMX_Other.h
@@ -0,0 +1,337 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Other.h - OpenMax IL version 1.1.2
+ *  The structures needed by Other components to exchange
+ *  parameters and configuration data with the components.
+ */
+
+#ifndef OMX_Other_h
+#define OMX_Other_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+
+/** 
+ * Enumeration of possible data types which match to multiple domains or no
+ * domain at all.  For types which are vendor specific, a value above
+ * OMX_OTHER_VENDORTSTART should be used.
+ */
+typedef enum OMX_OTHER_FORMATTYPE {
+    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
+                                   time deltas, etc */
+    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
+                                   management, setting clocks? */
+    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
+                                   dropped, etc */
+    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
+    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
+                                                formats */
+
+    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_OTHER_FormatMax = 0x7FFFFFFF
+} OMX_OTHER_FORMATTYPE;
+
+/** 
+ * Enumeration of seek modes.
+ */
+typedef enum OMX_TIME_SEEKMODETYPE {
+    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
+                                * of the requested seek position over   
+                                * the actual seek position if it
+                                * results in a faster seek. */
+    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
+                                * position over an approximation
+                                * of the requested seek position even
+                                * if it results in a slower seek. */
+    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_TIME_SeekModeMax = 0x7FFFFFFF
+} OMX_TIME_SEEKMODETYPE;
+
+/* Structure representing the seekmode of the component */
+typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
+} OMX_TIME_CONFIG_SEEKMODETYPE;
+
+/** Structure representing a time stamp used with the following configs 
+ * on the Clock Component (CC):
+ * 
+ * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall  
+ *     time
+ * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
+ *     time
+ * OMX_IndexConfigTimeCurrentAudioReference and  
+ * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference 
+ *     clock sending SC its reference time
+ * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
+ *     this structure to the Clock Component via a SetConfig on its 
+ *     client port when it receives a buffer with
+ *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
+ *     specified by that buffer for nStartTimestamp. 
+ *
+ * Its also used with the following config on components in general:
+ *
+ * OMX_IndexConfigTimePosition: IL client querying component position 
+ * (GetConfig) or commanding a component to seek to the given location
+ * (SetConfig)
+ */	
+typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
+    OMX_U32 nSize;               /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
+                                  *   information */
+    OMX_U32 nPortIndex;     /**< port that this structure applies to */
+    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
+} OMX_TIME_CONFIG_TIMESTAMPTYPE;  
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_UPDATETYPE {
+      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
+      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
+      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
+      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_UpdateMax = 0x7FFFFFFF
+} OMX_TIME_UPDATETYPE;
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_REFCLOCKTYPE {
+      OMX_TIME_RefClockNone,    /**< Use no references. */
+      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
+      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
+      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_RefClockMax = 0x7FFFFFFF
+} OMX_TIME_REFCLOCKTYPE;
+
+/** Enumeration of clock states. */
+typedef enum OMX_TIME_CLOCKSTATE {
+      OMX_TIME_ClockStateRunning,             /**< Clock running. */
+      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
+                                               *   prescribed clients emit their
+                                               *   start time. */
+      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
+      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_ClockStateMax = 0x7FFFFFFF
+} OMX_TIME_CLOCKSTATE;
+
+/** Structure representing a media time request to the clock component.
+ *
+ *  A client component sends this structure to the Clock Component via a SetConfig
+ *  on its client port to specify a media timestamp the Clock Component
+ *  should emit.  The Clock Component should fulfill the request by sending a
+ *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
+ *  timestamp.
+ *
+ *  The client may require a media time request be fulfilled slightly
+ *  earlier than the media time specified. In this case the client specifies 
+ *  an offset which is equal to the difference between wall time corresponding 
+ *  to the requested media time and the wall time when it will be 
+ *  fulfilled. 
+ *
+ *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
+ *  time events according to timestamps. If a client must perform an operation O at
+ *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
+ *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
+ *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
+ *  structure back to the client component, the client may perform operation O (perhaps having
+ *  to wait a slight amount more time itself as specified by the return values).
+ */
+
+typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
+                                 *   from others (e.g. the number of the frame to deliver). 
+                                 *   Duplicated in the media time structure that fulfills 
+                                 *   this request. A value of zero is reserved for time scale 
+                                 *   updates. */
+    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
+    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
+                                 *   request should be fulfilled early */
+} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
+
+/**< Structure sent from the clock component client either when fulfilling 
+ *   a media time request or when the time scale has changed. 
+ *
+ *   In the former case the Clock Component fills this structure and times its emission 
+ *   to a client component (via the client port) according to the corresponding media 
+ *   time request sent by the client. The Clock Component should time the emission to occur
+ *   when the requested timestamp matches the Clock Component's media time but also the 
+ *   prescribed offset early. 
+ *
+ *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
+ *   media time and sets the nScale to the new scale via the client port. It emits a 
+ *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
+ *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
+ *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
+ *   from an audio frame to scale audio data. 
+ *
+ *   It is expected that some clock components may not be able to fulfill requests
+ *   at exactly the prescribed time. This is acceptable so long as the request is 
+ *   fulfilled at least as early as described and not later. This structure provides 
+ *   fields the client may use to wait for the remaining time.
+ *
+ *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
+ *   wall time until the nMediaTimestamp actually occurs. In the latter case the
+ *   client can get a more accurate value for offset by getting the current wall
+ *   from the cloc component and subtracting it from nWallTimeAtMedia. 
+ */
+
+typedef struct OMX_TIME_MEDIATIMETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
+                                     *   from others. Copied from the media time request. 
+                                     *   A value of zero is reserved for time scale updates. */
+    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
+    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
+                                     *   requested then this is the current media time. */ 
+    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
+                                     *   request was actually fulfilled early */
+
+    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
+                                     *   A client may compare this value to current
+                                     *   media time obtained from the Clock Component to determine
+                                     *   the wall time until the media timestamp is really
+                                     *   current. */
+    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
+    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
+                                    /**< State of the media time. */
+} OMX_TIME_MEDIATIMETYPE;  
+
+/** Structure representing the current media time scale factor. Applicable only to clock 
+ *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
+ *  the clock component client ports. Upon recieving this config the clock component changes 
+ *  the rate by which the media time increases or decreases effectively implementing trick modes. 
+ */ 
+typedef struct OMX_TIME_CONFIG_SCALETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
+                                     * scaling the media time */
+} OMX_TIME_CONFIG_SCALETYPE;
+ 
+/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
+#define OMX_CLOCKPORT0 0x00000001
+#define OMX_CLOCKPORT1 0x00000002
+#define OMX_CLOCKPORT2 0x00000004
+#define OMX_CLOCKPORT3 0x00000008
+#define OMX_CLOCKPORT4 0x00000010
+#define OMX_CLOCKPORT5 0x00000020
+#define OMX_CLOCKPORT6 0x00000040
+#define OMX_CLOCKPORT7 0x00000080
+
+/** Structure representing the current mode of the media clock. 
+ *  IL Client uses this config to change or query the mode of the 
+ *  media clock of the clock component. Applicable only to clock
+ *  component. 
+ *  
+ *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
+ *  starts immediately at the prescribed start time. If
+ *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
+ *  the given nStartTime and waits for all clients specified in the 
+ *  nWaitMask to send starttimes (via 
+ *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
+ *  the media clock using the earliest start time supplied. */    
+typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
+                                 *   information */
+    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
+    OMX_TICKS nStartTime;       /**< Start time of the media time. */
+    OMX_TICKS nOffset;          /**< Time to offset the media time by 
+                                 * (e.g. preroll). Media time will be
+                                 * reported to be nOffset ticks earlier.     
+                                 */
+    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
+} OMX_TIME_CONFIG_CLOCKSTATETYPE;
+
+/** Structure representing the reference clock currently being used to
+ *  compute media time. IL client uses this config to change or query the 
+ *  clock component's active reference clock */
+typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
+} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
+
+/** Descriptor for setting specifics of power type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_POWERTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
+} OMX_OTHER_CONFIG_POWERTYPE;
+
+
+/** Descriptor for setting specifics of stats type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_STATSTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    /* what goes here */
+} OMX_OTHER_CONFIG_STATSTYPE;
+
+
+/**
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output other 
+ * path.
+ */
+typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
+    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
+} OMX_OTHER_PORTDEFINITIONTYPE;
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< Indicates which port to set */
+    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
+} OMX_OTHER_PARAM_PORTFORMATTYPE; 
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_Types.h b/third_party/openmax/il/OMX_Types.h
new file mode 100644
index 0000000..75fc715
--- /dev/null
+++ b/third_party/openmax/il/OMX_Types.h
@@ -0,0 +1,361 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Types.h - OpenMax IL version 1.1.2
+ *  The OMX_Types header file contains the primitive type definitions used by 
+ *  the core, the application and the component.  This file may need to be
+ *  modified to be used on systems that do not have "char" set to 8 bits, 
+ *  "short" set to 16 bits and "long" set to 32 bits.
+ */
+
+#ifndef OMX_Types_h
+#define OMX_Types_h
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/** The OMX_API and OMX_APIENTRY are platform specific definitions used
+ *  to declare OMX function prototypes.  They are modified to meet the
+ *  requirements for a particular platform */
+#ifdef __SYMBIAN32__   
+#   ifdef __OMX_EXPORTS
+#       define OMX_API __declspec(dllexport)
+#   else
+#       ifdef _WIN32
+#           define OMX_API __declspec(dllexport) 
+#       else
+#           define OMX_API __declspec(dllimport)
+#       endif
+#   endif
+#else
+#   ifdef _WIN32
+#      ifdef __OMX_EXPORTS
+#          define OMX_API __declspec(dllexport)
+#      else
+#          define OMX_API __declspec(dllimport)
+#      endif
+#   else
+#      ifdef __OMX_EXPORTS
+#          define OMX_API
+#      else
+#          define OMX_API extern
+#      endif
+#   endif
+#endif
+
+#ifndef OMX_APIENTRY
+#define OMX_APIENTRY 
+#endif 
+
+/** OMX_IN is used to identify inputs to an OMX function.  This designation 
+    will also be used in the case of a pointer that points to a parameter 
+    that is used as an output. */
+#ifndef OMX_IN
+#define OMX_IN
+#endif
+
+/** OMX_OUT is used to identify outputs from an OMX function.  This 
+    designation will also be used in the case of a pointer that points 
+    to a parameter that is used as an input. */
+#ifndef OMX_OUT
+#define OMX_OUT
+#endif
+
+
+/** OMX_INOUT is used to identify parameters that may be either inputs or
+    outputs from an OMX function at the same time.  This designation will 
+    also be used in the case of a pointer that  points to a parameter that 
+    is used both as an input and an output. */
+#ifndef OMX_INOUT
+#define OMX_INOUT
+#endif
+
+/** OMX_ALL is used to as a wildcard to select all entities of the same type
+ *  when specifying the index, or referring to a object by an index.  (i.e.
+ *  use OMX_ALL to indicate all N channels). When used as a port index
+ *  for a config or parameter this OMX_ALL denotes that the config or
+ *  parameter applies to the entire component not just one port. */
+#define OMX_ALL 0xFFFFFFFF
+
+/** In the following we define groups that help building doxygen documentation */
+
+/** @defgroup core OpenMAX IL core
+ * Functions and structure related to the OMX IL core
+ */
+ 
+ /** @defgroup comp OpenMAX IL component
+ * Functions and structure related to the OMX IL component
+ */
+ 
+/** @defgroup rpm Resource and Policy Management 
+ * Structures for resource and policy management of components
+ */
+
+/** @defgroup buf Buffer Management
+ * Buffer handling functions and structures
+ */
+  
+/** @defgroup tun Tunneling
+ * @ingroup core comp
+ * Structures and functions to manage tunnels among component ports
+ */
+ 
+/** @defgroup cp Content Pipes
+ *  @ingroup core
+ */
+ 
+ /** @defgroup metadata Metadata handling
+  * 
+  */ 
+
+/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
+typedef uint8_t OMX_U8;
+
+/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
+typedef int8_t OMX_S8;
+
+/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
+typedef uint16_t OMX_U16;
+
+/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
+typedef int16_t OMX_S16;
+
+/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
+typedef uint32_t OMX_U32;
+
+/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
+typedef int32_t OMX_S32;
+
+
+/* Users with compilers that cannot accept the "long long" designation should
+   define the OMX_SKIP64BIT macro.  It should be noted that this may cause 
+   some components to fail to compile if the component was written to require
+   64 bit integral types.  However, these components would NOT compile anyway
+   since the compiler does not support the way the component was written.
+*/
+#ifndef OMX_SKIP64BIT
+#ifdef __SYMBIAN32__
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long OMX_S64;
+
+#elif defined(WIN32)
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
+typedef unsigned __int64  OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed   __int64  OMX_S64;
+
+#else /* WIN32 */
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef uint64_t OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef int64_t OMX_S64;
+
+#endif /* WIN32 */
+#endif
+
+
+/** The OMX_BOOL type is intended to be used to represent a true or a false 
+    value when passing parameters to and from the OMX core and components.  The
+    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
+ */
+typedef enum OMX_BOOL {
+    OMX_FALSE = 0,
+    OMX_TRUE = !OMX_FALSE,
+    OMX_BOOL_MAX = 0x7FFFFFFF
+} OMX_BOOL; 
+ 
+/** The OMX_PTR type is intended to be used to pass pointers between the OMX
+    applications and the OMX Core and components.  This is a 32 bit pointer and
+    is aligned on a 32 bit boundary.
+ */
+typedef void* OMX_PTR;
+
+/** The OMX_STRING type is intended to be used to pass "C" type strings between
+    the application and the core and component.  The OMX_STRING type is a 32 
+    bit pointer to a zero terminated string.  The  pointer is word aligned and 
+    the string is byte aligned.  
+ */
+typedef char* OMX_STRING;
+
+/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
+    buffers between the application and the component and core.  The OMX_BYTE 
+    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
+    aligned and the string is byte aligned.
+ */
+typedef unsigned char* OMX_BYTE;
+
+/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
+    at runtime.  This identifier should be generated by a component in a way
+    that guarantees that every instance of the identifier running on the system
+    is unique. */
+typedef unsigned char OMX_UUIDTYPE[128];
+
+/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
+    an output port.  This enumeration is common across all component types.    
+ */
+typedef enum OMX_DIRTYPE
+{
+    OMX_DirInput,              /**< Port is an input port */
+    OMX_DirOutput,             /**< Port is an output port */
+    OMX_DirMax = 0x7FFFFFFF
+} OMX_DIRTYPE;
+
+/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
+    for numerical data (i.e. big endian, or little endian).    
+ */
+typedef enum OMX_ENDIANTYPE
+{
+    OMX_EndianBig, /**< big endian */
+    OMX_EndianLittle, /**< little endian */
+    OMX_EndianMax = 0x7FFFFFFF
+} OMX_ENDIANTYPE;
+
+
+/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
+    is signed or unsigned
+ */
+typedef enum OMX_NUMERICALDATATYPE
+{
+    OMX_NumericalDataSigned, /**< signed data */
+    OMX_NumericalDataUnsigned, /**< unsigned data */
+    OMX_NumercialDataMax = 0x7FFFFFFF
+} OMX_NUMERICALDATATYPE;
+
+
+/** Unsigned bounded value type */
+typedef struct OMX_BU32 {
+    OMX_U32 nValue; /**< actual value */
+    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BU32;
+
+
+/** Signed bounded value type */
+typedef struct OMX_BS32 {
+    OMX_S32 nValue; /**< actual value */
+    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BS32;
+
+
+/** Structure representing some time or duration in microseconds. This structure
+  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
+  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
+  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
+  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
+  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
+  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
+  *  or minus 35 minutes).
+  *
+  *  Implementations with limited precision may convert the signed 64 bit value to 
+  *  a signed 32 bit value internally but risk loss of precision.  
+  */
+#ifndef OMX_SKIP64BIT
+typedef OMX_S64 OMX_TICKS;
+#else
+typedef struct OMX_TICKS
+{
+    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
+    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
+} OMX_TICKS;
+#endif
+#define OMX_TICKS_PER_SECOND 1000000
+
+/** Define the public interface for the OMX Handle.  The core will not use
+    this value internally, but the application should only use this value.
+ */
+typedef void* OMX_HANDLETYPE;
+
+typedef struct OMX_MARKTYPE
+{
+    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will 
+                                                generate a mark event upon 
+                                                processing the mark. */
+    OMX_PTR pMarkData;   /**< Application specific data associated with 
+                              the mark sent on a mark event to disambiguate 
+                              this mark from others. */
+} OMX_MARKTYPE;
+
+
+/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the display 
+ *  or can be used by a audio port for native audio rendering */
+typedef void* OMX_NATIVE_DEVICETYPE;
+
+/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the window */
+typedef void* OMX_NATIVE_WINDOWTYPE;
+
+
+/** Define the OMX IL version that corresponds to this set of header files.
+ *  We also define a combined version that can be used to write or compare
+ *  values of the 32bit nVersion field, assuming a little endian architecture */
+#define OMX_VERSION_MAJOR 1
+#define OMX_VERSION_MINOR 1
+#define OMX_VERSION_REVISION 2
+#define OMX_VERSION_STEP 0
+
+#define OMX_VERSION ((OMX_VERSION_STEP<<24) | (OMX_VERSION_REVISION<<16) | (OMX_VERSION_MINOR<<8) | OMX_VERSION_MAJOR)
+
+
+/** The OMX_VERSIONTYPE union is used to specify the version for
+    a structure or component.  For a component, the version is entirely
+    specified by the component vendor.  Components doing the same function
+    from different vendors may or may not have the same version.  For 
+    structures, the version shall be set by the entity that allocates the
+    structure.  For structures specified in the OMX 1.1 specification, the
+    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
+    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
+    by accessing one of the structure elements to, for example, check only
+    the Major revision.
+ */
+typedef union OMX_VERSIONTYPE
+{
+    struct
+    {
+        OMX_U8 nVersionMajor;   /**< Major version accessor element */
+        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
+        OMX_U8 nRevision;       /**< Revision version accessor element */
+        OMX_U8 nStep;           /**< Step version accessor element */
+    } s;
+    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
+                                    version easily done in a single word
+                                    size copy/compare operation */
+} OMX_VERSIONTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/third_party/openmax/il/OMX_Video.h b/third_party/openmax/il/OMX_Video.h
new file mode 100644
index 0000000..4094809
--- /dev/null
+++ b/third_party/openmax/il/OMX_Video.h
@@ -0,0 +1,1060 @@
+/**
+ * Copyright (c) 2016 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** 
+ *  @file OMX_Video.h - OpenMax IL version 1.1.2
+ *  The structures is needed by Video components to exchange parameters 
+ *  and configuration data with OMX components.
+ */
+#ifndef OMX_Video_h
+#define OMX_Video_h
+
+/** @defgroup video OpenMAX IL Video Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Video domain
+ * @{
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully 
+ */
+
+#include <OMX_IVCommon.h>
+
+
+/**
+ * Enumeration used to define the possible video compression codings.  
+ * NOTE:  This essentially refers to file extensions. If the coding is 
+ *        being used to specify the ENCODE type, then additional work 
+ *        must be done to configure the exact flavor of the compression 
+ *        to be used.  For decode cases where the user application can 
+ *        not differentiate between MPEG-4 and H.264 bit streams, it is 
+ *        up to the codec to handle this.
+ */
+typedef enum OMX_VIDEO_CODINGTYPE {
+    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
+    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
+    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
+    OMX_VIDEO_CodingH263,       /**< H.263 */
+    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
+    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
+    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
+    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
+    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
+    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_CodingMax = 0x7FFFFFFF
+} OMX_VIDEO_CODINGTYPE;
+
+
+/**
+ * Data structure used to define a video path.  The number of Video paths for 
+ * input and output will vary by type of the Video component.  
+ * 
+ *    Input (aka Source) : zero Inputs, one Output,
+ *    Splitter           : one Input, 2 or more Outputs,
+ *    Processing Element : one Input, one output,
+ *    Mixer              : 2 or more inputs, one output,
+ *    Output (aka Sink)  : one Input, zero outputs.
+ * 
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output video 
+ * path.  If additional vendor specific data is required, it should be 
+ * transmitted to the component using the CustomCommand function.  Compliant 
+ * components will prepopulate this structure with optimal values during the 
+ * GetDefaultInitParams command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a 
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on channel if 
+ *                          uncompressed format is used.  Use 0 for unknown,
+ *                          don't care or variable
+ *  nFrameHeight          : Height of frame to be used on channel if 
+ *                          uncompressed format is used. Use 0 for unknown,
+ *                          don't care or variable
+ *  nStride               : Number of bytes per span of an image 
+ *                          (i.e. indicates the number of bytes to get
+ *                          from span N to span N+1, where negative stride
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  nBitrate              : Bit rate of frame to be used on channel if 
+ *                          compressed format is used. Use 0 for unknown, 
+ *                          don't care or variable
+ *  xFramerate            : Frame rate to be used on channel if uncompressed 
+ *                          format is used. Use 0 for unknown, don't care or 
+ *                          variable.  Units are Q16 frames per second.
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of the 
+ *                          component. When OMX_VIDEO_CodingUnused is 
+ *                          specified, eColorFormat is used
+ *  eColorFormat : Decompressed format used by this component
+ *  pNativeWindow : Platform specific reference for a window object if a 
+ *                          display sink , otherwise this field is 0x0. 
+ */
+typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth;
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;
+    OMX_U32 nSliceHeight;
+    OMX_U32 nBitrate;
+    OMX_U32 xFramerate;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_VIDEO_PORTDEFINITIONTYPE;
+
+/**  
+ * Port format parameter.  This structure is used to enumerate the various 
+ * data input/output format supported by the port.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from 
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the 
+ *                       component. When OMX_VIDEO_CodingUnused is specified, 
+ *                       eColorFormat is used 
+ *  eColorFormat       : Decompressed format used by this component
+ *  xFrameRate         : Indicates the video frame rate in Q16 format
+ */
+typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat; 
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_U32 xFramerate;
+} OMX_VIDEO_PARAM_PORTFORMATTYPE;
+
+
+/**
+ * This is a structure for configuring video compression quantization 
+ * parameter values.  Codecs may support different QP values for different
+ * frame types.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info
+ *  nPortIndex : Port that this structure applies to
+ *  nQpI       : QP value to use for index frames
+ *  nQpP       : QP value to use for P frames
+ *  nQpB       : QP values to use for bidirectional frames 
+ */
+typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nQpI;
+    OMX_U32 nQpP;
+    OMX_U32 nQpB;
+} OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
+
+
+/** 
+ * Structure for configuration of video fast update parameters. 
+ *  
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info 
+ *  nPortIndex : Port that this structure applies to
+ *  bEnableVFU : Enable/Disable video fast update
+ *  nFirstGOB  : Specifies the number of the first macroblock row
+ *  nFirstMB   : specifies the first MB relative to the specified first GOB
+ *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB 
+ *               and nFirstMB
+ */
+typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_BOOL bEnableVFU;      
+    OMX_U32 nFirstGOB;                            
+    OMX_U32 nFirstMB;                            
+    OMX_U32 nNumMBs;                                  
+} OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
+
+
+/** 
+ * Enumeration of possible bitrate control types 
+ */
+typedef enum OMX_VIDEO_CONTROLRATETYPE {
+    OMX_Video_ControlRateDisable,
+    OMX_Video_ControlRateVariable,
+    OMX_Video_ControlRateConstant,
+    OMX_Video_ControlRateVariableSkipFrames,
+    OMX_Video_ControlRateConstantSkipFrames,
+    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_ControlRateMax = 0x7FFFFFFF
+} OMX_VIDEO_CONTROLRATETYPE;
+
+
+/** 
+ * Structure for configuring bitrate mode of a codec. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  eControlRate   : Control rate type enum
+ *  nTargetBitrate : Target bitrate to encode with
+ */
+typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
+    OMX_U32 nSize;                          
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;                     
+    OMX_VIDEO_CONTROLRATETYPE eControlRate; 
+    OMX_U32 nTargetBitrate;                 
+} OMX_VIDEO_PARAM_BITRATETYPE;
+
+
+/** 
+ * Enumeration of possible motion vector (MV) types 
+ */
+typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
+    OMX_Video_MotionVectorPixel,
+    OMX_Video_MotionVectorHalfPel,
+    OMX_Video_MotionVectorQuarterPel,
+    OMX_Video_MotionVectorEighthPel,
+    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_MotionVectorMax = 0x7FFFFFFF
+} OMX_VIDEO_MOTIONVECTORTYPE;
+
+
+/**
+ * Structure for configuring the number of motion vectors used as well
+ * as their accuracy.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the struct in bytes
+ *  nVersion         : OMX spec version info
+ *  nPortIndex       : port that this structure applies to
+ *  eAccuracy        : Enumerated MV accuracy
+ *  bUnrestrictedMVs : Allow unrestricted MVs
+ *  bFourMV          : Allow use of 4 MVs
+ *  sXSearchRange    : Search range in horizontal direction for MVs
+ *  sYSearchRange    : Search range in vertical direction for MVs
+ */
+typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
+    OMX_BOOL bUnrestrictedMVs;
+    OMX_BOOL bFourMV;
+    OMX_S32 sXSearchRange;
+    OMX_S32 sYSearchRange;
+} OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
+
+
+/** 
+ * Enumeration of possible methods to use for Intra Refresh 
+ */
+typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
+    OMX_VIDEO_IntraRefreshCyclic,
+    OMX_VIDEO_IntraRefreshAdaptive,
+    OMX_VIDEO_IntraRefreshBoth,
+    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
+} OMX_VIDEO_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for configuring intra refresh mode 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to
+ *  eRefreshMode : Cyclic, Adaptive, or Both
+ *  nAirMBs      : Number of intra macroblocks to refresh in a frame when 
+ *                 AIR is enabled
+ *  nAirRef      : Number of times a motion marked macroblock has to be  
+ *                 intra coded
+ *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"  
+ *                 when CIR is enabled
+ */
+typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
+    OMX_U32 nAirMBs;
+    OMX_U32 nAirRef;
+    OMX_U32 nCirMBs;
+} OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for enabling various error correction methods for video 
+ * compression.
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information 
+ *  nPortIndex              : Port that this structure applies to 
+ *  bEnableHEC              : Enable/disable header extension codes (HEC)
+ *  bEnableResync           : Enable/disable resynchronization markers
+ *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be 
+ *                            applied in the stream 
+ *  bEnableDataPartitioning : Enable/disable data partitioning 
+ *  bEnableRVLC             : Enable/disable reversible variable length 
+ *                            coding
+ */
+typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnableHEC;
+    OMX_BOOL bEnableResync;
+    OMX_U32  nResynchMarkerSpacing;
+    OMX_BOOL bEnableDataPartitioning;
+    OMX_BOOL bEnableRVLC;
+} OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
+
+
+/** 
+ * Configuration of variable block-size motion compensation (VBSMC) 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  b16x16     : Enable inter block search 16x16
+ *  b16x8      : Enable inter block search 16x8
+ *  b8x16      : Enable inter block search 8x16
+ *  b8x8       : Enable inter block search 8x8
+ *  b8x4       : Enable inter block search 8x4
+ *  b4x8       : Enable inter block search 4x8
+ *  b4x4       : Enable inter block search 4x4
+ */
+typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_BOOL b16x16; 
+    OMX_BOOL b16x8; 
+    OMX_BOOL b8x16;
+    OMX_BOOL b8x8;
+    OMX_BOOL b8x4;
+    OMX_BOOL b4x8;
+    OMX_BOOL b4x4;
+} OMX_VIDEO_PARAM_VBSMCTYPE;
+
+
+/** 
+ * H.263 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ *
+ * ENUMS:
+ *  Baseline           : Baseline Profile: H.263 (V1), no optional modes                                                    
+ *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility 
+ *                       Profile: H.263+ (V2), includes annexes I, J, L.4
+ *                       and T
+ *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1), 
+ *                       includes annex F                                    
+ *  ISWV2              : Interactive Streaming Wireless Profile: H.263+ 
+ *                       (V2), includes annexes I, J, K and T                 
+ *  ISWV3              : Interactive Streaming Wireless Profile: H.263++  
+ *                       (V3), includes profile 3 and annexes V and W.6.3.8   
+ *  HighCompression    : Conversational High Compression Profile: H.263++  
+ *                       (V3), includes profiles 1 & 2 and annexes D and U   
+ *  Internet           : Conversational Internet Profile: H.263++ (V3),  
+ *                       includes profile 5 and annex K                       
+ *  Interlace          : Conversational Interlace Profile: H.263++ (V3),  
+ *                       includes profile 5 and annex W.6.3.11               
+ *  HighLatency        : High Latency Profile: H.263++ (V3), includes  
+ *                       profile 6 and annexes O.1 and P.5                       
+ */
+typedef enum OMX_VIDEO_H263PROFILETYPE {
+    OMX_VIDEO_H263ProfileBaseline            = 0x01,        
+    OMX_VIDEO_H263ProfileH320Coding          = 0x02,          
+    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,  
+    OMX_VIDEO_H263ProfileISWV2               = 0x08,               
+    OMX_VIDEO_H263ProfileISWV3               = 0x10,               
+    OMX_VIDEO_H263ProfileHighCompression     = 0x20,     
+    OMX_VIDEO_H263ProfileInternet            = 0x40,            
+    OMX_VIDEO_H263ProfileInterlace           = 0x80,           
+    OMX_VIDEO_H263ProfileHighLatency         = 0x100,         
+    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF  
+} OMX_VIDEO_H263PROFILETYPE;
+
+
+/** 
+ * H.263 level types, each level indicates support for various frame sizes, 
+ * bit rates, decoder frame rates.
+ */
+typedef enum OMX_VIDEO_H263LEVELTYPE {
+    OMX_VIDEO_H263Level10  = 0x01,  
+    OMX_VIDEO_H263Level20  = 0x02,      
+    OMX_VIDEO_H263Level30  = 0x04,      
+    OMX_VIDEO_H263Level40  = 0x08,      
+    OMX_VIDEO_H263Level45  = 0x10,      
+    OMX_VIDEO_H263Level50  = 0x20,      
+    OMX_VIDEO_H263Level60  = 0x40,      
+    OMX_VIDEO_H263Level70  = 0x80, 
+    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_H263LEVELTYPE;
+
+
+/** 
+ * Specifies the picture type. These values should be OR'd to signal all 
+ * pictures types which are allowed.
+ *
+ * ENUMS:
+ *  Generic Picture Types:          I, P and B
+ *  H.263 Specific Picture Types:   SI and SP
+ *  H.264 Specific Picture Types:   EI and EP
+ *  MPEG-4 Specific Picture Types:  S
+ */
+typedef enum OMX_VIDEO_PICTURETYPE {
+    OMX_VIDEO_PictureTypeI   = 0x01,
+    OMX_VIDEO_PictureTypeP   = 0x02,
+    OMX_VIDEO_PictureTypeB   = 0x04,
+    OMX_VIDEO_PictureTypeSI  = 0x08,
+    OMX_VIDEO_PictureTypeSP  = 0x10,
+    OMX_VIDEO_PictureTypeEI  = 0x11,
+    OMX_VIDEO_PictureTypeEP  = 0x12,
+    OMX_VIDEO_PictureTypeS   = 0x14,
+    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
+} OMX_VIDEO_PICTURETYPE;
+
+
+/** 
+ * H.263 Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                    : Size of the structure in bytes
+ *  nVersion                 : OMX specification version information 
+ *  nPortIndex               : Port that this structure applies to
+ *  nPFrames                 : Number of P frames between each I frame
+ *  nBFrames                 : Number of B frames between each I frame
+ *  eProfile                 : H.263 profile(s) to use
+ *  eLevel                   : H.263 level(s) to use
+ *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE 
+ *                             (specified in the 1998 version of H.263) to 
+ *                             indicate custom picture sizes or clock 
+ *                             frequencies 
+ *  nAllowedPictureTypes     : Specifies the picture types allowed in the 
+ *                             bitstream
+ *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is 
+ *                             not constrained. It is recommended to change 
+ *                             the value of the RTYPE bit for each reference 
+ *                             picture in error-free communication
+ *  nPictureHeaderRepetition : Specifies the frequency of picture header 
+ *                             repetition
+ *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB  
+ *                             headers in units of GOBs
+ */
+typedef struct OMX_VIDEO_PARAM_H263TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_VIDEO_H263PROFILETYPE eProfile;
+	OMX_VIDEO_H263LEVELTYPE eLevel;
+    OMX_BOOL bPLUSPTYPEAllowed;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_BOOL bForceRoundingTypeToZero;
+    OMX_U32 nPictureHeaderRepetition;
+    OMX_U32 nGOBHeaderInterval;
+} OMX_VIDEO_PARAM_H263TYPE;
+
+
+/** 
+ * MPEG-2 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
+    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
+    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
+    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
+    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
+    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
+    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
+    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG2PROFILETYPE;
+
+
+/** 
+ * MPEG-2 level types, each level indicates support for various frame 
+ * sizes, bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
+    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */ 
+    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */ 
+    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */ 
+    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */   
+    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG2LEVELTYPE;
+
+
+/** 
+ * MPEG-2 params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nPFrames   : Number of P frames between each I frame
+ *  nBFrames   : Number of B frames between each I frame
+ *  eProfile   : MPEG-2 profile(s) to use
+ *  eLevel     : MPEG-2 levels(s) to use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
+    OMX_U32 nSize;           
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;      
+    OMX_U32 nPFrames;        
+    OMX_U32 nBFrames;        
+    OMX_VIDEO_MPEG2PROFILETYPE eProfile;
+	OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
+} OMX_VIDEO_PARAM_MPEG2TYPE;
+
+
+/** 
+ * MPEG-4 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ * 
+ * ENUMS:
+ *  - Simple Profile, Levels 1-3
+ *  - Simple Scalable Profile, Levels 1-2
+ *  - Core Profile, Levels 1-2
+ *  - Main Profile, Levels 2-4
+ *  - N-bit Profile, Level 2
+ *  - Scalable Texture Profile, Level 1
+ *  - Simple Face Animation Profile, Levels 1-2
+ *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
+ *  - Basic Animated Texture Profile, Levels 1-2
+ *  - Hybrid Profile, Levels 1-2
+ *  - Advanced Real Time Simple Profiles, Levels 1-4
+ *  - Core Scalable Profile, Levels 1-3
+ *  - Advanced Coding Efficiency Profile, Levels 1-4
+ *  - Advanced Core Profile, Levels 1-2
+ *  - Advanced Scalable Texture, Levels 2-3
+ */
+typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
+    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,        
+    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,    
+    OMX_VIDEO_MPEG4ProfileCore             = 0x04,              
+    OMX_VIDEO_MPEG4ProfileMain             = 0x08,             
+    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,              
+    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,   
+    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,        
+    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,         
+    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,     
+    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,            
+    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,  
+    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,      
+    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,    
+    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,      
+    OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
+    OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
+    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG4PROFILETYPE;
+
+
+/** 
+ * MPEG-4 level types, each level indicates support for various frame 
+ * sizes, bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
+    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */   
+    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */   
+    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */ 
+    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */ 
+    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */ 
+    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */  
+    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */  
+    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */  
+    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG4LEVELTYPE;
+
+
+/** 
+ * MPEG-4 configuration.  This structure handles configuration options
+ * which are specific to MPEG4 algorithms
+ *
+ * STRUCT MEMBERS:
+ *  nSize                : Size of the structure in bytes
+ *  nVersion             : OMX specification version information
+ *  nPortIndex           : Port that this structure applies to
+ *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+ 
+ *                         Annex K). Put zero if not used
+ *  bSVH                 : Enable Short Video Header mode
+ *  bGov                 : Flag to enable GOV
+ *  nPFrames             : Number of P frames between each I frame (also called 
+ *                         GOV period)
+ *  nBFrames             : Number of B frames between each I frame
+ *  nIDCVLCThreshold     : Value of intra DC VLC threshold
+ *  bACPred              : Flag to use ac prediction
+ *  nMaxPacketSize       : Maximum size of packet in bytes.
+ *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4. 
+ *                         Interpreted as described in MPEG4 standard.
+ *  eProfile             : MPEG-4 profile(s) to use.
+ *  eLevel               : MPEG-4 level(s) to use.
+ *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
+ *  nHeaderExtension     : Specifies the number of consecutive video packet
+ *                         headers within a VOP
+ *  bReversibleVLC       : Specifies whether reversible variable length coding 
+ *                         is in use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nSliceHeaderSpacing;
+    OMX_BOOL bSVH;
+    OMX_BOOL bGov;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_U32 nIDCVLCThreshold;
+    OMX_BOOL bACPred;
+    OMX_U32 nMaxPacketSize;
+    OMX_U32 nTimeIncRes;
+    OMX_VIDEO_MPEG4PROFILETYPE eProfile;
+    OMX_VIDEO_MPEG4LEVELTYPE eLevel;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_U32 nHeaderExtension;
+    OMX_BOOL bReversibleVLC;
+} OMX_VIDEO_PARAM_MPEG4TYPE;
+
+
+/** 
+ * WMV Versions 
+ */
+typedef enum OMX_VIDEO_WMVFORMATTYPE {
+    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
+    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
+    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
+    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
+    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
+} OMX_VIDEO_WMVFORMATTYPE;
+
+
+/** 
+ * WMV Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  eFormat    : Version of WMV stream / data
+ */
+typedef struct OMX_VIDEO_PARAM_WMVTYPE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_WMVFORMATTYPE eFormat;
+} OMX_VIDEO_PARAM_WMVTYPE;
+
+
+/** 
+ * Real Video Version 
+ */
+typedef enum OMX_VIDEO_RVFORMATTYPE {
+    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
+    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
+    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
+    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
+    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
+} OMX_VIDEO_RVFORMATTYPE;
+
+
+/** 
+ * Real Video Params 
+ *
+ * STUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information 
+ *  nPortIndex         : Port that this structure applies to
+ *  eFormat            : Version of RV stream / data
+ *  nBitsPerPixel      : Bits per pixel coded in the frame
+ *  nPaddedWidth       : Padded width in pixel of a video frame
+ *  nPaddedHeight      : Padded Height in pixels of a video frame
+ *  nFrameRate         : Rate of video in frames per second
+ *  nBitstreamFlags    : Flags which internal information about the bitstream
+ *  nBitstreamVersion  : Bitstream version
+ *  nMaxEncodeFrameSize: Max encoded frame size
+ *  bEnablePostFilter  : Turn on/off post filter
+ *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
+ *  bEnableLatencyMode : When enabled, the decoder does not display a decoded 
+ *                       frame until it has detected that no enhancement layer 
+ *  					 frames or dependent B frames will be coming. This 
+ *  					 detection usually occurs when a subsequent non-B 
+ *  					 frame is encountered 
+ */
+typedef struct OMX_VIDEO_PARAM_RVTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_RVFORMATTYPE eFormat;
+    OMX_U16 nBitsPerPixel;
+    OMX_U16 nPaddedWidth;
+    OMX_U16 nPaddedHeight;
+    OMX_U32 nFrameRate;
+    OMX_U32 nBitstreamFlags;
+    OMX_U32 nBitstreamVersion;
+    OMX_U32 nMaxEncodeFrameSize;
+    OMX_BOOL bEnablePostFilter;
+    OMX_BOOL bEnableTemporalInterpolation;
+    OMX_BOOL bEnableLatencyMode;
+} OMX_VIDEO_PARAM_RVTYPE;
+
+
+/** 
+ * AVC profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_AVCPROFILETYPE {
+    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
+    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
+    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
+    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
+    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
+    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
+    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
+    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF  
+} OMX_VIDEO_AVCPROFILETYPE;
+
+
+/** 
+ * AVC level types, each level indicates support for various frame sizes, 
+ * bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_AVCLEVELTYPE {
+    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
+    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
+    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
+    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
+    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
+    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
+    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
+    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
+    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
+    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
+    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
+    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
+    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
+    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
+    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
+    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
+    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_AVCLEVELTYPE;
+
+
+/** 
+ * AVC loop filter modes 
+ *
+ * OMX_VIDEO_AVCLoopFilterEnable               : Enable
+ * OMX_VIDEO_AVCLoopFilterDisable              : Disable
+ * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
+ */
+typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
+    OMX_VIDEO_AVCLoopFilterEnable = 0,
+    OMX_VIDEO_AVCLoopFilterDisable,
+    OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
+    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCLOOPFILTERTYPE;
+
+
+/** 
+ * AVC params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                     : Size of the structure in bytes
+ *  nVersion                  : OMX specification version information
+ *  nPortIndex                : Port that this structure applies to
+ *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put  
+ *                              zero if not used
+ *  nPFrames                  : Number of P frames between each I frame
+ *  nBFrames                  : Number of B frames between each I frame
+ *  bUseHadamard              : Enable/disable Hadamard transform
+ *  nRefFrames                : Max number of reference frames to use for inter
+ *                              motion search (1-16)
+ *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
+ *                              frame buffer of trailing frames list), B frame
+ *                              support
+ *  nRefIdxForward            : Pic param set ref frame index (index into ref
+ *                              frame buffer of forward frames list), B frame
+ *                              support
+ *  bEnableUEP                : Enable/disable unequal error protection. This 
+ *                              is only valid of data partitioning is enabled.
+ *  bEnableFMO                : Enable/disable flexible macroblock ordering
+ *  bEnableASO                : Enable/disable arbitrary slice ordering
+ *  bEnableRS                 : Enable/disable sending of redundant slices
+ *  eProfile                  : AVC profile(s) to use
+ *  eLevel                    : AVC level(s) to use
+ *  nAllowedPictureTypes      : Specifies the picture types allowed in the 
+ *                              bitstream
+ *  bFrameMBsOnly             : specifies that every coded picture of the 
+ *                              coded video sequence is a coded frame 
+ *                              containing only frame macroblocks
+ *  bMBAFF                    : Enable/disable switching between frame and 
+ *                              field macroblocks within a picture
+ *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the 
+ *                              syntax elements for which two descriptors appear 
+ *                              in the syntax tables
+ *  bWeightedPPrediction      : Enable/disable weighted prediction shall not 
+ *                              be applied to P and SP slices
+ *  nWeightedBipredicitonMode : Default weighted prediction is applied to B 
+ *                              slices 
+ *  bconstIpred               : Enable/disable intra prediction
+ *  bDirect8x8Inference       : Specifies the method used in the derivation 
+ *                              process for luma motion vectors for B_Skip, 
+ *                              B_Direct_16x16 and B_Direct_8x8 as specified 
+ *                              in subclause 8.4.1.2 of the AVC spec 
+ *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
+ *                              mode used in B slice coding (related to 
+ *                              bDirect8x8Inference) . Spatial direct mode is 
+ *                              more common and should be the default.
+ *  nCabacInitIdx             : Index used to init CABAC contexts
+ *  eLoopFilterMode           : Enable/disable loop filter
+ */
+typedef struct OMX_VIDEO_PARAM_AVCTYPE {
+    OMX_U32 nSize;                 
+    OMX_VERSIONTYPE nVersion;      
+    OMX_U32 nPortIndex;            
+    OMX_U32 nSliceHeaderSpacing;  
+    OMX_U32 nPFrames;     
+    OMX_U32 nBFrames;     
+    OMX_BOOL bUseHadamard;
+    OMX_U32 nRefFrames;  
+	OMX_U32 nRefIdx10ActiveMinus1;
+	OMX_U32 nRefIdx11ActiveMinus1;
+    OMX_BOOL bEnableUEP;  
+    OMX_BOOL bEnableFMO;  
+    OMX_BOOL bEnableASO;  
+    OMX_BOOL bEnableRS;   
+    OMX_VIDEO_AVCPROFILETYPE eProfile;
+	OMX_VIDEO_AVCLEVELTYPE eLevel; 
+    OMX_U32 nAllowedPictureTypes;  
+	OMX_BOOL bFrameMBsOnly;        									
+    OMX_BOOL bMBAFF;               
+    OMX_BOOL bEntropyCodingCABAC;  
+    OMX_BOOL bWeightedPPrediction; 
+    OMX_U32 nWeightedBipredicitonMode; 
+    OMX_BOOL bconstIpred ;
+    OMX_BOOL bDirect8x8Inference;  
+	OMX_BOOL bDirectSpatialTemporal;
+	OMX_U32 nCabacInitIdc;
+	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
+} OMX_VIDEO_PARAM_AVCTYPE;
+
+typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
+   OMX_U32 nSize;                 
+   OMX_VERSIONTYPE nVersion;      
+   OMX_U32 nPortIndex;            
+   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
+                               This parameter is valid only for 
+                               OMX_IndexParamVideoProfileLevelQuerySupported index,
+                               For all other indices this parameter is to be ignored. */
+} OMX_VIDEO_PARAM_PROFILELEVELTYPE;
+
+/** 
+ * Structure for dynamically configuring bitrate mode of a codec. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  nEncodeBitrate : Target average bitrate to be generated in bps
+ */
+typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
+    OMX_U32 nSize;                          
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;                     
+    OMX_U32 nEncodeBitrate;                 
+} OMX_VIDEO_CONFIG_BITRATETYPE;
+
+/** 
+ * Defines Encoder Frame Rate setting
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information 
+ *  nPortIndex       : Port that this structure applies to
+ *  xEncodeFramerate : Encoding framerate represented in Q16 format
+ */
+typedef struct OMX_CONFIG_FRAMERATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 xEncodeFramerate; /* Q16 format */
+} OMX_CONFIG_FRAMERATETYPE;
+
+typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL IntraRefreshVOP;
+} OMX_CONFIG_INTRAREFRESHVOPTYPE;
+
+typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
+    OMX_U8  ErrMap[1];             /* Error map hint */
+} OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
+
+typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnabled;
+} OMX_CONFIG_MBERRORREPORTINGTYPE;
+
+typedef struct OMX_PARAM_MACROBLOCKSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nMacroblocks;
+} OMX_PARAM_MACROBLOCKSTYPE;
+
+/** 
+ * AVC Slice Mode modes 
+ *
+ * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
+ * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
+ * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
+ */
+typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
+    OMX_VIDEO_SLICEMODE_AVCDefault = 0,
+    OMX_VIDEO_SLICEMODE_AVCMBSlice,
+    OMX_VIDEO_SLICEMODE_AVCByteSlice,
+    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCSLICEMODETYPE;
+
+/** 
+ * AVC FMO Slice Mode Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNumSliceGroups : Specifies the number of slice groups
+ *  nSliceGroupMapType : Specifies the type of slice groups
+ *  eSliceMode : Specifies the type of slice
+ */
+typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U8 nNumSliceGroups;
+    OMX_U8 nSliceGroupMapType;
+    OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
+} OMX_VIDEO_PARAM_AVCSLICEFMO;
+
+/** 
+ * AVC IDR Period Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nIDRPeriod : Specifies periodicity of IDR frames
+ *  nPFrames : Specifies internal of coding Intra frames
+ */
+typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIDRPeriod;
+    OMX_U32 nPFrames;
+} OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
+
+/** 
+ * AVC NAL Size Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNaluBytes : Specifies the NAL unit size
+ */
+typedef struct OMX_VIDEO_CONFIG_NALSIZE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nNaluBytes;
+} OMX_VIDEO_CONFIG_NALSIZE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/third_party/openmax/il/OMX_VideoExt.h b/third_party/openmax/il/OMX_VideoExt.h
new file mode 100644
index 0000000..d3a6577
--- /dev/null
+++ b/third_party/openmax/il/OMX_VideoExt.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_VideoExt.h - OpenMax IL version 1.1.2
+ * The OMX_VideoExt header file contains extensions to the
+ * definitions used by both the application and the component to
+ * access video items.
+ */
+
+#ifndef OMX_VideoExt_h
+#define OMX_VideoExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Core.h>
+
+/** NALU Formats */
+typedef enum OMX_NALUFORMATSTYPE {
+    OMX_NaluFormatStartCodes = 1,
+    OMX_NaluFormatOneNaluPerBuffer = 2,
+    OMX_NaluFormatOneByteInterleaveLength = 4,
+    OMX_NaluFormatTwoByteInterleaveLength = 8,
+    OMX_NaluFormatFourByteInterleaveLength = 16,
+    OMX_NaluFormatCodingMax = 0x7FFFFFFF
+} OMX_NALUFORMATSTYPE;
+
+/** NAL Stream Format */
+typedef struct OMX_NALSTREAMFORMATTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_NALUFORMATSTYPE eNaluFormat;
+} OMX_NALSTREAMFORMATTYPE;
+
+/** Enum for standard video codingtype extensions */
+typedef enum OMX_VIDEO_CODINGEXTTYPE {
+    OMX_VIDEO_ExtCodingUnused = OMX_VIDEO_CodingKhronosExtensions,
+    OMX_VIDEO_CodingVP8,        /**< VP8/WebM */ 
+} OMX_VIDEO_CODINGEXTTYPE;
+
+/** VP8 profiles */
+typedef enum OMX_VIDEO_VP8PROFILETYPE {
+    OMX_VIDEO_VP8ProfileMain = 0x01,
+    OMX_VIDEO_VP8ProfileUnknown = 0x6EFFFFFF,
+    OMX_VIDEO_VP8ProfileMax = 0x7FFFFFFF
+} OMX_VIDEO_VP8PROFILETYPE;
+
+/** VP8 levels */
+typedef enum OMX_VIDEO_VP8LEVELTYPE {
+    OMX_VIDEO_VP8Level_Version0 = 0x01,
+    OMX_VIDEO_VP8Level_Version1 = 0x02,
+    OMX_VIDEO_VP8Level_Version2 = 0x04,
+    OMX_VIDEO_VP8Level_Version3 = 0x08,
+    OMX_VIDEO_VP8LevelUnknown = 0x6EFFFFFF,
+    OMX_VIDEO_VP8LevelMax = 0x7FFFFFFF
+} OMX_VIDEO_VP8LEVELTYPE;
+
+/** VP8 Param */
+typedef struct OMX_VIDEO_PARAM_VP8TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_VP8PROFILETYPE eProfile;
+    OMX_VIDEO_VP8LEVELTYPE eLevel;
+    OMX_U32 nDCTPartitions;
+    OMX_BOOL bErrorResilientMode;
+} OMX_VIDEO_PARAM_VP8TYPE;
+
+/** Structure for configuring VP8 reference frames */
+typedef struct OMX_VIDEO_VP8REFERENCEFRAMETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bPreviousFrameRefresh;
+    OMX_BOOL bGoldenFrameRefresh;
+    OMX_BOOL bAlternateFrameRefresh;
+    OMX_BOOL bUsePreviousFrame;
+    OMX_BOOL bUseGoldenFrame;
+    OMX_BOOL bUseAlternateFrame;
+} OMX_VIDEO_VP8REFERENCEFRAMETYPE;
+
+/** Structure for querying VP8 reference frame type */
+typedef struct OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bIsIntraFrame;
+    OMX_BOOL bIsGoldenOrAlternateFrame;
+} OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE;
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_VideoExt_h */
+/* File EOF */
-- 
2.17.1

